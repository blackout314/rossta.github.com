---
title: Fetching Resources from an API in Ruby
author: Ross Kaffenberger
published: false
summary: Use Ruby's Kernel#to_enum method to request resources from an API and handle pagination
author: Ross Kaffenberger
description: Next time you write a client to an API, consider using the Kernal#to_enum method to wrap your resource collection GET requests
pull_image: 'https://rossta.net/assets/images/icons/noun_138550.png'
series: Enumerable
tags:
  - Code
  - Ruby
---

# Outline

## Why?
* Trello is cool
* APIs fetching is a common need
* Consider the surface (use of Enum)
* Embrace Ruby's strengths (flexible)

## What/How
* Trello API setup
* Code example: Eager
* Code example: Collection class
* Code example: Enumerator

----

I love Trello and I love Ruby. Trello has as flexible API that's especially fun to work with in Ruby.
Since I've used Trello almost every day for work and personal projects for several years, there's a lot
of interesting data to explore. Though we'll focus on fetching paginated data with Trello as our source, the concepts we explore
here can be readily applied to any RESTful API of interest.

![Pages](icons/noun_83985.png)

When we need to retrieve lots of data from an API, we typically end up dealing with paginated data.
This is because there may be limits placed on the amount of data we can retrieve in a single request;
we can't get it all at once.

The thing with pages is, handling pages in our get __messy__.

You may want know how many Trello cards you marked as completed each month since last January, but you
don't __want to think about *pages*__.

There are a number of Trello endpoints that return collections of data, such as boards, lists,
cards, member, and actions like comments, copies, moves, etc. In some cases, Trello will provide a
default limit, typically 50, on the number of resources returned in a single request. To get more
data, we would need to provide additional __paginated__ requests. Let's take a look at how we'll do
this.

<aside>

For academic reasons, we're ignoring available Ruby clients for the Trello API. If you're interested in export with the Trello API further, through some open source wrappers, check out <%= link_to "ruby-trello", "https://github.com/jeremytregunna/ruby-trello" %> a popular library which aims to provide some ActiveRecord-like abstractions over Trello resources, and <%= link_to "tacokit.rb", "https://github.com/rossta/tacokit.rb" %>, a client with different design goals including simplicity and flexibility inspired by the ideas presented in this post and <%= link_to "octokit.rb", "https://github.com/octokit/octokit.rb" %> in aiming to be a "flat API client... that requires little knowledge of REST".

</aside>

### Trello World

First, some plumbing. The [Trello developer docs](https://developers.trello.com/) have some helpful information to get started quickly in javascript - here's the unofficial Ruby version.

While logged into your Trello account (you'll need one first), visit the [App Key page](https://trello.com/app-key) to retrieve your app **key**. We won't need the "secret" for this article.

Next, you'll generate an app **token**. Paste the following URL into your browser with your app **key** subsituted for the placeholder.

o```
https://trello.com/1/authorize?expiration=never&scope=read,write,account&response_type=token&name=Trello%20World&key=YOUR_KEY
```

Now that we have an app key and token, we can make authenticated requests to the Trello API.

As a quick test, let's read your member data

```ruby
https://api.trello.com/1/members/me?key=YOUR_KEY&token=YOUR_TOKEN
```

You should see a JSON response with attributes like your Trello id, username, bio, etc:

```json
{"id":"abcd1234","avatarHash":"5678wxyz", ... }
```

### Script Mode

Let's fetch some data in Ruby. For the following examples, we'll be using Ruby 2.2. To make HTTP requests, we'll also use the [http.rb](https://github.com/httprb/http), but feel free to subsitute with your HTTP client of choice. Install the gem yourself with `gem install http` or add it to your `Gemfile` and `bundle install`:

```
# Gemfile

gem "http"
```

To make things easier for the remainder, add the key and token as environment variables in your shell. For Mac/Linux users, something like this:

```ruby
export TRELLO_APP_KEY=your-key
export TRELLO_APP_TOKEN=your-token
```

Now, let's run Ruby version of our Trello World test.

```ruby
# trello.rb
require "http"

def app_key
  ENV.fetch("TRELLO_APP_KEY")
end

def app_token
  ENV.fetch("TRELLO_APP_TOKEN")
end

url = "https://api.trello.com/1/members/me?key=#{app_key}&token=#{app_token}"
puts HTTP.get(url).parse
```

If it worked correctly, you should see the same result we saw in your browser earlier.

Let's extract a helper building the url. We'll use `Addressable::URI`, which is available as a dependency of the http.rb gem as of version `1.0.0.pre1` or otherwise may be installed as `gem install addressable` or `gem "addressable"` in your `Gemfile`:

```ruby
# trello.rb
require "http"
require "addressable/uri"

def app_key
  ENV.fetch("TRELLO_APP_KEY")
end

def app_token
  ENV.fetch("TRELLO_APP_TOKEN")
end

def trello_url(path, params = {})
  auth_params = { key: app_key, token: app_token }

  Addressable::URI.new({
    scheme: "https",
    host: "api.trello.com",
    path: File.join("1", path),
    query_values: auth_params.merge(params)
  })
end

def get(path)
  HTTP.get(trello_url(path)).parse
end
```

### Let's Paginate

Trello provides endpoints for traversing actions taken on boards, cards, and lists. We'll add an alternative method to `get` that can handle pagination.

```ruby
def paginated_get(path, options = {})
  params  = options.dup
  max     = params.delete(:max) { 1000 }
  page    = params.delete(:page) { 1 }
  results = []

  loop do
    data = get(path, { page: page }.merge(params))

    page += 1
    results += data

    break if (data.empty? || results.length >= max)
  end

  results
end
```

Given a path and hash of parameter options, we'll build up an array of results by fetching the endpoint and incrementing the page number each time. Once either the max is reached or no more results are returned from the API, we'll exit the loop.

As a starting point, this works nicely. We can simply use `paginated_get` to collect up to 1000 results for a given resource without the caller caring about pages. Here's how we can grab the all the comments we've added to Trello cards:

```ruby
def comments(params = {})
  paginated_get("members/me/actions", filter: "commentCard")
end

comments
#=> [{"id"=>"abcd", "idMemberCreator"=>"wxyz", "data"=> {...} ...}, ...]
```

The main problem with this approach is that it forces the results to be eager loaded. Unless a max is specified in the method call, we could be waiting for up to 1000 comments to load - 20 requests of 50 - to execute before the results are returned.

### Stop, Enumerate, and Listen

We'll refactor our `paginated_get` method to take advantage of Ruby's `Enumerator`. I previous [described Enumerator](/blog/what-is-enumerator.html) and showed how it can be used to [generate infinite sequences in Ruby](/blog/infinite-sequences-in-ruby.html), including [Pascal's Triangle](/blog/pascals-triangle-with-rubys-enumerator.html). The main advantage will be to give callers flexibility to work with the results including filtering, searching, and lazy enumeration.

```ruby
def paginated_get(path, options = {})
  Enumerator.new do |y|
    params  = options.dup
    page    = params.delete(:page) { 1 }
    max     = params.delete(:max) { 1000 }
    total  = 0

    loop do
      data = get(path, { page: page }.merge(params))

      data.each do |element|
        y.yield element
      end

      break if (data.empty? || total >= max)

      page += 1
      total += data.length
    end
  end
end
```

We've got a few similarities with our first implementation. We still loop over repeated requests for successive pages until either the max is reach or no data is returned from the API. There are a few big differences though.

First, you'll notice we've wrapped our expression in `Enumerator` which will serve as the return value for `paginated_get`.

Using an enumerator may look strange but it offers a huge advantage over our first iteration. Enumerators allow callers to interact with data **as it is generated**. Conceptually, the enumerator represents the algorithm for retrieving or generating data in `Enumerable` form.
An enumerator implements the `Enumerable` module which means we can call familiar methods like `map`, `select`, `take`, and so on.

Instead of building up an internal array of results, enumerators provide a mechanism for yielding each element even though a block may not be given to the method (how mind blowing is that?).

Now we can use enumerator chains to doing something like the following, where we request comment data lazily, transform the API hash to comment text and select the first two addressed to Doris.

```ruby
puts comments.lazy.
   map { |axn| axn["data"]["text"] }.
   select { |txt| txt.start_with?("@mgerrior") }.
   take(2).force
```
We may not need to load all 1000 results to because the enumerators chain is evaluated for each item as it is yielded. This technique provides the caller with a great deal of flexibility. Eager loading can be delayed or avoided altogther, offering potential performance gains.

Here are magic lines from `paginated_get`:

```ruby
data.each do |element|
  y.yield element
end
```

The `y.yield` is not the keyword `yield`, but the invokation of the `#yield` method of `Enumerator::Yielder`, an object the enumerator uses internally to pass values through to the first block used in the enumerator chain. For a more detailed look at how enumerators work under the hood, read more about how [Ruby works hard so you can be lazy](http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy).

### A Cursor-y Example

Let's do one more iteration on our `paginated_get` refactoring. Up to this point, we've been using a "functional" approach; we've just been using a bunch of methods defined in the outermost lexical scope.

First, we'll extract a `Client` responsible for sending requests to the Trello API and parsing the responses as JSON.

```ruby
require "http"
require "addressable/uri"

class Client
  def initialize(opts = {})
    @app_key   = opts.fetch(:app_key, ENV.fetch("TRELLO_APP_KEY"))
    @app_token = opts.fetch(:app_token, ENV.fetch("TRELLO_APP_TOKEN"))
  end

  def get(path, params = {})
    HTTP.get(trello_url(path, params)).parse
  end

  private

  def trello_url(path, params = {})
    auth_params = { key: app_key, token: app_token }

    Addressable::URI.new({
      scheme: "https",
      host: "api.trello.com",
      path: File.join("1", path),
      query_values: auth_params.merge(params)
    })
  end
end
```

Next, we'll provide a class to represent the paginated collection of results to replace `paginated_get`.

The Twitter API provides a concept called [cursors](https://dev.twitter.com/overview/api/cursoring) to navigate through pages, a concept similar to "next" and "previous" links websites. Although Trello doesn't provide explicit cursors in their API, we can still wrap the paginated results in an enumerable class to get similar behavior.

```ruby
class Cursor
  def initialize(path, params = {})
    @path       = path
    @params     = params

    @collection = []
    @page       = params.fetch(:page, 1)
    @limit      = params.fetch(:limit, 50)
  end
end
```
The `Cursor` will be initialized with a path and params, like our `paginated_get`. We'll also maintain an internal `@collection` array to cache elements as they are returned from Trello.

```ruby
class Cursor
  private

  def client
    @client ||= Client.new
  end

  def fetch_next_page
    response              = client.get(@path, @params)
    @last_response_empty  = response.empty?
    @collection          += response
    @page                += 1
  end
end
```

We'll introduce a dependency on the `Client` to interface with Trello through the private `#client` method. We'll use our client to  `#fetch_next_page`, append the latest results to our cached `@collection` and increment the page number. Now for the key public method:

```ruby
class Cursor
  include Enumerable

  def each(start = 0)
    return to_enum(:each, start) unless block_given?

    Array(@collection[start..-1]).each do |element|
      yield(element)
    end

    unless last?
      start = [@collection.size, start].max

      fetch_next_page

      each(start, &Proc.new)
    end
  end
end
```

We've chosen to have our `Cursor` expose the Enumerable API by including the `Enumerable` module and implementing `#each`.

Credits

* [Document by Ayesha Rana](https://thenounproject.com/term/document/83985/)
* [Arrow by Arthur Shlain](https://thenounproject.com/term/arrow/138550/)
