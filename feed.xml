<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-03-01T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Thread Pool - A Ruby Antihero</title>
    <link rel="alternate" href="/blog/a-ruby-antihero-thread-pool.html"/>
    <id>/blog/a-ruby-antihero-thread-pool.html</id>
    <published>2016-03-01T19:00:00-05:00</published>
    <updated>2016-03-01T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Deadpool" src="/assets/images/blog/deadpool-b5499244.jpg"&gt;&lt;/p&gt;

&lt;p&gt;One of the fundamental concepts in key Ruby libraries that embrace
concurrency is the &lt;a href="https://en.wikipedia.org/wiki/Thread_pool"&gt;thread pool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find examples of thread pool implementations in gems like
&lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt;,
&lt;a href="https://github.com/ruby-concurrency/concurrent-ruby"&gt;concurrent-ruby&lt;/a&gt;,
&lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt;,
&lt;a href="https://github.com/bruceadams/pmap"&gt;pmap&lt;/a&gt;,
&lt;a href="https://github.com/grosser/parallel/blob/6ebee4ff5c0933da241a182e366eee9227b49764/lib/parallel.rb#L66"&gt;parallel&lt;/a&gt;,
and &lt;a href="https://github.com/meh/ruby-thread"&gt;ruby-thread&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A thread pool...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Deadpool" src="/assets/images/blog/deadpool-b5499244.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;One of the fundamental concepts in key Ruby libraries that embrace
concurrency is the &lt;a href="https://en.wikipedia.org/wiki/Thread_pool"&gt;thread pool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find examples of thread pool implementations in gems like
&lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt;,
&lt;a href="https://github.com/ruby-concurrency/concurrent-ruby"&gt;concurrent-ruby&lt;/a&gt;,
&lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt;,
&lt;a href="https://github.com/bruceadams/pmap"&gt;pmap&lt;/a&gt;,
&lt;a href="https://github.com/grosser/parallel/blob/6ebee4ff5c0933da241a182e366eee9227b49764/lib/parallel.rb#L66"&gt;parallel&lt;/a&gt;,
and &lt;a href="https://github.com/meh/ruby-thread"&gt;ruby-thread&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A thread pool is an abstraction for re-using a limited number of threads to
performing concurrent work.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Thread pool - no relation" src="/assets/images/blog/threadpool-428287d8.png" /&gt;&lt;/p&gt;

&lt;p&gt;General usage of a thread pool might look something like the following, where the &lt;code&gt;:size&lt;/code&gt;
represents the maximum number of threads open at any given time.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pool = ThreadPool.new(size: 5)

10_000.times do
  pool.schedule { do_work }
end

pool.shutdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The calculation would be performed 10,000 times across five separate threads.&lt;/p&gt;

&lt;p&gt;To get a better understanding of how thread pools work, let&amp;rsquo;s implement a thread
pool in test-driven fashion.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  The code samples in this post are run on &lt;code&gt;rubinius-3.14&lt;/code&gt; to take advantage of
  parallel processing.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Don&amp;rsquo;t be afraid&lt;/h3&gt;

&lt;p&gt;Before we dive in, let&amp;rsquo;s acknowledge that Rubyists, and most OO programmers in general,
are taught to fear multi-threaded concurrency.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;first rule&lt;/em&gt; of concurrency on the JRuby wiki, a Ruby implementation
designed to take advantage of native operating systems threads, is this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t do it, if you can avoid it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For the purpose of this post, I&amp;rsquo;m going to assume the author means &amp;ldquo;in
production&amp;rdquo;. In the safety of your development environment, playing with
concurrency in Ruby can be a tremendous learning opportunity.&lt;/p&gt;

&lt;h3&gt;A simple thread pool&lt;/h3&gt;

&lt;p&gt;So we&amp;rsquo;ll implement a simple thread pool guided by tests. Our thread pool will use the
interface we described earlier while limiting the number of threads
used to carry out a set of concurrent &amp;ldquo;jobs&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pool = ThreadPool.new(size: 5)

pool.schedule { do_work }

pool.shutdown
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Basic usage&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll start with a thread pool that doesn&amp;rsquo;t do any concurrent processing.
It will execute the block given to its &lt;code&gt;#schedule&lt;/code&gt; method
directly. Though we&amp;rsquo;ll add other tests later to exercise concurrency in the
implementation, this first test will assume the concurrency is already
implemented.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s our first test.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;
require &amp;#39;minitest/pride&amp;#39;
require_relative &amp;#39;./thread_pool&amp;#39;

class TestThreadPool &amp;lt; Minitest::Test
  def test_basic_usage
    pool_size = 5
    pool = ThreadPool.new(size: pool_size)

    mutex = Mutex.new

    iterations = pool_size * 3
    results = Array.new(iterations)

    iterations.times do |i|
      pool.schedule do
        mutex.synchronize do
          results[i] = i + 1
        end
      end
    end
    pool.shutdown

    assert_equal((1.upto(pool_size * 3)).to_a, results)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break it down. To test the basic usage of a thread pool scheduler, we&amp;rsquo;ll pass in an array and
augment it with in the scheduled blocks. Because &lt;a href="http://www.jstorimer.com/pages/ruby-core-classes-arent-thread-safe"&gt;&lt;code&gt;Array&lt;/code&gt; is not thread safe&lt;/a&gt;, we need to use a &lt;code&gt;Mutex&lt;/code&gt; object to lock the pooled threads while adding items to the array. The key snippet is here:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pool.schedule do
  mutex.synchronize do
    results[i] = i + 1
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The test asserts that the results match &lt;code&gt;1.upto(15)&lt;/code&gt; as an array.&lt;/p&gt;

&lt;p&gt;To make the tests pass:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ThreadPool
  def initialize(size:)
  end

  def schedule(*args, &amp;amp;block)
    block.call(args)
  end

  def shutdown
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve just stubbed out the &lt;code&gt;#initialize&lt;/code&gt; and &lt;code&gt;#shutdown&lt;/code&gt; methods since
additional behavior isn&amp;rsquo;t needed to get the tests to pass.&lt;/p&gt;

&lt;p&gt;You can see the source for &lt;a href="https://github.com/rossta/loves-enumerable/commit/fcd81ec86ae3525d8f0a3acf914507e2962fb962"&gt;this changeset on Github&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Saving time&lt;/h3&gt;

&lt;p&gt;Our next test will demonstrate that we&amp;rsquo;re actually taking advantage of concurrency by
(crudely) measuring the time taken to process multiple jobs.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a small test helper method to measure the number of
seconds elapsed during execution:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def time_taken
  now = Time.now.to_f
  yield
  Time.now.to_f - now
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our test will schedule 5 jobs that will each sleep for 1 second.
If the jobs executed serially, the total execution time would be at least 5
seconds. Running in parallel on Rubinius, we&amp;rsquo;d expect threaded-execution of 5 jobs
across 5 threads to take less time.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def test_time_taken
  pool_size = 5
  pool = ThreadPool.new(size: pool_size)
  elapsed = time_taken do
    pool_size.times do
      pool.schedule { sleep 1 }
    end
    pool.shutdown
  end
  assert_operator 4.5, :&amp;gt;, elapsed,
    &amp;#39;Elapsed time was too long: %.1f seconds&amp;#39; % elapsed
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test fails with our first pass-through implementation of &lt;code&gt;ThreadPool&lt;/code&gt;. We
can make this test pass by wrapping each scheduled job in its own thread.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ThreadPool
  def initialize(size:)
    @pool = []
  end

  def schedule(*args, &amp;amp;block)
    @pool &amp;lt;&amp;lt; Thread.new { block.call(args) }
  end

  def shutdown
    @pool.map(&amp;amp;:join)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We push each of these threads onto an array, &lt;code&gt;@pool&lt;/code&gt;, which we can use to join
the threads during the &lt;code&gt;#shutdown&lt;/code&gt; method. The tests pass again.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/loves-enumerable/commit/1d1cbc808a536a449b8f6dab5b9d4e0cb037f99c"&gt;Source for this changeset&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Adding Pooling&lt;/h3&gt;

&lt;p&gt;While we&amp;rsquo;ve achieved concurrency, you may notice there&amp;rsquo;s (at least) one problem.&lt;/p&gt;

&lt;p&gt;Our current implementation will naively create a new thread for each scheduled
job. This may not be an issue for small, trivial use cases, but it can be easily
abused. Thread creation does not come for free; every OS has its limit.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll prove it with our next test in which we&amp;rsquo;ll schedule a large number of
jobs.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def test_pool_size_limit
  pool_size = 5
  pool = ThreadPool.new(size: pool_size)
  mutex = Mutex.new
  threads = Set.new

  100_000.times do
    pool.schedule do
      mutex.synchronize do
        threads &amp;lt;&amp;lt; Thread.current
      end
    end
  end
  pool.shutdown

  assert_equal(pool_size, threads.size)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running these tests on my mid-2014 MacBook Pro, I hit the resource limit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TestThreadPool#test_pool_size_limit:
ThreadError: can&amp;#39;t create Thread: Resource temporarily unavailable
    /Users/ross/dev/rossta/enumerable/examples/thread_pool/thread_pool_test.rb:53:in `initialize&amp;#39;
    /Users/ross/dev/rossta/enumerable/examples/thread_pool/thread_pool_test.rb:53:in `new&amp;#39;
    /Users/ross/dev/rossta/enumerable/examples/thread_pool/thread_pool_test.rb:53:in `block in test_pool_size_limit&amp;#39;
    /Users/ross/dev/rossta/enumerable/examples/thread_pool/thread_pool_test.rb:52:in `times&amp;#39;
    /Users/ross/dev/rossta/enumerable/examples/thread_pool/thread_pool_test.rb:52:in `test_pool_size_limit&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is now the whole point of our &lt;code&gt;ThreadPool&lt;/code&gt;, to limit the number of threads
in use. To implement this behavior, instead of executing the scheduled job in a
new thread, we&amp;rsquo;ll add them to a &lt;code&gt;Queue&lt;/code&gt;. We&amp;rsquo;ll separately create a
limited number of threads whose responsibility will be to pop new &amp;ldquo;jobs&amp;rdquo; off the
queue and execute them when available.&lt;/p&gt;

&lt;p&gt;The beauty of &lt;code&gt;Queue&lt;/code&gt; is that it is thread-safe; multiple threads in the thread pool an access this resource without corrupting its contents.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the revised implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ThreadPool
  def initialize(size:)
    @size = size
    @jobs = Queue.new
    @pool = Array.new(size) do
      Thread.new do
        catch(:exit) do
          loop do
            job, args = @jobs.pop
            job.call(*args)
          end
        end
      end
    end
  end

  def schedule(*args, &amp;amp;block)
    @jobs &amp;lt;&amp;lt; [block, args]
  end

  def shutdown
    @size.times do
      schedule { throw :exit }
    end

    @pool.map(&amp;amp;:join)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start with the &lt;code&gt;#schedule&lt;/code&gt; method. Where before we immediately creating a
new thread to call the block, we instead push the block and arguments onto the
new &lt;code&gt;@jobs&lt;/code&gt; queue instance variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def schedule(*args, &amp;amp;block)
  @jobs &amp;lt;&amp;lt; [block, args]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This instance variable is setup in the &lt;code&gt;#initialize&lt;/code&gt; method where we also
eagerly create the maximum number of threads that will become our worker &lt;code&gt;@pool&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def initialize(size:)
  @size = size
  @jobs = Queue.new
  @pool = Array.new(size) do
    Thread.new do
      catch(:exit) do
        loop do
          job, args = @jobs.pop
          job.call(*args)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each thread runs an infinite loop that repeatedly pops jobs of the queue with
&lt;code&gt;@jobs.pop&lt;/code&gt;. The &lt;code&gt;Queue#pop&lt;/code&gt; method here is blocking so the thread will happily
wait for new jobs to be scheduled at this point.&lt;/p&gt;

&lt;p&gt;Notice also to &lt;code&gt;catch(:exit) do&lt;/code&gt; block. We break out of the thread loops by
pushing &lt;code&gt;throw :exit&lt;/code&gt; on to the job queue, once for each thread in the
&lt;code&gt;#shutdown&lt;/code&gt; method. This means that jobs currently executing when the shutdown
method is called will be able to complete before the threads can be joined.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def shutdown
  @size.times do
    schedule { throw :exit }
  end

  @pool.map(&amp;amp;:join)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a simple abstraction for handing concurrent work across a limited
number of threads. For more on this implementation, check out the original author&amp;rsquo;s &lt;a href="http://www.burgestrand.se/articles/quick-and-simple-ruby-thread-pool.html"&gt;blog post on
the subject&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/loves-enumerable/commit/eabf97e2e5b856eb2c12e68e36233940aec02030"&gt;Source for this changeset&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;In the Wild&lt;/h3&gt;

&lt;p&gt;Of course, if you&amp;rsquo;re planning on using a thread pool in production code, you&amp;rsquo;ll
may be better off leveraging the hard work of others. Our implementation omits
some key considerations, like providing reflection, handing timeouts, dealing with
exceptions, and better thread safety. Let&amp;rsquo;s look at some alternatives in the
community.&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/meh/ruby-thread"&gt;ruby-thread&lt;/a&gt; project provides a few extensions to the standard library &lt;code&gt;Thread&lt;/code&gt; class, including &lt;code&gt;Thread::Pool&lt;/code&gt;. Usage of &lt;code&gt;Thread::Pool&lt;/code&gt; is very similar to what we came up with on the surface.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;thread/pool&amp;#39;

pool = Thread.pool(4)

10.times {
  pool.process {
    sleep 2

    puts &amp;#39;lol&amp;#39;
  }
}

pool.shutdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation goes farther to ensure standard locking functions to work
properly across multiple Ruby implementations. Among other things, it has
support for handling timeouts, methods for introspecting pool objects, like
&lt;code&gt;#running?&lt;/code&gt; and &lt;code&gt;#terminated?&lt;/code&gt;, and optimizations for dealing with unused
threads. On reading the source, my impression is the implementation was heavily inspired by &lt;a href="https://github.com/puma/puma/blob/32b1fb3742e5918e0e79ee705b48c912a1f0742d/lib/puma/thread_pool.rb"&gt;Puma::ThreadPool&lt;/a&gt;, a class used internally by the puma web server. You be the judge.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/celluloid/celluloid"&gt;Celluloid&lt;/a&gt;, the most famous
collection of concurrency abstractions, provides a thread pool class,
most commonly accessed via a class method provided by the
&lt;code&gt;Celluloid&lt;/code&gt; mixin.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class MyWorker
  include Celluloid

  def add_one(number)
    # roflscale computation goes here
    number + 1
  end
end

MyWorker.pool

pool.future(:add_one, 5).value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new hotness for working with concurrency is the toolkit provided by &lt;a href="https://github.com/ruby-concurrency/concurrent-ruby"&gt;concurrent-ruby&lt;/a&gt;. While &lt;code&gt;Celluloid&lt;/code&gt; is easy to get started with, &lt;code&gt;Concurrent&lt;/code&gt; is the &amp;ldquo;Swiss Army Knife&amp;rdquo;, providing a large array of abstractions and classes, including futures, promises, thread-safe collections, maybes, and so on. &lt;code&gt;Concurrent&lt;/code&gt; provides several different thread pool implementations for different purposes, each supporting a number of configurations, including min and max pool sizes, advanced shutdown behaviors, max queue size (along with a fallback policy when the job queue size is exceeded) to name a few.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pool = Concurrent::FixedThreadPool.new(5) # 5 threads
pool.post do
  # some parallel work
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consider the &lt;a href="http://ruby-concurrency.github.io/concurrent-ruby/file.thread_pools.html"&gt;Thread Pool&lt;/a&gt; overview provided in the &lt;code&gt;Concurrent&lt;/code&gt; docs required reading.&lt;/p&gt;

&lt;p&gt;And, of course, the ultimate thread pool for Rails developers is &lt;a href="https://github.com/mperham/sidekiq"&gt;Sidekiq&lt;/a&gt;. Unlike the examples we&amp;rsquo;ve discussed so far, the components of the Sidekiq thread pool model are distributed: the caller, the job queue, and the threaded workers all running in separate processes, often on separate machines in a production environment.&lt;/p&gt;

&lt;h3&gt;Credits&lt;/h3&gt;

&lt;p&gt;In preparing for this post, I read through the source of several thread pool
implementations from various sources, ranging from simple examples, to internal
interfaces, to public-facing libraries.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.burgestrand.se/code/ruby-thread-pool/"&gt;A simple, annotated thread pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/meh/ruby-thread/blob/f25dd1184f4f4bee7cde0d54ad5ce5e32dc15279/lib/thread/pool.rb"&gt;Thread::Pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/celluloid/celluloid/blob/c54bbde76e6a71b44c3ca6d1abf71197c64d7614/lib/celluloid/group/pool.rb"&gt;Celluloid::Group::Pool&lt;/a&gt; implementation.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ruby-concurrency/concurrent-ruby/blob/536478817a3d0440f00ac09098f3ba71f0d8ce7c/lib/concurrent/executor/ruby_thread_pool_executor.rb"&gt;Concurrent::RubyThreadPoolExecutor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/puma/puma/blob/32b1fb3742e5918e0e79ee705b48c912a1f0742d/lib/puma/thread_pool.rb"&gt;Puma::ThreadPool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Though it&amp;rsquo;s well documented how much &lt;a href="http://adam.herokuapp.com/past/2009/8/13/threads_suck/"&gt;threads suck&lt;/a&gt;, that shouldn&amp;rsquo;t discourage Rubyists from trying to get some first-hand experience with working with threads, supporting classes from the standard library like &lt;code&gt;Queue&lt;/code&gt;, &lt;code&gt;Mutex&lt;/code&gt;, and &lt;code&gt;ConditionVariable&lt;/code&gt; and generic abstractions like &lt;code&gt;ThreadPool&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Connection Pool, the Sequel&lt;/h3&gt;

&lt;p&gt;Related, though not necessarily thread-based, is the concept of a connection
pool, which limits the number of network connections to a particular service.
You&amp;rsquo;ll find connection pools in &lt;a href="https://github.com/rails/rails/blob/107f4282bbfabc011d5ad3bcf3fb3c6fb812ad30/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb"&gt;activerecord&lt;/a&gt;, &lt;a href="https://github.com/mongodb/mongo-ruby-driver/blob/eece2a769bbf1a302b2f70b23dc6a43490392979/lib/mongo/server/connection_pool.rb"&gt;mongodb&lt;/a&gt;, and, as a standalone
abstraction in the approrpriately-named,
&lt;a href="https://github.com/mperham/connection_pool"&gt;connection_pool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s good to know
about connection pools for setting a connection to Redis from your Ruby
applications with the &lt;a href="https://github.com/redis/redis-rb"&gt;redis-rb&lt;/a&gt; gem. As of this writing, this client does not manage a connection pool for you, so &lt;a href="http://www.blrice.net/blog/2015/04/24/take-a-swim-in-the-connection-pool/"&gt;the common gotcha&lt;/a&gt; is a memory-leak that originates from creating a lot of open connections to the Redis server. You can avoid this with &lt;code&gt;ConnectionPool&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;redis = ConnectionPool.new { Redis.new }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much like &lt;code&gt;ThreadPool&lt;/code&gt;, having at least a cursory understanding of what&amp;rsquo;s happening
underneath can help you avoid issues with managing resources like network
connections.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What I learned building an app in Hanami</title>
    <link rel="alternate" href="/blog/what-i-learned-about-hanami.html"/>
    <id>/blog/what-i-learned-about-hanami.html</id>
    <published>2016-02-21T19:00:00-05:00</published>
    <updated>2016-02-21T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;For the past year, I’ve been loosely following the progress on &lt;a href="http://hanamirb.org"&gt;Hanami&lt;/a&gt; (formerly Lotus), a new web framework
for Ruby created by &lt;a href="https://github.com/jodosha"&gt;Luca Guidi (@jodosha)&lt;/a&gt;. I recently decided to build a small app in Hanami to get a feel for its design and to understand...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;For the past year, I&amp;rsquo;ve been loosely following the progress on &lt;a href="http://hanamirb.org"&gt;Hanami&lt;/a&gt; (formerly Lotus), a new web framework
for Ruby created by &lt;a href="https://github.com/jodosha"&gt;Luca Guidi (@jodosha)&lt;/a&gt;. I recently decided to build a small app in Hanami to get a feel for its design and to understand better its fresh perspective on web development in Ruby. In other words, to answer for myself, &amp;ldquo;Is Hanami better than Rails?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/github_groove"&gt;The app&lt;/a&gt; is a simple integration between GitHub issues and the helpdesk platform, &lt;a href="https://www.groovehq.com"&gt;Groove&lt;/a&gt;.
Visitors can login via OAuth through their GitHub accounts, connect to a Groove
account with an API key, import their Groove tickets, and create GitHub issues
from these tickets through the app. You can see the &lt;a href="https://github.com/rossta/github_groove"&gt;source on Github&lt;/a&gt; and play with the &lt;a href="https://github-groove.herokuapp.com/"&gt;app hosted on Heroku&lt;/a&gt;, where it would help to have accounts on both GitHub and Groove to see how it works.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve made note of what I learned and some of the challenges I faced while going beyond the &lt;a href="http://hanamirb.org/guides/"&gt;getting
started guides&lt;/a&gt; to build and deploy the app. This post is not an introduction
to Hanami - the &lt;a href="http://hanamirb.org/guides/"&gt;guides&lt;/a&gt; serve as an excellent overview.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
  &lt;p&gt;The Github-Groove app is built on &lt;code&gt;hanami-0.7.0&lt;/code&gt;. As the framework is under
heavy development (as of this writing the latest version is
&lt;code&gt;v0.7.2&lt;/code&gt;), your experience getting started with Hanami may differ.
  &lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Hanami opinions are not Rails opinions&lt;/h3&gt;

&lt;p&gt;Hanami has a lot in common with Rails. Both are web frameworks built on Ruby
that employ some version of the Model-View-Controller pattern and, among other
things, value &lt;a href="http://rubyonrails.org/doctrine/#convention-over-configuration"&gt;convention over configuration&lt;/a&gt;.
Both frameworks are &lt;em&gt;opinionated&lt;/em&gt; about how web apps should be built. In a
nutshell, Hanami takes what it likes from Rails and draws the line on certain
principles including avoidance of monkey-patching, enforcing modularity, and encouraging
the use of &amp;ldquo;plain old Ruby objects&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re coming from Rails, you can expect to learn some new conventions in Hanami.
&lt;a href="http://hanamirb.org/guides/getting-started/"&gt;As the guides warn&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;learning these conventions may be hard: without change, there is no challenge&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The framework pushes you toward &amp;ldquo;monolith first&amp;rdquo; while emphasizing &amp;ldquo;separation of concerns&amp;rdquo;. There are suggestions in the generated directory structure like how the &lt;code&gt;app/&lt;/code&gt; folder is named &lt;code&gt;apps/&lt;/code&gt; in Hanami encouraging you from the start to define sub-applications boundaries under one umbrella, or &amp;ldquo;container&amp;rdquo; in Hanami parlance. So while in Rails has engines as an opt-in feature, you build everything as an engine in Hanami. Each &amp;ldquo;app&amp;rdquo; gets its own set of views, controllers, assets, configuration, etc. Shared resources, like models, tend to go in &lt;code&gt;lib/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You also get useful development tools like generators, migrations, and asset
pipelines in Hanami, but expect less ceremony here. Migrations handed off to the
venerable &lt;a href="http://sequel.jeremyevans.net/rdoc/files/doc/schema_modification_rdoc.html"&gt;Sequel&lt;/a&gt; project and the asset story is still young but passable; you won&amp;rsquo;t be able to take advantage of the multitude of Rails-asset gems.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d be interested to see Hanami go in a different direction here, like taking advantage of the &amp;ldquo;frontend explosion&amp;rdquo; by providing integration with external pipelines as the static-site generator &lt;a href="https://middlemanapp.com/advanced/external-pipeline/"&gt;middleman has done&lt;/a&gt; or what &lt;a href="http://www.shakacode.com/"&gt;Shakacode&lt;/a&gt; is trying with &lt;a href="https://webpack.github.io/"&gt;webpack&lt;/a&gt; in &lt;a href="https://github.com/shakacode/react_on_rails"&gt;&lt;code&gt;react_on_rails&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that Hanami comes with security features baked in for as one would expect, including &lt;a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)"&gt;CSRF protection&lt;/a&gt; and app-level secure-by-default options for items like &lt;a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP"&gt;Content Security Policy&lt;/a&gt; and &lt;code&gt;X-Frame-Options&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One gotcha is that Hanami &lt;a href="https://github.com/hanami/hanami/issues/249"&gt;does not itself provide any mechanism for code
reloading&lt;/a&gt; (at the moment). This
was not obvious to me starting off since the development server does &amp;ldquo;appear&amp;rdquo; to reload code. It turns out that the dev server launches with &lt;a href="https://github.com/rtomayko/shotgun"&gt;Shotgun&lt;/a&gt; (commonly used in Sinatra projects), to serve each development request in a new process with &lt;code&gt;fork(2)&lt;/code&gt;. I didn&amp;rsquo;t pick up on this until several iterations in when I added the &lt;a href="https://github.com/brandonhilkert/sucker_punch"&gt;SuckerPunch gem&lt;/a&gt; and couldn&amp;rsquo;t figure out why my background jobs wouldn&amp;rsquo;t run in development. I added a &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/apps/web/controllers/tickets/sync.rb#L11"&gt;sync action&lt;/a&gt; that allows users to trigger a &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/lib/github_groove/jobs/sync_tickets_job.rb"&gt;background job to import ticket data&lt;/a&gt; from Groove into the application. Long story short, kicking off background jobs in threads in the request process, as is possible with SuckerPunch, won&amp;rsquo;t work without disabling Shotgun.&lt;/p&gt;

&lt;h3&gt;Hanami MVC is not Rails MVC&lt;/h3&gt;

&lt;p&gt;With the Model-View-Controller paradigm, you&amp;rsquo;ll see some big departures from
Rails. First, controllers are not classes with &amp;ldquo;RESTful&amp;rdquo; methods, but
&lt;em&gt;directories&lt;/em&gt; of related action classes. In other words, instead of defining
&lt;code&gt;#index&lt;/code&gt;, &lt;code&gt;#show&lt;/code&gt;, &lt;code&gt;#create&lt;/code&gt;, etc. in a &lt;code&gt;PostsController&lt;/code&gt;, you create a separate
class for each action using a mixin that live in a directory that would
represent a single controller in Rails.&lt;/p&gt;

&lt;p&gt;In my Github-Groove app, here&amp;rsquo;s how I organize the tickets controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;app/
  web/
    assets/
    config/
    controllers/
      tickets/
        index.rb
        show.rb
        sync.rb
    templates/
    views/
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each &amp;ldquo;action&amp;rdquo; is a Rack-inspired class whose contract is only that it responds to &lt;code&gt;#call&lt;/code&gt;. You still get
familiar macros like &lt;code&gt;before&lt;/code&gt; filters, but there are new ideas too, like declaring what instance variables are available to the view with &lt;code&gt;expose&lt;/code&gt;, inserting action-specific middleware, and whitelisting &lt;code&gt;params&lt;/code&gt; at the class level, all of which I find to be huge improvements over the Rails controller design.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Web::Controllers::Project
  class Create
    include Web::Action

    expose :project
    before :authenticate!

    params do
      param :project do
        param :groove_access_token, presence: true
        param :github_repository, presence: true
      end
    end

    def call(params)
      if params.valid?
        @project = ProjectRepository.find_or_create_by_params(params[:project])
        UserRepository.update_user_project(current_user, @project)

        flash[:notice] = &amp;quot;Your project has been saved!&amp;quot;

        redirect_to &amp;quot;/project&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguably, the biggest efforts in Hanami appear to be at this action layer and it
shows in the &lt;a href="http://hanamirb.org/guides/actions/overview/"&gt;guides&lt;/a&gt; and the
&lt;a href="https://github.com/hanami/controller/blob/master/README.md"&gt;README&lt;/a&gt; where you
can find a ton of great information for customizing these classes.&lt;/p&gt;

&lt;p&gt;Another big benefit in the controller design, and for most of the Hanami
framework, is that unit-testing has a much lower barrier to entry. To get
controller tests to work in Rails requires a ton of setup behind the scenes to
the point where you essentially have integration tests. Controllers tests in
Hanami are much simpler by the simple fact that getting a testable object is as
easy as &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/spec/web/controllers/project/create_spec.rb#L5"&gt;instantiating a Hanami action&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Hanami, &amp;ldquo;views&amp;rdquo; are classes that act more like presenter to represent a model
or collection of models for the &amp;ldquo;templates&amp;rdquo;, which the place of the
&lt;code&gt;views/&lt;/code&gt; folder in Rails. Like Rails, file-naming conventions link an action,
view, and template. The helper method story is still developing, but you can
expect to find some surprises in the docs, like the criticism of Rails
monkey-patching of ERB to achieve block-style helpers for things like forms.
Expect to get tripped up by these differences in helper syntax which ironically are
valid ERB. Hanami does support all the other popular templating engines through
&lt;a href="https://github.com/rtomayko/tilt"&gt;Tilt&lt;/a&gt; for your preference.&lt;/p&gt;

&lt;p&gt;Hanami also provides &lt;code&gt;hanami-model&lt;/code&gt; for the model layer as a soft-dependency so
you can bring your own ORM if desired. If you choose to use &lt;code&gt;hanami-model&lt;/code&gt; as I
did, you can expect to leave your ActiveRecord convenience (and baggage) behind.
Hanami&amp;rsquo;s model layer emulates the &lt;a href="http://martinfowler.com/eaaCatalog/repository.html"&gt;repository pattern&lt;/a&gt; where database queries, table mapping, and entities are all separate concerns.&lt;/p&gt;

&lt;p&gt;Repositories become a collection of query methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProjectRepository
  include Hanami::Repository

  def self.find_or_create_by_params(params)
    found = find_by_groove_access_token(params[:groove_access_token])

    if found
      found.update(params)
      update found
    else
      create(Project.new(params))
    end
  end

  def self.find_by_groove_access_token(groove_access_token)
    query do
      where(groove_access_token: groove_access_token)
    end.first
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entities feel basically like POROS that provide a thin layer over attributes.
Don&amp;rsquo;t expect to find any database access, validations (by default anyhow), or callbacks here.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Project
  include Hanami::Entity

  attributes :groove_access_token, :github_repository, :syncing

  def ready?
    groove_access_token.present? &amp;amp;&amp;amp; github_repository.present?
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validations do exist in Hanami &lt;a href="https://github.com/hanami/validations"&gt;as a separate mixin&lt;/a&gt; but these are more typically done in the params macro at the action-layer.&lt;/p&gt;

&lt;h2&gt;Expect to write code&lt;/h2&gt;

&lt;p&gt;While Hanami has its own variety of &amp;ldquo;magic&amp;rdquo; of the kind that developers have come to
either love or hate in Rails, you can expect to write code you might not
otherwise have to in Rails. The framework is still young, so there are missing
features. What&amp;rsquo;s not always clear is whether these features have been left out
by priority or choice. To figure that out takes some digging on GitHub issues, the Hanami &lt;a href="https://gitter.im/hanami/chat"&gt;chat&lt;/a&gt; and &lt;a href="https://discuss.hanamirb.org/"&gt;Discourse forum&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Though its database layer has the &lt;a href="https://github.com/jeremyevans/sequel"&gt;Sequel&lt;/a&gt; library as a foundation, I didn&amp;rsquo;t find the repository and entity functionality as fully-developed. I found myself writing a lot of boilerplate code in the entities and repositories with a lot of co-dependence between the classes. With some more thoughtful design and refactoring, I could probably address this issue, but at this stage, the separation of concerns is less apparent: entities and repositories appear to be tightly bound. &lt;a href="https://github.com/hanami/model/issues/291"&gt;Convenience methods&lt;/a&gt; are still in the works.&lt;/p&gt;

&lt;p&gt;For one, &lt;a href="https://github.com/hanami/model/pull/244"&gt;associations&lt;/a&gt; are still in development at the time of this writing (see open issue &lt;a href="https://github.com/hanami/model/issues/35"&gt;here&lt;/a&gt;). Much of my entity code was to fill this gap - to load objects linked by foreign keys via repositories like below.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Project
  include Hanami::Entity

  def tickets(params = {})
    TicketRepository.all_by_project(self, params)
  end
end

class TicketRepository
  include Hanami::Repository

  def self.all_by_project(project, _params = {})
    query do
      where(project_id: project.id).desc(:number)
    end.all
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m not sure if this is the &amp;ldquo;Hanami-way&amp;rdquo;, but I found myself doing this kind of
thing a lot.&lt;/p&gt;

&lt;p&gt;I also ran into some unexpected issues while deploying the application to Heroku
where its &lt;code&gt;HANAMI_ENV&lt;/code&gt; is set to &lt;code&gt;&amp;#39;production&amp;#39;&lt;/code&gt;. In many cases, custom classes I
extracted, like one for sharing &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/lib/github_groove/repositories/pagination.rb"&gt;a pagination query&lt;/a&gt; and another for &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/lib/github_groove/vendor/groove.rb"&gt;wrapping the &lt;code&gt;Groove API Ruby Client&lt;/code&gt;&lt;/a&gt; (my &lt;a href="https://github.com/Fodoj/groovehq/pull/16"&gt;fork with paginated enumeration&lt;/a&gt;) weren&amp;rsquo;t &amp;ldquo;autoloaded&amp;rdquo; when booting the Hanami application. To resolve this, I added explicit requires like &lt;code&gt;require_relative &amp;#39;./pagination&amp;#39;&lt;/code&gt;. Again, I didn&amp;rsquo;t have time to dig into whether this issue would be expected or not; I could have been missing something important here.&lt;/p&gt;

&lt;h3&gt;The Community is still young&lt;/h3&gt;

&lt;p&gt;That brings me to the community - it&amp;rsquo;s extremely supportive, but still very
small. I encountered a lot of helpful folks on
&lt;a href="https://gitter.im/hanami/chat"&gt;chat&lt;/a&gt; including &lt;code&gt;@jodosha&lt;/code&gt; himself, but there
simply hasn&amp;rsquo;t been enough traction to reach &lt;a href="https://stackoverflow.com/questions/tagged/hanami"&gt;StackOverflow&lt;/a&gt; critical mass where just about any question you can think of in Rails already has an answer.&lt;/p&gt;

&lt;p&gt;This means a lot more code-spelunking in the &lt;a href="https://github.com/hanami"&gt;hanami&lt;/a&gt; repositories. To that end, I found the code extremely clean, well-documented, and approachable whereas, even today, I need to brace myself before diving into Rails source.&lt;/p&gt;

&lt;p&gt;That said, you can expect to run into edge cases and bugs occasionally that may
not yet have a solution, including this &lt;a href="https://github.com/pry/pry/issues/1471#issuecomment-187420164"&gt;incredibly irksome&lt;/a&gt; issue that prevents you from accessing the pry console when using &lt;code&gt;binding.pry&lt;/code&gt; in Hanami controllers and the problem I mentioned earlier that prevents you from using SuckerPunch in development with Shotgun enabled.&lt;/p&gt;

&lt;p&gt;Another challenge is that all those Rails-specific plugins and engines
you&amp;rsquo;ve come to rely on won&amp;rsquo;t work in Hanami: Yikes, you have build authentication without Devise!
Using &lt;a href="https://github.com/hassox/warden"&gt;&lt;code&gt;Warden&lt;/code&gt;&lt;/a&gt;, the general Rack-based
authentication middleware on which Devise is based, is very feasible and you can always
rely on &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/apps/web/application.rb#L86"&gt;OmniAuth like I did&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The lesson here is that with Hanami, you&amp;rsquo;re much more likely to have to &amp;ldquo;roll up
your sleeves&amp;rdquo; to get to the bottom of issues, figure how to do things that
aren&amp;rsquo;t covered by the guides, or otherwise, get from a Rails-specific gem.&lt;/p&gt;

&lt;h3&gt;Hanami is and is not Rails&lt;/h3&gt;

&lt;p&gt;So should you build your next app in Hanami? Only you can answer that of course.
The lightweight approach in Hanami means there is less to wrap your head around
if you&amp;rsquo;re coming from Rails, but there is still a learning curve nonetheless. I&amp;rsquo;d say it&amp;rsquo;s a worthwhile endeavor to build something small like I did at first to push the boundaries and answer the questions you have about Hanami for yourself.&lt;/p&gt;

&lt;p&gt;Hanami treads the same ground as Rails and aims to do a lot of the low level
work for you so can focus on what&amp;rsquo;s important - your business logic. Personally, I found a lot of advantages in the &amp;ldquo;Hanami way&amp;rdquo; and enjoyed the experience of the new paradigm. My &amp;ldquo;Rails muscle memory&amp;rdquo; tripped me up on occasion and left me pining for features that don&amp;rsquo;t exist or are not as well-developed in Hanami yet. I see a lot of potential in the Hanami framework and see it growing into a viable alternative to Rails in the near future.&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href="https://github.com/rossta/github_groove"&gt;GitHub-Groove source&lt;/a&gt; and &lt;a href="https://github-groove.herokuapp.com/"&gt;demo app&lt;/a&gt; and let me know what I could have done differently.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Clojure's iterate in Ruby</title>
    <link rel="alternate" href="/blog/clojure-iterate-in-ruby.html"/>
    <id>/blog/clojure-iterate-in-ruby.html</id>
    <published>2016-02-16T19:00:00-05:00</published>
    <updated>2016-02-16T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the result of an algorithm. Previously, I described how to generate Clojure-like &lt;a href="https://rossta.net/blog/pascals-triangle-with-rubys-enumerator.html"&gt;sequences in Ruby&lt;/a&gt; (without the immutability anyways), including &lt;a href="https://rossta.net/blog/infinite-sequences-in-ruby.html"&gt;Pascal&amp;rsquo;s Triangle&lt;/a&gt; using &lt;code&gt;Enumerator&lt;/code&gt;, which allows us to package up an algorithm as an object that can emit values as any &amp;ldquo;eager&amp;rdquo; collection can, like &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Clojure provides a few functions that can be used to generate sequences,
including &lt;code&gt;iterate&lt;/code&gt;. According to the &lt;a href="https://clojuredocs.org/clojure.core/iterate"&gt;docs&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, &lt;code&gt;iterate&lt;/code&gt; will emit values starting with the first and repeatedly call the given function with the return value of the previous call.&lt;/p&gt;

&lt;p&gt;The signature in Clojure looks this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;(iterate f x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can generate a simple sequence of numbers using the &lt;code&gt;inc&lt;/code&gt; function and some start value:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate inc 1)
(1 2 3 4 5 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we have a terse was of generating a sequence like this in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb(main)&amp;gt; (1..5).to_a
=&amp;gt; [1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this solution doesn&amp;rsquo;t generalize to other types of sequences like, for instance,
generating a sequence of the powers of 2. In the example below, &lt;code&gt;(partial * 2)&lt;/code&gt;
returns a function that multiplies a single argument by 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate (partial * 2) 1)
(1 2 4 8 16 32 64 128 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get this result in Ruby, we might try something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; (1..7).each_with_object([]) { |n, seq| seq &amp;lt;&amp;lt; (seq.last.nil? ? n : seq.last * 2) }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not very pretty (ok, I admit that&amp;rsquo;s a strawman). But this also is an &amp;ldquo;eagerly&amp;rdquo;
generated collection whereas we want something that can be lazily generated to
get closer to Clojure.&lt;/p&gt;

&lt;p&gt;While there may be a number of ways to generate these sequences in Ruby, for this
exercise, we also want something that has a similar signature to Clojure&amp;rsquo;s &lt;code&gt;iterate&lt;/code&gt;,
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(x, &amp;amp;block)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll leverage Ruby&amp;rsquo;s method block convention in place of the function, &lt;code&gt;f&lt;/code&gt;.
Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; iterate(1) { |n| n + 1 }
=&amp;gt; [1, 2, 3, 4, 5, ...]
irb&amp;gt; iterate(1) { |n| n * 2 }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two examples now have the same &amp;ldquo;surface area&amp;rdquo; and have a lot in common with the Clojure
companions. So how would we implement this?&lt;/p&gt;

&lt;p&gt;First a test. By the way, all the code found in the following examples is &lt;a href="https://github.com/rossta/loves-enumerable/tree/master/examples/sequence"&gt;on Github&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;
require_relative &amp;#39;./sequence&amp;#39;

class TestSequence &amp;lt; Minitest::Test
  include Sequence

  def test_iterate_increment
    sequence = iterate(1) { |x| x + 1 }

    assert_equal sequence.first(5), [1, 2, 3, 4, 5]
  end

  def test_iterate_power_of_2
    sequence = iterate(1) { |x| x * 2 }

    assert_equal sequence.first(5), [1, 2, 4, 8, 16]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re going to implement &lt;code&gt;iterate&lt;/code&gt; in a Ruby module called &lt;code&gt;Sequence&lt;/code&gt;. Our test
for &lt;code&gt;iterate&lt;/code&gt; will return an instance of &lt;code&gt;Enumerator&lt;/code&gt; (the &lt;code&gt;sequence&lt;/code&gt; variable).
The enumerator allows use to generate the sequence on demand with the call to
&lt;code&gt;#first&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg)
    Enumerator.new do |yielder|
      current = arg
      loop do
        yielder &amp;lt;&amp;lt; current
        current = yield(current)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our implementation of &lt;code&gt;iterate&lt;/code&gt; returns an &lt;code&gt;Enumerator&lt;/code&gt; that will first yield
the given &lt;code&gt;arg&lt;/code&gt; and repeatedly call the given block with the result of the
previous call. The &lt;code&gt;loop&lt;/code&gt; construct means this enumeration can potentially
continue forever - capturing the spirit of a Clojure sequence. That means
we need to use a terminating functions like &lt;code&gt;#first&lt;/code&gt; or &lt;code&gt;#take&lt;/code&gt; to limit the
results, just like we would in Clojure:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (take 5 (iterate (partial * 2) 1))
(1 2 4 8 16)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Ruby equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(1) { |n| n * 2 }.take(5)
=&amp;gt; [1, 2, 4, 8, 16]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could go one step further an make this method work as a mixin. Below is a
test for using &lt;code&gt;iterate&lt;/code&gt; as an instance method of a class using in our tests
that will simply delegate missing methods to the object passed in on
instantiation.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class TestSequence &amp;lt; Minitest::Test
  include Sequence

  class Sequenced &amp;lt; SimpleDelegator
    include Sequence
  end

  def test_iterate_include
    num = Sequenced.new(0)

    sequence = num.iterate { |x| x - 1 }
    assert_equal sequence.first(5), [0, -1, -2, -3, -4]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make this pass, we need only set the default arg to &lt;code&gt;self&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg = self)
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what? Ok, well, you may be hard pressed to use &lt;code&gt;iterate&lt;/code&gt; in your daily work,
but there is certainly more room to think about data processing as functional
operations (free of side effects) on sequences (values that can be generated on demand). Something like &lt;code&gt;iterate&lt;/code&gt; need not apply to only numbers; you can imagine sequences of letters, time objects, or POROs also being generated. At times, Rubyist are too quick to wrap collections in other classes when simpler, more generalizable &amp;ldquo;functional&amp;rdquo; transforms could suffice.&lt;/p&gt;

&lt;p&gt;When I started &lt;a href="http://devpost.com/software/learning-clojure"&gt;learning Clojure&lt;/a&gt; last year, I got really excited about the functional aspects of Ruby. &amp;ldquo;Wait, I thought everything in Ruby is an object.&amp;rdquo; Yes, but a great thing about Ruby is its &lt;a href="http://yehudakatz.com/2009/07/11/python-decorators-in-ruby/"&gt;ability to adopt aspects of other languages&lt;/a&gt;. As Piotr Solnica illustrates in &lt;a href="https://speakerdeck.com/solnic/blending-functional-and-oo-programming-in-ruby"&gt;his recent talk&lt;/a&gt;, blending functional techniques with our OO code can have a lot of benefits including avoidance of side effects and favoring composability. Introducing sequence-generating methods, like we saw here, is just one small idea to help sprinkle a little functional flavor into your Ruby code.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Recurring events in Ruby</title>
    <link rel="alternate" href="/blog/recurring-events-in-ruby.html"/>
    <id>/blog/recurring-events-in-ruby.html</id>
    <published>2016-02-02T19:00:00-05:00</published>
    <updated>2016-02-02T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo-160981e8.jpg"&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I’d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo-160981e8.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I&amp;rsquo;d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such options as the &lt;a href="https://github.com/javan/whenever"&gt;&lt;code&gt;whenever&lt;/code&gt;&lt;/a&gt; gem to setup cron from Rails and Sinatra applications. Rubyists can also take advantage of fantastic background job schedulers like &lt;a href="https://github.com/jmettraux/rufus-scheduler"&gt;&lt;code&gt;rufus-scheduler&lt;/code&gt;&lt;/a&gt; to run recurring tasks from a separate process or even an API for defining repeating &lt;a href="https://github.com/mperham/sidekiq"&gt;&lt;code&gt;Sidekiq&lt;/code&gt;&lt;/a&gt; jobs with &lt;a href="https://github.com/tobiassvn/sidetiq"&gt;&lt;code&gt;Sidetiq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For an Edgar clone though, we need a layer for users of the application to define their own recurrences. This means finding a way to represent time-based recurrences which are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;serializable, so we can save them to the database, and&lt;/li&gt;
&lt;li&gt;enumerable, so we can determine when the next post(s) should be shared on designated social networks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s an interesting problem to model. While we have classes like &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, and event &lt;code&gt;ActiveSupport::Duration&lt;/code&gt;, it&amp;rsquo;s more elusive to consider recurrences. I mean, what does it mean to represent the meeting time of my &lt;a href="http://www.meetup.com/NYC-rb/"&gt;NYC.rb&lt;/a&gt; meetup: &amp;ldquo;every second Tuesday of the month at 7pm&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Solutions for this exist in Ruby, namely &lt;a href="https://github.com/seejohnrun/ice_cube"&gt;&lt;code&gt;ice_cube&lt;/code&gt;&lt;/a&gt;. If you&amp;rsquo;re looking for a mature, up-to-date project devoted to modeling recurring events in Ruby, please check it out. I did, and highly recommend it. After playing with it for awhile, I found felt the urge for alternative semantics - like the ability to define a recurrence without a start date - and API similar to the hash-like syntax provided by another less-active recurring events library, &lt;a href="https://github.com/fnando/recurrence"&gt;&lt;code&gt;recurrence&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I thought of the &lt;a href="https://github.com/httprb/http"&gt;&lt;code&gt;HTTP&lt;/code&gt;&lt;/a&gt; gem which bills
itself as the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP (The Gem! a.k.a. http.rb) is an easy-to-use client library for making requests from Ruby. It uses a simple method chaining system for building requests, similar to Python&amp;rsquo;s &lt;a href="http://docs.python-requests.org/en/latest/"&gt;Requests&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Taking a cue from &lt;code&gt;http.rb&lt;/code&gt; and the &lt;code&gt;recurrence&lt;/code&gt; gem, I set out to create something similar for recurring events.&lt;/p&gt;

&lt;p&gt;Introducing &lt;a href="https://github.com/rossta/montrose"&gt;&lt;code&gt;Montrose&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Montrose allows you to easily create &amp;ldquo;recurrence&amp;rdquo; objects through chaining:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every Monday at 10:30am
Montrose.weekly.on(:monday).at(&amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the constructor hash-syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Montrose::Recurrence.new(every: :week, on: :monday, at: &amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Montrose recurrence responds to &lt;code&gt;#events&lt;/code&gt;, which returns an &lt;a href="/blog/what-is-enumerator.html"&gt;&lt;code&gt;Enumerator&lt;/code&gt;&lt;/a&gt; that can generate timestamps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.hourly
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;

r.events
=&amp;gt; #&amp;lt;Enumerator:...&amp;gt;

r.events.take(10)
=&amp;gt; [2016-02-03 18:26:08 -0500,
2016-02-03 19:26:08 -0500,
2016-02-03 20:26:08 -0500,
2016-02-03 21:26:08 -0500,
2016-02-03 22:26:08 -0500,
2016-02-03 23:26:08 -0500,
2016-02-04 00:26:08 -0500,
2016-02-04 01:26:08 -0500,
2016-02-04 02:26:08 -0500,
2016-02-04 03:26:08 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Montrose recurrences are themselves enumerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every month starting a year from now on Friday the 13th for 5 occurrences
r = Montrose.monthly.starting(1.year.from_now).on(friday: 13).repeat(5)

r.map(&amp;amp;:to_date)
=&amp;gt; [Fri, 13 Oct 2017,
Fri, 13 Apr 2018,
Fri, 13 Jul 2018,
Fri, 13 Sep 2019,
Fri, 13 Dec 2019]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each chained recurrence returns a new object so they can be composed and
merged:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every week
r1 = Montrose.every(:week)
r2 = Montrose.on([:tuesday, :thursday])
r3 = Montrose.at(&amp;quot;12 pm&amp;quot;)
r4 = Montrose.total(4)

r1.merge(r2).merge(r3).merge(r4).to_a
=&amp;gt; [2016-02-04 12:00:00 -0500,
2016-02-09 12:00:00 -0500,
2016-02-11 12:00:00 -0500,
2016-02-16 12:00:00 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a nod to DHH and the &lt;a href="http://rubyonrails.org/doctrine"&gt;Rails doctrine&lt;/a&gt;, Montrose aims to &lt;a href="http://rubyonrails.org/doctrine/#optimize-for-programmer-happiness"&gt;optimize for programmer happiness&lt;/a&gt;. Hence, there are several ways to define equivalent recurrences. For example, recurrences intervals can be configured as an explicit option, or inferred by the frequency duration.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 3 hours, all equivalent
Montrose.hourly.interval(3)
Montrose.every(3.hours)
Montrose::Recurrence.new(every: :hour, interval: 3)
Montrose::Recurrence.new(every: 3.hours)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Montrose&lt;/code&gt; tries to provide useful feedback when you run into exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.total(1)
r.each { |t| puts t}
Montrose::ConfigurationError: Please specify the :every option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conceptually, recurrences can represent an infinite sequence. When we say
simply &amp;ldquo;every day&amp;rdquo;, there is no implied ending. It&amp;rsquo;s therefore possible to
create a recurrence that can enumerate forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every day starting now
r = Montrose.daily

# this expression will never complete, Ctrl-c!
r.map(&amp;amp;:to_date)

# so use your `Enumerable` methods wisely
r.lazy.map(&amp;amp;:to_date).select { |d| d.mday &amp;gt; 25 }.take(5).to_a
=&amp;gt; [Fri, 26 Feb 2016,
Sat, 27 Feb 2016,
Sun, 28 Feb 2016,
Mon, 29 Feb 2016,
Sat, 26 Mar 2016]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s straightforward to convert recurrence options back to a hash.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 10 minutes starting now
opts = Montrose::Recurrence.new(every: 10.minutes).to_h
=&amp;gt; {:every=&amp;gt;:minute, :interval=&amp;gt;10}

Montrose::Recurrence.new(opts).take(3)
=&amp;gt; [2016-02-03 19:06:07 -0500,
2016-02-03 19:16:07 -0500,
2016-02-03 19:26:07 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accordingly, &lt;code&gt;Montrose::Recurrence&lt;/code&gt; implements &lt;code&gt;.dump&lt;/code&gt; and &lt;code&gt;.load&lt;/code&gt; so that you can use it with the &lt;code&gt;serialize&lt;/code&gt; feature of &lt;code&gt;ActiveRecord&lt;/code&gt; to back a recurrence by a database column in your Rails apps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class EventSeries &amp;lt; ActiveRecord::Base
  serialize :recurrence, Montrose::Recurrence
end

es = EventSeries.new(recurrence: Montrose.daily.at(&amp;quot;12pm&amp;quot;))
es.save

es = EventSeries.last
es.recurrence
# =&amp;gt; #&amp;lt;Montrose::Recurrence:...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This library is still in its early stages (version &lt;code&gt;0.2.1&lt;/code&gt; as of this writing) and aspects of the API are still in flux, such as the ability to configure default start and end times or combines multiple, distinct recurrences in a &lt;code&gt;Montrose::Schedule&lt;/code&gt;. &lt;code&gt;Montrose&lt;/code&gt; has one dependency - &lt;code&gt;ActiveSupport&lt;/code&gt; - for time calculations.&lt;/p&gt;

&lt;p&gt;There are &lt;a href="https://github.com/rossta/montrose/issues"&gt;plenty of missing features&lt;/a&gt;, including iCal serialization though Montrose already &lt;a href="https://github.com/rossta/montrose/blob/master/spec/rfc_spec.rb"&gt;supports most of the examples&lt;/a&gt; given by the iCal spec, &lt;a href="https://www.ietf.org/rfc/rfc2445.txt"&gt;rfc2445&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I still haven&amp;rsquo;t built that Edgar clone, but feel this is a good place from which to grow. As I said earlier, the &lt;code&gt;ice_cube&lt;/code&gt; gem is a mature library and already does much of what I&amp;rsquo;ve described here. Writing my own solution allowed me to think more deeply about the internal mechanisms for calculating recurrences and ultimately, once my curiosity was piqued, I couldn&amp;rsquo;t stop. If, you like what &lt;code&gt;Montrose&lt;/code&gt; has to offer and you&amp;rsquo;re feeling adventurous, try it out in your own application and send some feedback. Don&amp;rsquo;t hesitate to &lt;a href="https://github.com/rossta/montrose"&gt;fork the project&lt;/a&gt; and contribute.&lt;/p&gt;

&lt;p&gt;NYC.rb?&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Second Tuesday of every month
r = Montrose.every(:month, day: { tuesday: [2] }, at: &amp;quot;7pm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See you there.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How to write a simple web crawler in Ruby - revisited</title>
    <link rel="alternate" href="/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html"/>
    <id>/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html</id>
    <published>2016-01-26T19:00:00-05:00</published>
    <updated>2016-01-26T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo-eda44250.jpg"&gt;&lt;/p&gt;

&lt;p&gt;Let’s build a simple web crawler in Ruby. For inspiration, I’d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin’s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We’ll adapt Skork’s original goals and...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo-eda44250.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build a simple web crawler in Ruby. For inspiration, I&amp;rsquo;d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin&amp;rsquo;s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll adapt Skork&amp;rsquo;s original goals and provide a few of our own:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;must be able to crawl just a single domain&lt;/li&gt;
&lt;li&gt;must be able to limit number of pages to crawl&lt;/li&gt;
&lt;li&gt;the results should be represented as structured data so we don&amp;rsquo;t have an incomprehensible soup of content&lt;/li&gt;
&lt;li&gt;the results should be enumerable so we can have flexibility in how they&amp;rsquo;re handled&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  Caveats! Please keep in mind that there are, of course, &lt;a href="http://webscraper.io/"&gt;many&lt;/a&gt; &lt;a href="http://scrapy.org/"&gt;resources&lt;/a&gt; for
  using resilient, well-tested &lt;a href="https://www.import.io/"&gt;crawlers&lt;/a&gt; in a variety of languages. We have mere academic intentions
  here so we choose to ignore many important concerns, such as client-side rendering, parallelism, and handling failure, as a matter of convenience.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Breaking it down&lt;/h3&gt;

&lt;p&gt;For this exercise, we&amp;rsquo;re going to crawl &lt;a href="http://www.programmableweb.com/"&gt;Programmable Web&lt;/a&gt; to extract data from their &lt;a href="http://www.programmableweb.com/apis/directory"&gt;API directory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than take the naive approach of grabbing all content from any page, we&amp;rsquo;re going to build a webcrawler that emits
structured data. Traversing from the first page of the api directory, our
crawler will visit web pages like a nodes of a tree, collecting data and
additional urls along the way.&lt;/p&gt;

&lt;p&gt;Imagine that the results of our web crawl as a nested collection of
hashes with meaningful key-value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# results
[
  {
    name: &amp;quot;Google Maps&amp;quot;,
    api_provider: &amp;quot;https://google.com&amp;quot;
    api_homepage: &amp;quot;https://developers.google.com/maps/&amp;quot;
    categories: [&amp;quot;Mapping&amp;quot;, &amp;quot;Viewer&amp;quot;],
    provider_formats: [&amp;quot;JSON&amp;quot;, &amp;quot;KML&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
  {
    name: &amp;quot;Twitter&amp;quot;,
    api_provider: &amp;quot;https://twitter.com&amp;quot;
    api_homepage: &amp;quot;https://dev.twitter.com/rest/public&amp;quot;
    categories: [&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;],
    provider_formats: [&amp;quot;Atom&amp;quot;, &amp;quot;JSON&amp;quot;, &amp;quot;REST&amp;quot;, &amp;quot;RSS&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  When using a web crawler, be aware of the limitations described in the website&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard"&gt;robots.txt&lt;/a&gt; file. In this post, we skip automated parsing and detection of &lt;a href="http://www.programmableweb.com/robots.txt"&gt;Programmable Web&amp;rsquo;s robots.txt&lt;/a&gt; to filter out blacklisted urls and set a crawl delay dynamically. If you choose to run this code on your own, please crawl responsibly.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Designing the surface&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve been following my posts lately, you know that &lt;a href="https://rossta.net/blog/ruby-enumerable.html"&gt;I love Enumerable&lt;/a&gt; and you may not be surprised that I&amp;rsquo;d like to model our structured, website data with an &lt;a href="/blog/what-is-enumerator.html"&gt;Enumerator&lt;/a&gt;. This will provide a familiar, flexible interface that can be adapted for logging, storage, transformation, and a wide range of use cases.&lt;/p&gt;

&lt;p&gt;I want to simply ask a &lt;code&gt;spider&lt;/code&gt; object for its results and get back an enumerator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider.results
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll be able to do some interesting things, like stream the
results lazily into a flexible storage engine, e.g. &lt;a href="https://www.mongodb.org/"&gt;mongodb&lt;/a&gt; or &lt;code&gt;PStore&lt;/code&gt;,
available from the &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/pstore/rdoc/PStore.html"&gt;Ruby standard library&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;pstore&amp;quot;
store  = PStore.new(&amp;quot;api_directory.pstore&amp;quot;)

# create `spider`, then ...

spider.results.lazy.take(50).each_with_index do |result, i|
  store.transaction do
    store[result[:name]] = result
    store.commit
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Writing the crawler&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to write a &lt;code&gt;Spider&lt;/code&gt; class to enumerate website data. Our spider implementation borrows heavily from &lt;a href="https://github.com/joeyAghion/spidey"&gt;joeyAghion&amp;rsquo;s spidey&lt;/a&gt; gem, described as a &amp;ldquo;loose framework for crawling and scraping websites&amp;rdquo; and Python&amp;rsquo;s venerable &lt;a href="http://scrapy.org/"&gt;Scrapy&lt;/a&gt; project, which allows you to scrape websites &amp;ldquo;in a fast, simple, yet extensible way.&amp;rdquo; Both resources achieve the goals of being easy-to-use and extensible.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll build our web crawler piece-by-piece, but if you want a full preview of the source, check out it &lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; will maintain a set of urls to visit, data is collects, and a set of url &amp;ldquo;handlers&amp;rdquo; that will describe how each page should be processed. We&amp;rsquo;ll take advantage of one external dependency, &lt;code&gt;mechanize&lt;/code&gt;, to handle interaction with the pages we visit - to extract data, resolve urls, follow redirects, etc. Below is the &lt;code&gt;#enqueue&lt;/code&gt; method to add urls and their handlers to a running list in our spider.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;mechanize&amp;quot; # as of this writing, the latest release is 2.7.4

class Spider
  def enqueue(url, method)
    url = agent.resolve(url).to_s
    return if @handlers[url]
    @urls &amp;lt;&amp;lt; url
    @handlers[url] ||= { method: method, data: {} }
  end

  private

  def agent
    @agent ||= Mechanize.new
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we process each page we&amp;rsquo;ll need a way to record the structured data we extract from various pages. We&amp;rsquo;ll expose a &lt;code&gt;#record&lt;/code&gt; method append a hash of data to the &lt;code&gt;@results&lt;/code&gt; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def record(data = {})
    @results &amp;lt;&amp;lt; data
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our &lt;code&gt;Spider&lt;/code&gt; will only know how to enumerate urls and record data, we&amp;rsquo;ll introduce a collaborator object to contain the implementation for consuming data for a specific site. For now, we&amp;rsquo;ll call this object a &amp;ldquo;processor&amp;rdquo;. The processor will respond to the messages &lt;code&gt;#root&lt;/code&gt; and &lt;code&gt;#handler&lt;/code&gt; - the first url and handler method to enqueue for the spider, respectively. We&amp;rsquo;ll also provide options for enforcing limits on the number of pages to crawl and the delay between each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  REQUEST_INTERVAL = 5
  MAX_URLS = 1000

  def initialize(processor, attrs = {})
    @processor = processor

    @urls     = []
    @results  = []
    @handlers = {}

    @interval = attrs.fetch(:interval, REQUEST_INTERVAL)
    @max_urls = attrs.fetch(:max_urls, MAX_URLS)

    enqueue(processor.root, processor.handler)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Enumerator Two Ways&lt;/h3&gt;

&lt;p&gt;Now for the real meat of our young &lt;code&gt;Spider&lt;/code&gt;. The &lt;code&gt;#results&lt;/code&gt; method is the key public interface: it enumerates the enqueued urls and yields members of the &lt;code&gt;@results&lt;/code&gt; collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def results
    return enum_for(:results) unless block_given?

    index = @results.length
    enqueued_urls.each do |url, handler|

      # process url
      @processor.send(handler[:method], agent.get(url), handler[:data])

      if block_given? &amp;amp;&amp;amp; @results.length &amp;gt; index
        yield @results.last
        index += 1
      end

      # crawl delay
      sleep @interval if @interval &amp;gt; 0
    end
  end

  private

  def enqueued_urls
    Enumerator.new do |y|
      index = 0
      while index &amp;lt; @urls.count &amp;amp;&amp;amp; index &amp;lt;= @max_urls
        url = @urls[index]
        index += 1
        next unless url
        y.yield url, @handlers[url]
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting thing to note is that the size of our url queue and the collected results may be growing as we crawl more pages. For the &lt;code&gt;#enqueued_urls&lt;/code&gt; private method, we&amp;rsquo;re using an &lt;code&gt;Enumerator&lt;/code&gt; to wrap the logic for iterating over the list of &lt;code&gt;@urls&lt;/code&gt; and maintaining state, like the &lt;code&gt;index&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; class is well-suited to represent a lazily generated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def enqueued_urls
  Enumerator.new do |y|
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find it to be a more expressive way to indicate we&amp;rsquo;re enumerating values &amp;ldquo;on demand&amp;rdquo; as opposed to &amp;ldquo;eagerly&amp;rdquo;, like a typical collection.&lt;/p&gt;

&lt;p&gt;Notice we&amp;rsquo;re also returning an enumerator from &lt;code&gt;#results&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def results
  return enum_for(:results) unless block_given?
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique provides the method caller to more flexibility when determining
how to handler the results. While you could pass a block to consume the
results, e.g., &lt;code&gt;spider.results { |r| puts r.inspect }&lt;/code&gt;, this is an eager
operation. We&amp;rsquo;d have to wait for all the pages to be processed before continuing
with the block. Returning an enumerator offers the potential to stream results
to something like a data store.&lt;/p&gt;

&lt;p&gt;Why not include &lt;code&gt;Enumerable&lt;/code&gt; in our &lt;code&gt;Spider&lt;/code&gt; and implement &lt;code&gt;#each&lt;/code&gt; instead? As pointed out in &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Arkency&amp;rsquo;s Stop including Enumerable, return Enumerator
instead&lt;/a&gt;, our
&lt;code&gt;Spider&lt;/code&gt; class doesn&amp;rsquo;t itself represent a collection, so exposing the &lt;code&gt;#results&lt;/code&gt;
method as an enumerator is more appropriate.&lt;/p&gt;

&lt;h3&gt;From Soup to Net Results&lt;/h3&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; is now functional so we can move onto the details of extracting data from an actual website.&lt;/p&gt;

&lt;p&gt;Our processor, &lt;code&gt;ProgrammableWeb&lt;/code&gt; will be responsible for wrappin a &lt;code&gt;Spider&lt;/code&gt; instance and extracting data from
the pages it visits. As mentioned previously, our processor will need to
define a root url and initial handler method, for which defaults are provided, and delegate the &lt;code&gt;#results&lt;/code&gt; method to a &lt;code&gt;Spider&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProgrammableWeb
  attr_reader :root, :handler

  def initialize(root: &amp;quot;https://www.programmableweb.com/apis/directory&amp;quot;, handler: :process_index, **options)
    @root = root
    @handler = handler
    @options = options
  end

  def results(&amp;amp;block)
    spider.results(&amp;amp;block)
  end

  private

  def spider
    @spider ||= Spider.new(self, @options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ProgrammableWeb&lt;/code&gt; will define handler methods that deserialize a web page into additional urls and data to add to our collection of results.
Our spider will invoke the handlers (as seen above with &lt;code&gt;@processor.send(method, agent.get(url), data)&lt;/code&gt;). Each handler method will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def handler_method(page, data = {})
  # enqueue urls and/or record data
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; where &lt;code&gt;page&lt;/code&gt; is an instance of &lt;code&gt;Mechanize::Page&lt;/code&gt; (&lt;a href="http://docs.seattlerb.org/mechanize/Mechanize/Page.html"&gt;docs&lt;/a&gt;) providing a number of methods for interacting with html content:&lt;/p&gt;

&lt;p&gt;The root handler method, &lt;code&gt;ProgrammableWeb#process_index&lt;/code&gt;, will extract api names in the
index list, enqueue api detail pages and additional, paginated indexes. As data
is collected, it may be passed on to handlers further down the tree via
&lt;code&gt;Spider#enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_index(page, data = {})
  page.links_with(href: %r{\?page=\d+}).each do |link|
    spider.enqueue(link.href, :process_index)
  end

  page.links_with(href: %r{/api/\w+$}).each do |link|
    spider.enqueue(link.href, :process_api, name: link.text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process api detail pages, we&amp;rsquo;ll define a separate handler. Since these pages
will represent &amp;ldquo;leaves&amp;rdquo; in this exercise, we&amp;rsquo;ll merge the data passed in with
that extracted from the page and pass it along to &lt;code&gt;Spider#record&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_api(page, data = {})
  fields = page.search(&amp;quot;#tabs-content .field&amp;quot;).each_with_object({}) do |tag, o|
    key = tag.search(&amp;quot;label&amp;quot;).text.strip.downcase.gsub(%r{[^\w]+}, &amp;#39; &amp;#39;).gsub(%r{\s+}, &amp;quot;_&amp;quot;).to_sym
    val = tag.search(&amp;quot;span&amp;quot;).text
    o[key] = val
  end

  categories = page.search(&amp;quot;article.node-api .tags&amp;quot;).first.text.strip.split(/\s+/)

  spider.record data.merge(fields).merge(categories: categories)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw earlier, recorded data is emitted in the &lt;code&gt;Spider#results&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Now we can make use of our &lt;code&gt;ProgrammableWeb&lt;/code&gt; crawler as intended with simple
instantiation and the ability to enumerate results as a stream of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider = ProgrammableWeb.new

spider.results.lazy.take(5).each_with_index do |result, i|
  puts &amp;quot;%-3s: %s&amp;quot; % [i, result.inspect]
end

# 0 : {:name=&amp;gt;&amp;quot;Facebook&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://facebook.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.facebook.com/restserver.php&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.facebook.com/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Webhooks&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, REST&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;http://developers.facebook.com/documentation.php?doc=clients&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.developers.facebook.com/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/fbplatform&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://developers.facebook.com/group.php?gid=2205007948&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developers.facebook.com/tools/explorer&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;API Key, OAuth 2, Username/password&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Webhooks&amp;quot;]}
# 1 : {:name=&amp;gt;&amp;quot;LinkedIn&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.linkedin.com/&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.linkedin.com/v1/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developer.linkedin.com/docs&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Enterprise&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, JSONP, REST, XML&amp;quot;, :other_options=&amp;gt;&amp;quot;JavaScript&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_forum=&amp;gt;&amp;quot;https://developer.linkedin.com/forum&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/linkedindev&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developer.linkedinlabs.com/jsapi-console/#examples/login/simple.html&amp;amp;{&amp;amp;quot;framework&amp;amp;quot;:&amp;amp;quot;platform.linkedin.com/in.js&amp;amp;quot;,&amp;amp;quot;frameworkurl&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;apikey&amp;amp;quot;:&amp;amp;quo&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Enterprise&amp;quot;]}
# 2 : {:name=&amp;gt;&amp;quot;Skype&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_homepage=&amp;gt;&amp;quot;http://www.skype.com/en/developer/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Telephony&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Chat, Messaging, Video, Voice&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Unspecified&amp;quot;, :other_options=&amp;gt;&amp;quot;Skype proprietary&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;https://developer.skype.com/Docs/Web https://developer.skype.com/wiki/Java_API&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;Unspecified&amp;quot;, :categories=&amp;gt;[&amp;quot;Telephony&amp;quot;, &amp;quot;Chat,&amp;quot;, &amp;quot;Messaging,&amp;quot;, &amp;quot;Video,&amp;quot;, &amp;quot;Voice&amp;quot;]}
# 3 : {:name=&amp;gt;&amp;quot;Twitter&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://twitter.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://twitter.com/statuses/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://dev.twitter.com/rest/public&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Blogging&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, JSON, REST, RSS, XML&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/twitter-development-talk&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/twitterapi&amp;quot;, :contact_email=&amp;gt;&amp;quot;api@twitter.com&amp;quot;, :console_url=&amp;gt;&amp;quot;https://dev.twitter.com/console&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2, HTTP Basic Auth, OAuth&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;]}
# 4 : {:name=&amp;gt;&amp;quot;YouTube&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.google.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://gdata.youtube.com/feeds/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.google.com/youtube/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Video&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Media&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, RSS, JSON, XML, GData&amp;quot;, :other_options=&amp;gt;&amp;quot;Atom Publishing Protocol (Atom/RSS)&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;Java, PHP Python, Ruby, ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/youtube-api/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/YouTubeDev/&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://code.google.com/support/bin/topic.py?topic=12357&amp;quot;, :console_url=&amp;gt;&amp;quot;http://code.google.com/apis/ajax/playground/?exp=youtube#simple_embed&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth2&amp;quot;, :categories=&amp;gt;[&amp;quot;Video&amp;quot;, &amp;quot;Media&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;I admit, it&amp;rsquo;s arguable that this implementation is &amp;ldquo;simple&amp;rdquo;. Skorks provided a straightforward, recursive solution to consume unstructured content. Our approach is iterative and requires some work up front to define which links to consume and how to process them with &amp;ldquo;handlers&amp;rdquo;. However, we were able to achieve an extensible, flexible tool with a nice separation of concerns and a familiar, enumerable interface.&lt;/p&gt;

&lt;p&gt;Modeling results from a multi-level page crawl as a collection may not work for every use case, but, for this exercise, it serves as a nice abstraction. It would now be trivial to take our &lt;code&gt;Spider&lt;/code&gt; class and implement a new processor for a site like &lt;a href="https://rubygems.org"&gt;rubygems.org&lt;/a&gt; or &lt;a href="https://craigslist.org"&gt;craigslist&lt;/a&gt; and stream the results to a database like &lt;a href="http://redis.io"&gt;Redis&lt;/a&gt; or &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html"&gt;&lt;code&gt;YAML::Store&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Try it yourself and let me know what you think of this approach (&lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;full source&lt;/a&gt;).&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What's new in Ruby 2.3 Enumerable</title>
    <link rel="alternate" href="/blog/whats-new-in-ruby-2-3-enumerable.html"/>
    <id>/blog/whats-new-in-ruby-2-3-enumerable.html</id>
    <published>2016-01-17T19:00:00-05:00</published>
    <updated>2016-01-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo-a158f6e5.jpg"&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We’ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo-a158f6e5.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We&amp;rsquo;ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep allows you to select members of a collection that match an expression. That expression is &lt;code&gt;some_object === item&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What does &amp;ldquo;triple equals&amp;rdquo; do? Well, in Ruby, as in most languages, that answer is complicated. Since we can define this method however we want in our own classes, it can mean anything. But, most commonly, it is a loose way of asking whether an object belongs to a certain group:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;a&lt;/code&gt; === &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is a subset of &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Symbol === :foo     # =&amp;gt; true, :foo is a symbol
String === &amp;quot;foo&amp;quot;    # =&amp;gt; true, &amp;quot;foo&amp;quot; is a string
Symbol === &amp;quot;foo&amp;quot;    # =&amp;gt; false, &amp;quot;foo&amp;quot; is not a symbol
String === :foo     # =&amp;gt; false, :foo is not a string

/foo/ === &amp;quot;foobar&amp;quot;  # =&amp;gt; true, &amp;quot;foobar&amp;quot; matches /foo/
(1..10) === 2       # =&amp;gt; true, 2 is in the range 1..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; use &lt;code&gt;select&lt;/code&gt; to filter out items of a collection with the &lt;code&gt;===&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(20).select { |i| (6..10) === i } # =&amp;gt; [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is what &lt;code&gt;grep&lt;/code&gt; is for:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep(6..8) # =&amp;gt; [6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;grep&lt;/code&gt; is like saying &amp;ldquo;gimme all the items in the given set&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To get all the items &lt;em&gt;not&lt;/em&gt; included, use &lt;code&gt;grep_v&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep_v(6..8)
=&amp;gt; [1, 2, 3, 4, 5, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably most likely that you&amp;rsquo;d use &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; with a regular expression, like
to select all the months that end in &amp;ldquo;er&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MONTHS.grep(/er$/)
=&amp;gt; [&amp;quot;September&amp;quot;, &amp;quot;October&amp;quot;, &amp;quot;November&amp;quot;, &amp;quot;December&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define &lt;code&gt;===&lt;/code&gt; on any class or object to take advantage of filtering with &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; in other contexts.&lt;/p&gt;

&lt;h4&gt;Chunking&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Enumerable&lt;/code&gt; module provides several methods for enumerating adjacent
members of a collection, including &lt;code&gt;slice_when&lt;/code&gt;, &lt;code&gt;slice_before&lt;/code&gt;, &lt;code&gt;slice_after&lt;/code&gt;,
&lt;code&gt;each_cons&lt;/code&gt;, and, not surprisingly, &lt;code&gt;chunk&lt;/code&gt;. Ruby 2.3 offers yet another
chunking method, &lt;code&gt;chunk_while&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before diving into &lt;code&gt;chunk_while&lt;/code&gt;, let&amp;rsquo;s look at its relatives, &lt;code&gt;chunk&lt;/code&gt; and &lt;code&gt;slice_when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the following examples, we&amp;rsquo;ll enumerate over recurring events given by the
&lt;code&gt;Montrose&lt;/code&gt; gem. Montrose provides an api to create recurrences as enumerators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a recurrence that will enumerate over every other Tuesday at noon.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;montrose&amp;quot;

r = Montrose.every(2.weeks, on: :tuesday, at: &amp;#39;12pm&amp;#39;)

r.take(10).to_a
=&amp;gt; [2016-02-02 12:00:00 -0500,
 2016-02-16 12:00:00 -0500,
 2016-03-01 12:00:00 -0500,
 2016-03-15 12:00:00 -0400,
 2016-03-29 12:00:00 -0400,
 2016-04-12 12:00:00 -0400,
 2016-04-26 12:00:00 -0400,
 2016-05-10 12:00:00 -0400,
 2016-05-24 12:00:00 -0400,
 2016-06-07 12:00:00 -0400]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For calendaring, it may be useful to split this array into chunks by month.&lt;/p&gt;

&lt;p&gt;We could use &lt;code&gt;group_by&lt;/code&gt; to return a hash of month numbers to Tuesday time
instances:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month)
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;chunk&lt;/code&gt; method is similar to &lt;code&gt;group_by&lt;/code&gt; as it will divide the collection
into groups based on the given block/proc except it returns an enumerator
instead of a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month)
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I recently &lt;a href="/blog/what-is-enumerator.html"&gt;described some great things you can do with enumerators in Ruby&lt;/a&gt; including transforming the result of chunk into an array of month, time pairs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month).to_a
=&amp;gt; [[2, [2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500]],
 [3, [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400]],
 [4, [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400]],
 [5, [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400]],
 [6, [2016-06-07 12:00:00 -0400]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly enough, passing the previous result to &lt;code&gt;Hash[]&lt;/code&gt; returns the same
result we got with &lt;code&gt;group_by&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Hash[r.take(10).chunk(&amp;amp;:month).to_a]
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we just wanted the groups of times, not the month keys, we could ask for the
&lt;code&gt;group_by&lt;/code&gt; values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month).values
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can replace this computation with &lt;code&gt;slice_when&lt;/code&gt; which will allow us to compare
adjacent members to determine &amp;ldquo;when&amp;rdquo; to start a new slice (or chunk). That means
the block we pass to &lt;code&gt;slice_when&lt;/code&gt; accepts two arguments, the current and
previous collection member, and should return true or false. In this
case, we want a new slice to start when the month of the previous time does not
match the month of the current time as we enumerate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).slice_when { |a, b| a.month != b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the return value of &lt;code&gt;slice_when&lt;/code&gt; is an enumerator like we saw with &lt;code&gt;chunk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out, the most common use cases of &lt;code&gt;slice_when&lt;/code&gt; tend to be negative
comparisons, i.e., &amp;ldquo;slice when the previous thing is not the same as the current
thing&amp;rdquo;. Since this is Ruby after all, wouldn&amp;rsquo;t you prefer to stay positive?&lt;/p&gt;

&lt;p&gt;Which brings us to &lt;code&gt;chunk_while&lt;/code&gt;. Ruby 2.3 introduces this positive complement to
&lt;code&gt;slice_when&lt;/code&gt; so we can say, &amp;ldquo;keep the same chunk if the current thing &lt;em&gt;does&lt;/em&gt;
match the previous thing&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Back to our Tuesday recurrences. Let&amp;rsquo;s replace &lt;code&gt;slice_when&lt;/code&gt; with &lt;code&gt;chunk_while&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk_while { |a, b| a.month == b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in short, &lt;code&gt;Enumerable&lt;/code&gt; in Ruby 2.3 gives us both a negative and a positive variation, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt; respectively, on existing methods.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Looking for a way to handle recurring events in your app? Be sure to check out &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
</feed>
