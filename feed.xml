<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-02-16T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Clojure's iterate in Ruby</title>
    <link rel="alternate" href="/blog/clojure-iterate-in-ruby.html"/>
    <id>/blog/clojure-iterate-in-ruby.html</id>
    <published>2016-02-16T19:00:00-05:00</published>
    <updated>2016-02-16T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the result of an algorithm. Previously, I described how to generate Clojure-like &lt;a href="https://rossta.net/blog/pascals-triangle-with-rubys-enumerator.html"&gt;sequences in Ruby&lt;/a&gt; (without the immutability anyways), including &lt;a href="https://rossta.net/blog/infinite-sequences-in-ruby.html"&gt;Pascal&amp;rsquo;s Triangle&lt;/a&gt; using &lt;code&gt;Enumerator&lt;/code&gt;, which allows us to package up an algorithm as an object that can emit values as any &amp;ldquo;eager&amp;rdquo; collection can, like &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Clojure provides a few functions that can be used to generate sequences,
including &lt;code&gt;iterate&lt;/code&gt;. According to the &lt;a href="https://clojuredocs.org/clojure.core/iterate"&gt;docs&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, &lt;code&gt;iterate&lt;/code&gt; will emit values starting with the first and repeatedly call the given function with the return value of the previous call.&lt;/p&gt;

&lt;p&gt;The signature in Clojure looks this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;(iterate f x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can generate a simple sequence of numbers using the &lt;code&gt;inc&lt;/code&gt; function and some start value:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate inc 1)
(1 2 3 4 5 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we have a terse was of generating a sequence like this in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb(main)&amp;gt; (1..5).to_a
=&amp;gt; [1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this solution doesn&amp;rsquo;t generalize to other types of sequences like, for instance,
generating a sequence of the powers of 2. In the example below, &lt;code&gt;(partial * 2)&lt;/code&gt;
returns a function that multiplies a single argument by 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate (partial * 2) 1)
(1 2 4 8 16 32 64 128 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get this result in Ruby, we might try something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; (1..7).each_with_object([]) { |n, seq| seq &amp;lt;&amp;lt; (seq.last.nil? ? n : seq.last * 2) }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not very pretty (ok, I admit that&amp;rsquo;s a strawman). But this also is an &amp;ldquo;eagerly&amp;rdquo;
generated collection whereas we want something that can be lazily generated to
get closer to Clojure.&lt;/p&gt;

&lt;p&gt;While there may be a number of ways to generate these sequences in Ruby, for this
exercise, we also want something that has a similar signature to Clojure&amp;rsquo;s &lt;code&gt;iterate&lt;/code&gt;,
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(x, &amp;amp;block)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll leverage Ruby&amp;rsquo;s method block convention in place of the function, &lt;code&gt;f&lt;/code&gt;.
Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; iterate(1) { |n| n + 1 }
=&amp;gt; [1, 2, 3, 4, 5, ...]
irb&amp;gt; iterate(1) { |n| n * 2 }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two examples now have the same &amp;ldquo;surface area&amp;rdquo; and have a lot in common with the Clojure
companions. So how would we implement this?&lt;/p&gt;

&lt;p&gt;First a test. By the way, all the code found in the following examples is &lt;a href="https://github.com/rossta/loves-enumerable/tree/master/examples/sequence"&gt;on Github&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;
require_relative &amp;#39;./sequence&amp;#39;

class TestSequence &amp;lt; Minitest::Test
  include Sequence

  def test_iterate_increment
    sequence = iterate(1) { |x| x + 1 }

    assert_equal sequence.first(5), [1, 2, 3, 4, 5]
  end

  def test_iterate_power_of_2
    sequence = iterate(1) { |x| x * 2 }

    assert_equal sequence.first(5), [1, 2, 4, 8, 16]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re going to implement &lt;code&gt;iterate&lt;/code&gt; in a Ruby module called &lt;code&gt;Sequence&lt;/code&gt;. Our test
for &lt;code&gt;iterate&lt;/code&gt; will return an instance of &lt;code&gt;Enumerator&lt;/code&gt; (the &lt;code&gt;sequence&lt;/code&gt; variable).
The enumerator allows use to generate the sequence on demand with the call to
&lt;code&gt;#first&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg)
    Enumerator.new do |yielder|
      current = arg
      loop do
        yielder &amp;lt;&amp;lt; current
        current = yield(current)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our implementation of &lt;code&gt;iterate&lt;/code&gt; returns an &lt;code&gt;Enumerator&lt;/code&gt; that will first yield
the given &lt;code&gt;arg&lt;/code&gt; and repeatedly call the given block with the result of the
previous call. The &lt;code&gt;loop&lt;/code&gt; construct means this enumeration can potentially
continue forever - capturing the spirit of a Clojure sequence. That means
we need to use a terminating functions like &lt;code&gt;#first&lt;/code&gt; or &lt;code&gt;#take&lt;/code&gt; to limit the
results, just like we would in Clojure:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (take 5 (iterate (partial * 2) 1))
(1 2 4 8 16)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Ruby equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(1) { |n| n * 2 }.take(5)
=&amp;gt; [1, 2, 4, 8, 16]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could go one step further an make this method work as a mixin. Below is a
test for using &lt;code&gt;iterate&lt;/code&gt; as an instance method of a class using in our tests
that will simply delegate missing methods to the object passed in on
instantiation.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class TestSequence &amp;lt; Minitest::Test
  include Sequence

  class Sequenced &amp;lt; SimpleDelegator
    include Sequence
  end

  def test_iterate_include
    num = Sequenced.new(0)

    sequence = num.iterate { |x| x - 1 }
    assert_equal sequence.first(5), [0, -1, -2, -3, -4]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make this pass, we need only set the default arg to &lt;code&gt;self&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg = self)
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what? Ok, well, you may be hard pressed to use &lt;code&gt;iterate&lt;/code&gt; in your daily work,
but there is certainly more room to think about data processing as functional
operations (free of side effects) on sequences (values that can be generated on demand). Something like &lt;code&gt;iterate&lt;/code&gt; need not apply to only numbers; you can imagine sequences of letters, time objects, or POROs also being generated. At times, Rubyist are too quick to wrap collections in other classes when simpler, more generalizable &amp;ldquo;functional&amp;rdquo; transforms could suffice.&lt;/p&gt;

&lt;p&gt;When I started &lt;a href="http://devpost.com/software/learning-clojure"&gt;learning Clojure&lt;/a&gt; last year, I got really excited about the functional aspects of Ruby. &amp;ldquo;Wait, I thought everything in Ruby is an object.&amp;rdquo; Yes, but a great thing about Ruby is its &lt;a href="http://yehudakatz.com/2009/07/11/python-decorators-in-ruby/"&gt;ability to adopt aspects of other languages&lt;/a&gt;. As Piotr Solnica illustrates in &lt;a href="https://speakerdeck.com/solnic/blending-functional-and-oo-programming-in-ruby"&gt;his recent talk&lt;/a&gt;, blending functional techniques with our OO code can have a lot of benefits including avoidance of side effects and favoring composability. Introducing sequence-generating methods, like we saw here, is just one small idea to help sprinkle a little functional flavor into your Ruby code.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Recurring events in Ruby</title>
    <link rel="alternate" href="/blog/recurring-events-in-ruby.html"/>
    <id>/blog/recurring-events-in-ruby.html</id>
    <published>2016-02-02T19:00:00-05:00</published>
    <updated>2016-02-02T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo.jpg?1455835444"&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I’d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo.jpg?1455835444" /&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I&amp;rsquo;d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such options as the &lt;a href="https://github.com/javan/whenever"&gt;&lt;code&gt;whenever&lt;/code&gt;&lt;/a&gt; gem to setup cron from Rails and Sinatra applications. Rubyists can also take advantage of fantastic background job schedulers like &lt;a href="https://github.com/jmettraux/rufus-scheduler"&gt;&lt;code&gt;rufus-scheduler&lt;/code&gt;&lt;/a&gt; to run recurring tasks from a separate process or even an API for defining repeating &lt;a href="https://github.com/mperham/sidekiq"&gt;&lt;code&gt;Sidekiq&lt;/code&gt;&lt;/a&gt; jobs with &lt;a href="https://github.com/tobiassvn/sidetiq"&gt;&lt;code&gt;Sidetiq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For an Edgar clone though, we need a layer for users of the application to define their own recurrences. This means finding a way to represent time-based recurrences which are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;serializable, so we can save them to the database, and&lt;/li&gt;
&lt;li&gt;enumerable, so we can determine when the next post(s) should be shared on designated social networks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s an interesting problem to model. While we have classes like &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, and event &lt;code&gt;ActiveSupport::Duration&lt;/code&gt;, it&amp;rsquo;s more elusive to consider recurrences. I mean, what does it mean to represent the meeting time of my &lt;a href="http://www.meetup.com/NYC-rb/"&gt;NYC.rb&lt;/a&gt; meetup: &amp;ldquo;every second Tuesday of the month at 7pm&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Solutions for this exist in Ruby, namely &lt;a href="https://github.com/seejohnrun/ice_cube"&gt;&lt;code&gt;ice_cube&lt;/code&gt;&lt;/a&gt;. If you&amp;rsquo;re looking for a mature, up-to-date project devoted to modeling recurring events in Ruby, please check it out. I did, and highly recommend it. After playing with it for awhile, I found felt the urge for alternative semantics - like the ability to define a recurrence without a start date - and API similar to the hash-like syntax provided by another less-active recurring events library, &lt;a href="https://github.com/fnando/recurrence"&gt;&lt;code&gt;recurrence&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I thought of the &lt;a href="https://github.com/httprb/http"&gt;&lt;code&gt;HTTP&lt;/code&gt;&lt;/a&gt; gem which bills
itself as the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP (The Gem! a.k.a. http.rb) is an easy-to-use client library for making requests from Ruby. It uses a simple method chaining system for building requests, similar to Python&amp;rsquo;s &lt;a href="http://docs.python-requests.org/en/latest/"&gt;Requests&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Taking a cue from &lt;code&gt;http.rb&lt;/code&gt; and the &lt;code&gt;recurrence&lt;/code&gt; gem, I set out to create something similar for recurring events.&lt;/p&gt;

&lt;p&gt;Introducing &lt;a href="https://github.com/rossta/montrose"&gt;&lt;code&gt;Montrose&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Montrose allows you to easily create &amp;ldquo;recurrence&amp;rdquo; objects through chaining:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every Monday at 10:30am
Montrose.weekly.on(:monday).at(&amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the constructor hash-syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Montrose::Recurrence.new(every: :week, on: :monday, at: &amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Montrose recurrence responds to &lt;code&gt;#events&lt;/code&gt;, which returns an &lt;a href="/blog/what-is-enumerator.html"&gt;&lt;code&gt;Enumerator&lt;/code&gt;&lt;/a&gt; that can generate timestamps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.hourly
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;

r.events
=&amp;gt; #&amp;lt;Enumerator:...&amp;gt;

r.events.take(10)
=&amp;gt; [2016-02-03 18:26:08 -0500,
2016-02-03 19:26:08 -0500,
2016-02-03 20:26:08 -0500,
2016-02-03 21:26:08 -0500,
2016-02-03 22:26:08 -0500,
2016-02-03 23:26:08 -0500,
2016-02-04 00:26:08 -0500,
2016-02-04 01:26:08 -0500,
2016-02-04 02:26:08 -0500,
2016-02-04 03:26:08 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Montrose recurrences are themselves enumerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every month starting a year from now on Friday the 13th for 5 occurrences
r = Montrose.monthly.starting(1.year.from_now).on(friday: 13).repeat(5)

r.map(&amp;amp;:to_date)
=&amp;gt; [Fri, 13 Oct 2017,
Fri, 13 Apr 2018,
Fri, 13 Jul 2018,
Fri, 13 Sep 2019,
Fri, 13 Dec 2019]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each chained recurrence returns a new object so they can be composed and
merged:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every week
r1 = Montrose.every(:week)
r2 = Montrose.on([:tuesday, :thursday])
r3 = Montrose.at(&amp;quot;12 pm&amp;quot;)
r4 = Montrose.total(4)

r1.merge(r2).merge(r3).merge(r4).to_a
=&amp;gt; [2016-02-04 12:00:00 -0500,
2016-02-09 12:00:00 -0500,
2016-02-11 12:00:00 -0500,
2016-02-16 12:00:00 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a nod to DHH and the &lt;a href="http://rubyonrails.org/doctrine"&gt;Rails doctrine&lt;/a&gt;, Montrose aims to &lt;a href="http://rubyonrails.org/doctrine/#optimize-for-programmer-happiness"&gt;optimize for programmer happiness&lt;/a&gt;. Hence, there are several ways to define equivalent recurrences. For example, recurrences intervals can be configured as an explicit option, or inferred by the frequency duration.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 3 hours, all equivalent
Montrose.hourly.interval(3)
Montrose.every(3.hours)
Montrose::Recurrence.new(every: :hour, interval: 3)
Montrose::Recurrence.new(every: 3.hours)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Montrose&lt;/code&gt; tries to provide useful feedback when you run into exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.total(1)
r.each { |t| puts t}
Montrose::ConfigurationError: Please specify the :every option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conceptually, recurrences can represent an infinite sequence. When we say
simply &amp;ldquo;every day&amp;rdquo;, there is no implied ending. It&amp;rsquo;s therefore possible to
create a recurrence that can enumerate forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every day starting now
r = Montrose.daily

# this expression will never complete, Ctrl-c!
r.map(&amp;amp;:to_date)

# so use your `Enumerable` methods wisely
r.lazy.map(&amp;amp;:to_date).select { |d| d.mday &amp;gt; 25 }.take(5).to_a
=&amp;gt; [Fri, 26 Feb 2016,
Sat, 27 Feb 2016,
Sun, 28 Feb 2016,
Mon, 29 Feb 2016,
Sat, 26 Mar 2016]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s straightforward to convert recurrence options back to a hash.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 10 minutes starting now
opts = Montrose::Recurrence.new(every: 10.minutes).to_h
=&amp;gt; {:every=&amp;gt;:minute, :interval=&amp;gt;10}

Montrose::Recurrence.new(opts).take(3)
=&amp;gt; [2016-02-03 19:06:07 -0500,
2016-02-03 19:16:07 -0500,
2016-02-03 19:26:07 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accordingly, &lt;code&gt;Montrose::Recurrence&lt;/code&gt; implements &lt;code&gt;.dump&lt;/code&gt; and &lt;code&gt;.load&lt;/code&gt; so that you can use it with the &lt;code&gt;serialize&lt;/code&gt; feature of &lt;code&gt;ActiveRecord&lt;/code&gt; to back a recurrence by a database column in your Rails apps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class EventSeries &amp;lt; ActiveRecord::Base
  serialize :recurrence, Montrose::Recurrence
end

es = EventSeries.new(recurrence: Montrose.daily.at(&amp;quot;12pm&amp;quot;))
es.save

es = EventSeries.last
es.recurrence
# =&amp;gt; #&amp;lt;Montrose::Recurrence:...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This library is still in its early stages (version &lt;code&gt;0.2.1&lt;/code&gt; as of this writing) and aspects of the API are still in flux, such as the ability to configure default start and end times or combines multiple, distinct recurrences in a &lt;code&gt;Montrose::Schedule&lt;/code&gt;. &lt;code&gt;Montrose&lt;/code&gt; has one dependency - &lt;code&gt;ActiveSupport&lt;/code&gt; - for time calculations.&lt;/p&gt;

&lt;p&gt;There are &lt;a href="https://github.com/rossta/montrose/issues"&gt;plenty of missing features&lt;/a&gt;, including iCal serialization though Montrose already &lt;a href="https://github.com/rossta/montrose/blob/master/spec/rfc_spec.rb"&gt;supports most of the examples&lt;/a&gt; given by the iCal spec, &lt;a href="https://www.ietf.org/rfc/rfc2445.txt"&gt;rfc2445&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I still haven&amp;rsquo;t built that Edgar clone, but feel this is a good place from which to grow. As I said earlier, the &lt;code&gt;ice_cube&lt;/code&gt; gem is a mature library and already does much of what I&amp;rsquo;ve described here. Writing my own solution allowed me to think more deeply about the internal mechanisms for calculating recurrences and ultimately, once my curiosity was piqued, I couldn&amp;rsquo;t stop. If, you like what &lt;code&gt;Montrose&lt;/code&gt; has to offer and you&amp;rsquo;re feeling adventurous, try it out in your own application and send some feedback. Don&amp;rsquo;t hesitate to &lt;a href="https://github.com/rossta/montrose"&gt;fork the project&lt;/a&gt; and contribute.&lt;/p&gt;

&lt;p&gt;NYC.rb?&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Second Tuesday of every month
r = Montrose.every(:month, day: { tuesday: [2] }, at: &amp;quot;7pm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See you there.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How to write a simple web crawler in Ruby - revisited</title>
    <link rel="alternate" href="/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html"/>
    <id>/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html</id>
    <published>2016-01-26T19:00:00-05:00</published>
    <updated>2016-01-26T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo.jpg?1455835444"&gt;&lt;/p&gt;

&lt;p&gt;Let’s build a simple web crawler in Ruby. For inspiration, I’d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin’s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We’ll adapt Skork’s original goals and...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo.jpg?1455835444" /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build a simple web crawler in Ruby. For inspiration, I&amp;rsquo;d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin&amp;rsquo;s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll adapt Skork&amp;rsquo;s original goals and provide a few of our own:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;must be able to crawl just a single domain&lt;/li&gt;
&lt;li&gt;must be able to limit number of pages to crawl&lt;/li&gt;
&lt;li&gt;the results should be represented as structured data so we don&amp;rsquo;t have an incomprehensible soup of content&lt;/li&gt;
&lt;li&gt;the results should be enumerable so we can have flexibility in how they&amp;rsquo;re handled&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  Caveats! Please keep in mind that there are, of course, &lt;a href="http://webscraper.io/"&gt;many&lt;/a&gt; &lt;a href="http://scrapy.org/"&gt;resources&lt;/a&gt; for
  using resilient, well-tested &lt;a href="https://www.import.io/"&gt;crawlers&lt;/a&gt; in a variety of languages. We have mere academic intentions
  here so we choose to ignore many important concerns, such as client-side rendering, parallelism, and handling failure, as a matter of convenience.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Breaking it down&lt;/h3&gt;

&lt;p&gt;For this exercise, we&amp;rsquo;re going to crawl &lt;a href="http://www.programmableweb.com/"&gt;Programmable Web&lt;/a&gt; to extract data from their &lt;a href="http://www.programmableweb.com/apis/directory"&gt;API directory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than take the naive approach of grabbing all content from any page, we&amp;rsquo;re going to build a webcrawler that emits
structured data. Traversing from the first page of the api directory, our
crawler will visit web pages like a nodes of a tree, collecting data and
additional urls along the way.&lt;/p&gt;

&lt;p&gt;Imagine that the results of our web crawl as a nested collection of
hashes with meaningful key-value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# results
[
  {
    name: &amp;quot;Google Maps&amp;quot;,
    api_provider: &amp;quot;https://google.com&amp;quot;
    api_homepage: &amp;quot;https://developers.google.com/maps/&amp;quot;
    categories: [&amp;quot;Mapping&amp;quot;, &amp;quot;Viewer&amp;quot;],
    provider_formats: [&amp;quot;JSON&amp;quot;, &amp;quot;KML&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
  {
    name: &amp;quot;Twitter&amp;quot;,
    api_provider: &amp;quot;https://twitter.com&amp;quot;
    api_homepage: &amp;quot;https://dev.twitter.com/rest/public&amp;quot;
    categories: [&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;],
    provider_formats: [&amp;quot;Atom&amp;quot;, &amp;quot;JSON&amp;quot;, &amp;quot;REST&amp;quot;, &amp;quot;RSS&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  When using a web crawler, be aware of the limitations described in the website&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard"&gt;robots.txt&lt;/a&gt; file. In this post, we skip automated parsing and detection of &lt;a href="http://www.programmableweb.com/robots.txt"&gt;Programmable Web&amp;rsquo;s robots.txt&lt;/a&gt; to filter out blacklisted urls and set a crawl delay dynamically. If you choose to run this code on your own, please crawl responsibly.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Designing the surface&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve been following my posts lately, you know that &lt;a href="https://rossta.net/blog/ruby-enumerable.html"&gt;I love Enumerable&lt;/a&gt; and you may not be surprised that I&amp;rsquo;d like to model our structured, website data with an &lt;a href="/blog/what-is-enumerator.html"&gt;Enumerator&lt;/a&gt;. This will provide a familiar, flexible interface that can be adapted for logging, storage, transformation, and a wide range of use cases.&lt;/p&gt;

&lt;p&gt;I want to simply ask a &lt;code&gt;spider&lt;/code&gt; object for its results and get back an enumerator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider.results
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll be able to do some interesting things, like stream the
results lazily into a flexible storage engine, e.g. &lt;a href="https://www.mongodb.org/"&gt;mongodb&lt;/a&gt; or &lt;code&gt;PStore&lt;/code&gt;,
available from the &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/pstore/rdoc/PStore.html"&gt;Ruby standard library&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;pstore&amp;quot;
store  = PStore.new(&amp;quot;api_directory.pstore&amp;quot;)

# create `spider`, then ...

spider.results.lazy.take(50).each_with_index do |result, i|
  store.transaction do
    store[result[:name]] = result
    store.commit
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Writing the crawler&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to write a &lt;code&gt;Spider&lt;/code&gt; class to enumerate website data. Our spider implementation borrows heavily from &lt;a href="https://github.com/joeyAghion/spidey"&gt;joeyAghion&amp;rsquo;s spidey&lt;/a&gt; gem, described as a &amp;ldquo;loose framework for crawling and scraping websites&amp;rdquo; and Python&amp;rsquo;s venerable &lt;a href="http://scrapy.org/"&gt;Scrapy&lt;/a&gt; project, which allows you to scrape websites &amp;ldquo;in a fast, simple, yet extensible way.&amp;rdquo; Both resources achieve the goals of being easy-to-use and extensible.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll build our web crawler piece-by-piece, but if you want a full preview of the source, check out it &lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; will maintain a set of urls to visit, data is collects, and a set of url &amp;ldquo;handlers&amp;rdquo; that will describe how each page should be processed. We&amp;rsquo;ll take advantage of one external dependency, &lt;code&gt;mechanize&lt;/code&gt;, to handle interaction with the pages we visit - to extract data, resolve urls, follow redirects, etc. Below is the &lt;code&gt;#enqueue&lt;/code&gt; method to add urls and their handlers to a running list in our spider.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;mechanize&amp;quot; # as of this writing, the latest release is 2.7.4

class Spider
  def enqueue(url, method)
    url = agent.resolve(url).to_s
    return if @handlers[url]
    @urls &amp;lt;&amp;lt; url
    @handlers[url] ||= { method: method, data: {} }
  end

  private

  def agent
    @agent ||= Mechanize.new
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we process each page we&amp;rsquo;ll need a way to record the structured data we extract from various pages. We&amp;rsquo;ll expose a &lt;code&gt;#record&lt;/code&gt; method append a hash of data to the &lt;code&gt;@results&lt;/code&gt; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def record(data = {})
    @results &amp;lt;&amp;lt; data
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our &lt;code&gt;Spider&lt;/code&gt; will only know how to enumerate urls and record data, we&amp;rsquo;ll introduce a collaborator object to contain the implementation for consuming data for a specific site. For now, we&amp;rsquo;ll call this object a &amp;ldquo;processor&amp;rdquo;. The processor will respond to the messages &lt;code&gt;#root&lt;/code&gt; and &lt;code&gt;#handler&lt;/code&gt; - the first url and handler method to enqueue for the spider, respectively. We&amp;rsquo;ll also provide options for enforcing limits on the number of pages to crawl and the delay between each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  REQUEST_INTERVAL = 5
  MAX_URLS = 1000

  def initialize(processor, attrs = {})
    @processor = processor

    @urls     = []
    @results  = []
    @handlers = {}

    @interval = attrs.fetch(:interval, REQUEST_INTERVAL)
    @max_urls = attrs.fetch(:max_urls, MAX_URLS)

    enqueue(processor.root, processor.handler)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Enumerator Two Ways&lt;/h3&gt;

&lt;p&gt;Now for the real meat of our young &lt;code&gt;Spider&lt;/code&gt;. The &lt;code&gt;#results&lt;/code&gt; method is the key public interface: it enumerates the enqueued urls and yields members of the &lt;code&gt;@results&lt;/code&gt; collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def results
    return enum_for(:results) unless block_given?

    index = @results.length
    enqueued_urls.each do |url, handler|

      # process url
      @processor.send(handler[:method], agent.get(url), handler[:data])

      if block_given? &amp;amp;&amp;amp; @results.length &amp;gt; index
        yield @results.last
        index += 1
      end

      # crawl delay
      sleep @interval if @interval &amp;gt; 0
    end
  end

  private

  def enqueued_urls
    Enumerator.new do |y|
      index = 0
      while index &amp;lt; @urls.count &amp;amp;&amp;amp; index &amp;lt;= @max_urls
        url = @urls[index]
        index += 1
        next unless url
        y.yield url, @handlers[url]
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting thing to note is that the size of our url queue and the collected results may be growing as we crawl more pages. For the &lt;code&gt;#enqueued_urls&lt;/code&gt; private method, we&amp;rsquo;re using an &lt;code&gt;Enumerator&lt;/code&gt; to wrap the logic for iterating over the list of &lt;code&gt;@urls&lt;/code&gt; and maintaining state, like the &lt;code&gt;index&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; class is well-suited to represent a lazily generated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def enqueued_urls
  Enumerator.new do |y|
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find it to be a more expressive way to indicate we&amp;rsquo;re enumerating values &amp;ldquo;on demand&amp;rdquo; as opposed to &amp;ldquo;eagerly&amp;rdquo;, like a typical collection.&lt;/p&gt;

&lt;p&gt;Notice we&amp;rsquo;re also returning an enumerator from &lt;code&gt;#results&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def results
  return enum_for(:results) unless block_given?
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique provides the method caller to more flexibility when determining
how to handler the results. While you could pass a block to consume the
results, e.g., &lt;code&gt;spider.results { |r| puts r.inspect }&lt;/code&gt;, this is an eager
operation. We&amp;rsquo;d have to wait for all the pages to be processed before continuing
with the block. Returning an enumerator offers the potential to stream results
to something like a data store.&lt;/p&gt;

&lt;p&gt;Why not include &lt;code&gt;Enumerable&lt;/code&gt; in our &lt;code&gt;Spider&lt;/code&gt; and implement &lt;code&gt;#each&lt;/code&gt; instead? As pointed out in &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Arkency&amp;rsquo;s Stop including Enumerable, return Enumerator
instead&lt;/a&gt;, our
&lt;code&gt;Spider&lt;/code&gt; class doesn&amp;rsquo;t itself represent a collection, so exposing the &lt;code&gt;#results&lt;/code&gt;
method as an enumerator is more appropriate.&lt;/p&gt;

&lt;h3&gt;From Soup to Net Results&lt;/h3&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; is now functional so we can move onto the details of extracting data from an actual website.&lt;/p&gt;

&lt;p&gt;Our processor, &lt;code&gt;ProgrammableWeb&lt;/code&gt; will be responsible for wrappin a &lt;code&gt;Spider&lt;/code&gt; instance and extracting data from
the pages it visits. As mentioned previously, our processor will need to
define a root url and initial handler method, for which defaults are provided, and delegate the &lt;code&gt;#results&lt;/code&gt; method to a &lt;code&gt;Spider&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProgrammableWeb
  attr_reader :root, :handler

  def initialize(root: &amp;quot;https://www.programmableweb.com/apis/directory&amp;quot;, handler: :process_index, **options)
    @root = root
    @handler = handler
    @options = options
  end

  def results(&amp;amp;block)
    spider.results(&amp;amp;block)
  end

  private

  def spider
    @spider ||= Spider.new(self, @options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ProgrammableWeb&lt;/code&gt; will define handler methods that deserialize a web page into additional urls and data to add to our collection of results.
Our spider will invoke the handlers (as seen above with &lt;code&gt;@processor.send(method, agent.get(url), data)&lt;/code&gt;). Each handler method will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def handler_method(page, data = {})
  # enqueue urls and/or record data
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; where &lt;code&gt;page&lt;/code&gt; is an instance of &lt;code&gt;Mechanize::Page&lt;/code&gt; (&lt;a href="http://docs.seattlerb.org/mechanize/Mechanize/Page.html"&gt;docs&lt;/a&gt;) providing a number of methods for interacting with html content:&lt;/p&gt;

&lt;p&gt;The root handler method, &lt;code&gt;ProgrammableWeb#process_index&lt;/code&gt;, will extract api names in the
index list, enqueue api detail pages and additional, paginated indexes. As data
is collected, it may be passed on to handlers further down the tree via
&lt;code&gt;Spider#enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_index(page, data = {})
  page.links_with(href: %r{\?page=\d+}).each do |link|
    spider.enqueue(link.href, :process_index)
  end

  page.links_with(href: %r{/api/\w+$}).each do |link|
    spider.enqueue(link.href, :process_api, name: link.text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process api detail pages, we&amp;rsquo;ll define a separate handler. Since these pages
will represent &amp;ldquo;leaves&amp;rdquo; in this exercise, we&amp;rsquo;ll merge the data passed in with
that extracted from the page and pass it along to &lt;code&gt;Spider#record&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_api(page, data = {})
  fields = page.search(&amp;quot;#tabs-content .field&amp;quot;).each_with_object({}) do |tag, o|
    key = tag.search(&amp;quot;label&amp;quot;).text.strip.downcase.gsub(%r{[^\w]+}, &amp;#39; &amp;#39;).gsub(%r{\s+}, &amp;quot;_&amp;quot;).to_sym
    val = tag.search(&amp;quot;span&amp;quot;).text
    o[key] = val
  end

  categories = page.search(&amp;quot;article.node-api .tags&amp;quot;).first.text.strip.split(/\s+/)

  spider.record data.merge(fields).merge(categories: categories)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw earlier, recorded data is emitted in the &lt;code&gt;Spider#results&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Now we can make use of our &lt;code&gt;ProgrammableWeb&lt;/code&gt; crawler as intended with simple
instantiation and the ability to enumerate results as a stream of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider = ProgrammableWeb.new

spider.results.lazy.take(5).each_with_index do |result, i|
  puts &amp;quot;%-3s: %s&amp;quot; % [i, result.inspect]
end

# 0 : {:name=&amp;gt;&amp;quot;Facebook&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://facebook.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.facebook.com/restserver.php&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.facebook.com/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Webhooks&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, REST&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;http://developers.facebook.com/documentation.php?doc=clients&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.developers.facebook.com/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/fbplatform&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://developers.facebook.com/group.php?gid=2205007948&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developers.facebook.com/tools/explorer&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;API Key, OAuth 2, Username/password&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Webhooks&amp;quot;]}
# 1 : {:name=&amp;gt;&amp;quot;LinkedIn&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.linkedin.com/&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.linkedin.com/v1/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developer.linkedin.com/docs&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Enterprise&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, JSONP, REST, XML&amp;quot;, :other_options=&amp;gt;&amp;quot;JavaScript&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_forum=&amp;gt;&amp;quot;https://developer.linkedin.com/forum&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/linkedindev&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developer.linkedinlabs.com/jsapi-console/#examples/login/simple.html&amp;amp;{&amp;amp;quot;framework&amp;amp;quot;:&amp;amp;quot;platform.linkedin.com/in.js&amp;amp;quot;,&amp;amp;quot;frameworkurl&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;apikey&amp;amp;quot;:&amp;amp;quo&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Enterprise&amp;quot;]}
# 2 : {:name=&amp;gt;&amp;quot;Skype&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_homepage=&amp;gt;&amp;quot;http://www.skype.com/en/developer/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Telephony&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Chat, Messaging, Video, Voice&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Unspecified&amp;quot;, :other_options=&amp;gt;&amp;quot;Skype proprietary&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;https://developer.skype.com/Docs/Web https://developer.skype.com/wiki/Java_API&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;Unspecified&amp;quot;, :categories=&amp;gt;[&amp;quot;Telephony&amp;quot;, &amp;quot;Chat,&amp;quot;, &amp;quot;Messaging,&amp;quot;, &amp;quot;Video,&amp;quot;, &amp;quot;Voice&amp;quot;]}
# 3 : {:name=&amp;gt;&amp;quot;Twitter&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://twitter.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://twitter.com/statuses/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://dev.twitter.com/rest/public&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Blogging&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, JSON, REST, RSS, XML&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/twitter-development-talk&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/twitterapi&amp;quot;, :contact_email=&amp;gt;&amp;quot;api@twitter.com&amp;quot;, :console_url=&amp;gt;&amp;quot;https://dev.twitter.com/console&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2, HTTP Basic Auth, OAuth&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;]}
# 4 : {:name=&amp;gt;&amp;quot;YouTube&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.google.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://gdata.youtube.com/feeds/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.google.com/youtube/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Video&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Media&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, RSS, JSON, XML, GData&amp;quot;, :other_options=&amp;gt;&amp;quot;Atom Publishing Protocol (Atom/RSS)&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;Java, PHP Python, Ruby, ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/youtube-api/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/YouTubeDev/&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://code.google.com/support/bin/topic.py?topic=12357&amp;quot;, :console_url=&amp;gt;&amp;quot;http://code.google.com/apis/ajax/playground/?exp=youtube#simple_embed&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth2&amp;quot;, :categories=&amp;gt;[&amp;quot;Video&amp;quot;, &amp;quot;Media&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;I admit, it&amp;rsquo;s arguable that this implementation is &amp;ldquo;simple&amp;rdquo;. Skorks provided a straightforward, recursive solution to consume unstructured content. Our approach is iterative and requires some work up front to define which links to consume and how to process them with &amp;ldquo;handlers&amp;rdquo;. However, we were able to achieve an extensible, flexible tool with a nice separation of concerns and a familiar, enumerable interface.&lt;/p&gt;

&lt;p&gt;Modeling results from a multi-level page crawl as a collection may not work for every use case, but, for this exercise, it serves as a nice abstraction. It would now be trivial to take our &lt;code&gt;Spider&lt;/code&gt; class and implement a new processor for a site like &lt;a href="https://rubygems.org"&gt;rubygems.org&lt;/a&gt; or &lt;a href="https://craigslist.org"&gt;craigslist&lt;/a&gt; and stream the results to a database like &lt;a href="http://redis.io"&gt;Redis&lt;/a&gt; or &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html"&gt;&lt;code&gt;YAML::Store&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Try it yourself and let me know what you think of this approach (&lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;full source&lt;/a&gt;).&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What's new in Ruby 2.3 Enumerable</title>
    <link rel="alternate" href="/blog/whats-new-in-ruby-2-3-enumerable.html"/>
    <id>/blog/whats-new-in-ruby-2-3-enumerable.html</id>
    <published>2016-01-17T19:00:00-05:00</published>
    <updated>2016-01-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo.jpg?1455835444"&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We’ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo.jpg?1455835444" /&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We&amp;rsquo;ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep allows you to select members of a collection that match an expression. That expression is &lt;code&gt;some_object === item&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What does &amp;ldquo;triple equals&amp;rdquo; do? Well, in Ruby, as in most languages, that answer is complicated. Since we can define this method however we want in our own classes, it can mean anything. But, most commonly, it is a loose way of asking whether an object belongs to a certain group:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;a&lt;/code&gt; === &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is a subset of &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Symbol === :foo     # =&amp;gt; true, :foo is a symbol
String === &amp;quot;foo&amp;quot;    # =&amp;gt; true, &amp;quot;foo&amp;quot; is a string
Symbol === &amp;quot;foo&amp;quot;    # =&amp;gt; false, &amp;quot;foo&amp;quot; is not a symbol
String === :foo     # =&amp;gt; false, :foo is not a string

/foo/ === &amp;quot;foobar&amp;quot;  # =&amp;gt; true, &amp;quot;foobar&amp;quot; matches /foo/
(1..10) === 2       # =&amp;gt; true, 2 is in the range 1..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; use &lt;code&gt;select&lt;/code&gt; to filter out items of a collection with the &lt;code&gt;===&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(20).select { |i| (6..10) === i } # =&amp;gt; [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is what &lt;code&gt;grep&lt;/code&gt; is for:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep(6..8) # =&amp;gt; [6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;grep&lt;/code&gt; is like saying &amp;ldquo;gimme all the items in the given set&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To get all the items &lt;em&gt;not&lt;/em&gt; included, use &lt;code&gt;grep_v&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep_v(6..8)
=&amp;gt; [1, 2, 3, 4, 5, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably most likely that you&amp;rsquo;d use &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; with a regular expression, like
to select all the months that end in &amp;ldquo;er&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MONTHS.grep(/er$/)
=&amp;gt; [&amp;quot;September&amp;quot;, &amp;quot;October&amp;quot;, &amp;quot;November&amp;quot;, &amp;quot;December&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define &lt;code&gt;===&lt;/code&gt; on any class or object to take advantage of filtering with &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; in other contexts.&lt;/p&gt;

&lt;h4&gt;Chunking&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Enumerable&lt;/code&gt; module provides several methods for enumerating adjacent
members of a collection, including &lt;code&gt;slice_when&lt;/code&gt;, &lt;code&gt;slice_before&lt;/code&gt;, &lt;code&gt;slice_after&lt;/code&gt;,
&lt;code&gt;each_cons&lt;/code&gt;, and, not surprisingly, &lt;code&gt;chunk&lt;/code&gt;. Ruby 2.3 offers yet another
chunking method, &lt;code&gt;chunk_while&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before diving into &lt;code&gt;chunk_while&lt;/code&gt;, let&amp;rsquo;s look at its relatives, &lt;code&gt;chunk&lt;/code&gt; and &lt;code&gt;slice_when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the following examples, we&amp;rsquo;ll enumerate over recurring events given by the
&lt;code&gt;Montrose&lt;/code&gt; gem. Montrose provides an api to create recurrences as enumerators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a recurrence that will enumerate over every other Tuesday at noon.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;montrose&amp;quot;

r = Montrose.every(2.weeks, on: :tuesday, at: &amp;#39;12pm&amp;#39;)

r.take(10).to_a
=&amp;gt; [2016-02-02 12:00:00 -0500,
 2016-02-16 12:00:00 -0500,
 2016-03-01 12:00:00 -0500,
 2016-03-15 12:00:00 -0400,
 2016-03-29 12:00:00 -0400,
 2016-04-12 12:00:00 -0400,
 2016-04-26 12:00:00 -0400,
 2016-05-10 12:00:00 -0400,
 2016-05-24 12:00:00 -0400,
 2016-06-07 12:00:00 -0400]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For calendaring, it may be useful to split this array into chunks by month.&lt;/p&gt;

&lt;p&gt;We could use &lt;code&gt;group_by&lt;/code&gt; to return a hash of month numbers to Tuesday time
instances:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month)
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;chunk&lt;/code&gt; method is similar to &lt;code&gt;group_by&lt;/code&gt; as it will divide the collection
into groups based on the given block/proc except it returns an enumerator
instead of a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month)
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I recently &lt;a href="/blog/what-is-enumerator.html"&gt;described some great things you can do with enumerators in Ruby&lt;/a&gt; including transforming the result of chunk into an array of month, time pairs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month).to_a
=&amp;gt; [[2, [2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500]],
 [3, [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400]],
 [4, [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400]],
 [5, [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400]],
 [6, [2016-06-07 12:00:00 -0400]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly enough, passing the previous result to &lt;code&gt;Hash[]&lt;/code&gt; returns the same
result we got with &lt;code&gt;group_by&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Hash[r.take(10).chunk(&amp;amp;:month).to_a]
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we just wanted the groups of times, not the month keys, we could ask for the
&lt;code&gt;group_by&lt;/code&gt; values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month).values
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can replace this computation with &lt;code&gt;slice_when&lt;/code&gt; which will allow us to compare
adjacent members to determine &amp;ldquo;when&amp;rdquo; to start a new slice (or chunk). That means
the block we pass to &lt;code&gt;slice_when&lt;/code&gt; accepts two arguments, the current and
previous collection member, and should return true or false. In this
case, we want a new slice to start when the month of the previous time does not
match the month of the current time as we enumerate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).slice_when { |a, b| a.month != b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the return value of &lt;code&gt;slice_when&lt;/code&gt; is an enumerator like we saw with &lt;code&gt;chunk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out, the most common use cases of &lt;code&gt;slice_when&lt;/code&gt; tend to be negative
comparisons, i.e., &amp;ldquo;slice when the previous thing is not the same as the current
thing&amp;rdquo;. Since this is Ruby after all, wouldn&amp;rsquo;t you prefer to stay positive?&lt;/p&gt;

&lt;p&gt;Which brings us to &lt;code&gt;chunk_while&lt;/code&gt;. Ruby 2.3 introduces this positive complement to
&lt;code&gt;slice_when&lt;/code&gt; so we can say, &amp;ldquo;keep the same chunk if the current thing &lt;em&gt;does&lt;/em&gt;
match the previous thing&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Back to our Tuesday recurrences. Let&amp;rsquo;s replace &lt;code&gt;slice_when&lt;/code&gt; with &lt;code&gt;chunk_while&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk_while { |a, b| a.month == b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in short, &lt;code&gt;Enumerable&lt;/code&gt; in Ruby 2.3 gives us both a negative and a positive variation, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt; respectively, on existing methods.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Looking for a way to handle recurring events in your app? Be sure to check out &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Debugging SystemStackError</title>
    <link rel="alternate" href="/blog/debugging-systemstackerror.html"/>
    <id>/blog/debugging-systemstackerror.html</id>
    <published>2016-01-11T19:00:00-05:00</published>
    <updated>2016-01-11T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo.jpg?1455835444"&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words,...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo.jpg?1455835444" /&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words, the memory allocated to execute the program exceeded the memory
available on the stack.&lt;/p&gt;

&lt;p&gt;The most common cause of a stack overflow in application code that
recursively calls itself without terminating arguments: an infinite loop in your
code.&lt;/p&gt;

&lt;p&gt;You can reproduce such an error with code like this in a terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ pry --noprompt
def foo
  foo
end
=&amp;gt; :foo
foo
SystemStackError: stack level too deep
from /Users/ross/.gem/ruby/2.1.6/gems/pry-0.10.3/lib/pry/pry_instance.rb:355
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: for the examples in this post, assume I&amp;rsquo;m using Ruby 2.1 unless otherwise
indicated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;$ ruby -v
ruby 2.1.6p336 (2015-04-13 revision 50298) [x86_64-darwin14.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prior to Ruby 2.2 and &lt;a href="https://bugs.ruby-lang.org/issues/6216"&gt;this issue&lt;/a&gt;, the
backtrace for &lt;code&gt;SystemStackError&lt;/code&gt; was reduced to one line. That meant, unless
that one line lead you to an obvious culprit in your source code, it
would be very difficult to unravel the method calls causing the stack to overflow.&lt;/p&gt;

&lt;p&gt;So, first step in debugging the &lt;code&gt;SystemStackError&lt;/code&gt; is upgrade to Ruby 2.2!&lt;/p&gt;

&lt;p&gt;In case that&amp;rsquo;s not possible, there&amp;rsquo;s still hope. Let&amp;rsquo;s try using information
from the error first. Here&amp;rsquo;s the method containing &lt;a href="https://github.com/rossta/montrose/blob/e5b7a12f6832b4f971a52b27800cefe144ecd399/lib/montrose/options.rb#L204"&gt;the line in the backtrace&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# lib/montrose/options.rb:204

def map_arg(arg, &amp;amp;block)
  return nil unless arg

  Array(arg).map(&amp;amp;block)    # line 204
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No obvious culprit. This method doesn&amp;rsquo;t call itself and there are multiple callers
of this method in this class.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try rescuing from the error in a test and printing the execution stack
using &lt;a href="http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-caller"&gt;&lt;code&gt;Kernel.caller&lt;/code&gt;&lt;/a&gt;. I can isolate the application code that produces the stack overflow in a single test and rescue there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;it &amp;quot;a test&amp;quot; do
  # given

  begin
    # when
  rescue SystemStackError
    puts caller
  end

  # then
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what I get:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bin/m spec/rfc_spec.rb:426
/Users/ross/dev/rossta/montrose/spec/rfc_spec.rb:434:in `block (2 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:108:in `block (3 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:205:in `capture_exceptions&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:105:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:256:in `time_it&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:104:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:276:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:103:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:781:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:308:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:296:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `each&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:321:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:294:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `block in __run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `map&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `__run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:129:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runners/minitest_5.rb:9:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/executor.rb:26:in `execute&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runner.rb:17:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m.rb:13:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/bin/m:4:in `&amp;lt;top (required)&amp;gt;&amp;#39;
bin/m:16:in `load&amp;#39;
bin/m:16:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backtrace points to lines in minitest. Since I&amp;rsquo;ve been running tests prior
to this isssue successfully, it&amp;rsquo;s unlikely minitest is the source of the stack overflow error. So rescuing from &lt;code&gt;SytemStackError&lt;/code&gt; doesn&amp;rsquo;t help us either.&lt;/p&gt;

&lt;p&gt;Luckily, we have &lt;a href="https://gist.github.com/jbgo/4493822"&gt;this gist&lt;/a&gt; from
&lt;a href="https://github.com/jbgo"&gt;@jbgo&lt;/a&gt; who highlighted a special feature in Ruby for
tracing function events: &lt;a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-set_trace_func"&gt;&lt;code&gt;Kernel.set_trace_func&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the example from the docs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Test
  def test
    a = 1
    b = 2
  end
end

set_trace_func proc { |event, file, line, id, binding, classname|
  printf &amp;quot;%8s %s:%-2d %10s %8s\n&amp;quot;, event, file, line, id, classname
}
t = Test.new
t.test

    line prog.rb:11               false
  c-call prog.rb:11        new    Class
  c-call prog.rb:11 initialize   Object
c-return prog.rb:11 initialize   Object
c-return prog.rb:11        new    Class
    line prog.rb:12               false
    call prog.rb:2        test     Test
    line prog.rb:3        test     Test
    line prog.rb:4        test     Test
  return prog.rb:4        test     Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method &lt;code&gt;set_trace_func&lt;/code&gt; sets a global proc to be invoked in response to
runtime events including the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c-call&lt;/code&gt; a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-return&lt;/code&gt; return from a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call&lt;/code&gt; a Ruby method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; start a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end&lt;/code&gt; finish a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt; execute code on a new line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raise&lt;/code&gt; raise an exception&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt; return from a Ruby method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we want to isolate the Ruby method causing the infinite loop in our stack,
we&amp;rsquo;ll log the line info for &lt;code&gt;call&lt;/code&gt; events:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb

$trace_out = open(&amp;quot;trace.txt&amp;quot;)

set_trace_func proc { |event, file, line, id, binding, classname|
  if event == &amp;#39;call&amp;#39;
    $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-running the test produces a &lt;code&gt;trace.txt&lt;/code&gt; file that records all the Ruby method
calls encountered during execution. Inspecting this log, we hope to find a
repeating pattern of an identical list of method calls.&lt;/p&gt;

&lt;p&gt;In my case, the start of each pattern pointed to another line in my source where
the stack originates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A useful trick is to keep the trace routine in a separate file that you can
incorporate with an environment variable. You can also leverage &lt;code&gt;Kernel.caller&lt;/code&gt;
here and only log when the stack exceeds an arbitrarily large size.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/support/trace.rb

if ENV[&amp;quot;TRACE&amp;quot;]
  $stack_size = ENV[&amp;quot;TRACE&amp;quot;].to_i
  $trace_out = open(&amp;quot;trace.txt&amp;quot;)

  set_trace_func proc { |event, file, line, id, binding, classname|
    if event == &amp;#39;call&amp;#39; &amp;amp;&amp;amp; caller.length &amp;gt; $stack_size
      $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
    end
  }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt; gem, &lt;a href="https://github.com/rossta/montrose/blob/9600e0b63bde342011b3b9b1e29ab9f76f5f69c3/spec/support/trace.rb"&gt;this file&lt;/a&gt; gets loaded during every test run but the &lt;code&gt;set_trace_func&lt;/code&gt; hook will
only be evaluated when the &lt;code&gt;TRACE&lt;/code&gt; environment variable is present:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ TRACE=500 bin/m spec/montrose/recurrence_spec.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, you won&amp;rsquo;t need to resort to this workaround for &lt;code&gt;SystemStackError&lt;/code&gt; in Ruby
2.2+, but keep this in mind next time you get stuck &amp;ldquo;in the loop&amp;rdquo;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using RSpec Metadata</title>
    <link rel="alternate" href="/blog/using-rspec-metadata.html"/>
    <id>/blog/using-rspec-metadata.html</id>
    <published>2015-12-28T19:00:00-05:00</published>
    <updated>2015-12-28T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Fall" src="/assets/images/blog/stock/fall-leaves-pexels-photo.jpg?1455835444"&gt;&lt;/p&gt;

&lt;p&gt;A useful feature of RSpec is the ability to pass metadata to tests and suites.&lt;/p&gt;

&lt;p&gt;You may already be familiar with how &lt;a href="https://github.com/jnicklas/capybara"&gt;Capybara&lt;/a&gt; uses the &lt;code&gt;:js&lt;/code&gt; option to enable the javascript driver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;describe "a javascript feature", :js do
  # tests run against the...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Fall" src="/assets/images/blog/stock/fall-leaves-pexels-photo.jpg?1455835444" /&gt;&lt;/p&gt;

&lt;p&gt;A useful feature of RSpec is the ability to pass metadata to tests and suites.&lt;/p&gt;

&lt;p&gt;You may already be familiar with how &lt;a href="https://github.com/jnicklas/capybara"&gt;Capybara&lt;/a&gt; uses the &lt;code&gt;:js&lt;/code&gt; option to enable the javascript driver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;describe &amp;quot;a javascript feature&amp;quot;, :js do
  # tests run against the Capyabara.javascript_driver
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Capybara &lt;a href="https://github.com/jnicklas/capybara/blob/957c35f580b68e8a140b5bbe7818fdcf06bc4521/lib/capybara/rspec.rb#L27"&gt;provides an RSpec configuration hook&lt;/a&gt; that changes the web driver for any example where &lt;code&gt;:js&lt;/code&gt; metadata is present. Here it is, oversimplified:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# capybara/rspec.rb
RSpec.configure do |config|
  config.before do
    Capybara.current_driver = Capybara.javascript_driver if example.metadata[:js]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We may reach a point in the maturity of our test suite when it makes sense add our own configuration options.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
The examples in the post are based on RSpec version &lt;code&gt;~&gt; 3&lt;/code&gt;.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Changing Test Runner Behavior&lt;/h3&gt;

&lt;p&gt;Testing libraries like RSpec and Capybara do some heavy lifting to set up the
Rails environment and make it suitable for running in test mode. For performance
reasons, it may be beneficial to run each of our specs in a database
transaction so test data can be easily rolled back at the start of each spec.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a common base configuration for using the popular &lt;a href="https://github.com/DatabaseCleaner/database_cleaner"&gt;DatabaseCleaner&lt;/a&gt; gem to
set up transactional database behavior for RSpec:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not all specs can be run this way - once we add a javascript acceptance specs, for
example, the javascript driver will likely need its own connection to the
database so it won&amp;rsquo;t have access to data setup in the tests. We need to run
javascript acceptance specs in &lt;em&gt;truncation&lt;/em&gt; mode to ensure database changes are
committed to the database so multiple database connections will have access to the same data.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use RSpec metadata to toggle database behavior automatically when using
the javascript driver (i.e., not the default &lt;code&gt;:rack_test&lt;/code&gt; driver). We&amp;rsquo;ll add the
following hooks, borrowed from the DatabaseCleaner &lt;a href="https://github.com/DatabaseCleaner/database_cleaner/tree/f32abebc4f28faa6ff944c4d1d4fee3f21ceb0bb#rspec-example"&gt;README&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
config.before(:each, type: :feature) do
  # :rack_test driver&amp;#39;s Rack app under test shares database connection
  # with the specs, so continue to use transaction strategy for speed.
  driver_shares_db_connection_with_specs = Capybara.current_driver == :rack_test

  if !driver_shares_db_connection_with_specs
    # Driver is probably for an external browser with an app
    # under test that does *not* share a database connection with the
    # specs, so use truncation strategy.
    DatabaseCleaner.strategy = :truncation
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also run into problems with ActiveRecord &lt;code&gt;after_commit&lt;/code&gt; callbacks - when running
tests in transaction mode, these callbacks will never fire. We can also
add an option for enabling truncation mode outside of acceptance specs when
isolated specs are needed for these callbacks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/model/user_spec.rb
it &amp;quot;triggers background job after creating new user&amp;quot;, :truncation_mode do
  # test after_commit callback
end

# spec/spec_helper.rb
config.before(:each, :truncation_mode) do
  DatabaseCleaner.strategy = :truncation
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a consolidated configuration for providing hooks for the issues related
to database truncation mentioned above:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
  end

  config.before(:each) do
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each, type: :feature) do
    driver_shares_db_connection_with_specs = Capybara.current_driver == :rack_test

    if !driver_shares_db_connection_with_specs
      DatabaseCleaner.strategy = :truncation
    end
  end

  config.before(:each, :truncation_mode) do
    DatabaseCleaner.strategy = :truncation
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Changing Application Settings&lt;/h3&gt;

&lt;p&gt;Rails provides a number of settings that can be easily configured based on the
environment, so we avoid undesired work in development or test environments,
such as sending emails. For any mature Rails application, we&amp;rsquo;ll likely have
our own custom settings layered on top of the Rails defaults.&lt;/p&gt;

&lt;p&gt;There are many cases where we&amp;rsquo;ll still want to test the production settings in
our test environments.  For example, by default, controller caching is disabled in tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/test.rb
Rails.application.configure do
  # ...
  config.action_controller.perform_caching = false

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For selected acceptances specs, we may still want to test behavior of caching at
the view layer, say that users can see new info when a model attribute changes. We don&amp;rsquo;t need this caching behavior is all test, so it may be useful to toggle specs on/off during the test run.&lt;/p&gt;

&lt;h4&gt;First attempt&lt;/h4&gt;

&lt;p&gt;We could try to stub the setting in the context of a single spec run with the enabled state.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.before(:each, :caching) do
    allow_any_instance_of(ActionController::Base).to receive(:perform_caching).and_return true
  end

  config.after(:each, :caching) do
    Rails.cache.clear
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may require changing behavior of instances which is &lt;a href="https://relishapp.com/rspec/rspec-mocks/docs/working-with-legacy-code/any-instance"&gt;typically discouraged&lt;/a&gt;. We may also need to clean up other global state, like clearing the Rails cache after the test run.&lt;/p&gt;

&lt;h4&gt;Better attempt&lt;/h4&gt;

&lt;p&gt;Alternatively, we can set the actual values on while settings are derived.
Here&amp;rsquo;s how it might look for enabling controller caching with an &lt;code&gt;around&lt;/code&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.around(:each, :caching) do |example|
    caching = ActionController::Base.perform_caching
    ActionController::Base.perform_caching = example.metadata[:caching]

    example.run

    Rails.cache.clear
    ActionController::Base.perform_caching = caching
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;around&lt;/code&gt; block takes the RSpec example object as an argument. When running specs, the given block is triggered when &lt;code&gt;:caching&lt;/code&gt; is detected as a key in an example’s metadata. The example object provides a number of methods for test introspection, allowing us to make changes before and after calling run to execute the spec.&lt;/p&gt;

&lt;p&gt;As a result, we now have a simple, explicit mechanism for introducing caching to individual specs and suites:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/features/homepage_spec.rb
describe &amp;quot;visit the homepage&amp;quot;, :caching do
  it &amp;quot;expires cache&amp;quot; do
    # test cached stuff
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main concern with this approach is that modifying a global state can affect
other tests unintentionally - a big no-no.&lt;/p&gt;

&lt;p&gt;To avoid this, &lt;strong&gt;we need to reset the original value when the example completes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Here, we are storing the previously set value of &lt;code&gt;ActionContoller::Base.perform_caching&lt;/code&gt;, setting it for the local suite, and resetting it back to the original value after it completes.&lt;/p&gt;

&lt;p&gt;This technique may come into play when integrating with certain gems like
&lt;a href="https://github.com/airblade/paper_trail"&gt;PaperTrail&lt;/a&gt; which may generate expensive logic or queries not need in most
situations. PaperTrail even &lt;a href="https://github.com/airblade/paper_trail/blob/eef918bca42bab85c4467541037897f0788b6062/lib/paper_trail/frameworks/rspec.rb"&gt;provides a helper&lt;/a&gt; to take advantage of RSpec. It may be worth considering whether to provide an interface to toggle behavior and RSpec helpers next time we write a gem.
metadata to toggle behavior in specs.&lt;/p&gt;

&lt;h3&gt;Filtering Specs&lt;/h3&gt;

&lt;p&gt;One useful technique while developing is to run a selected set of specs. We may
be editing acceptances specs, model validations, and other disparate tests while test driving a
feature from &lt;a href="http://everydayrails.com/2014/01/15/outside-in-example-ruby-tapas.html"&gt;outside to in&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Manual tagging&lt;/h4&gt;

&lt;p&gt;Adding arbitrary metadata like &lt;code&gt;:focus&lt;/code&gt; to set of specs is one way to approach
this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# spec/models/user_spec.rb
it &amp;quot;validates a user&amp;quot;, :focus do
  # unit test
end

# spec/features/sign_up_spec.rb
it &amp;quot;displays error message&amp;quot;, :focus do
  # acceptance spec
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now filter our test run to a subset at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ rspec --tag focus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also add some global configuration so this will be the default behavior
when using &lt;code&gt;:focus&lt;/code&gt; specs, as long as we don&amp;rsquo;t make the mistake of filtering on the build server unintentionally.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rspec"&gt;RSpec.configure do |config|
  # enable auto-focus only when running locally
  config.filter_run_including focus: ENV[&amp;#39;CI_SERVER_SETTING&amp;#39;].blank?

  config.run_all_when_everything_filtered = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, avoid running broken or flaky specs when tagged accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;it &amp;quot;test that fails intermittently&amp;quot;, :flaky do
  # probably a javascript test
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using either a command line option&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;$ rspec --tag ~flaky
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or a configuration option, we can filter out specs we wish to ignore.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;RSpec.configure do |c|
  c.filter_run_excluding flaky: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Auto Tagging&lt;/h4&gt;

&lt;p&gt;A less-known feature of RSpec 3 is an API for telling RSpec to derive additional metadata
automatically based on &lt;em&gt;other&lt;/em&gt; metadata.&lt;/p&gt;

&lt;p&gt;For example, each spec example has metadata that includes its file path. This,
along with the &lt;code&gt;RSpec::Core::Configuration#define_derived_metadata&lt;/code&gt; method,
allows us to alter spec behavior based on the spec directories, for example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why is this useful and how do we use it?&lt;/em&gt; Glad you asked.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to isolate model specs that require database truncation since
they are more like functional specs than unit specs. We may set up our spec
directory like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spec/
  truncation/
    example1_spec.rb
    example2_spec.rb
    ...
  transaction/
    example1_spec.rb
    example2_spec.rb
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of manually tagging each file with our &lt;code&gt;:truncation_mode&lt;/code&gt; metadata we
used earlier to toggle DatabaseCleaner&amp;rsquo;s truncation strategy, we can configure
all the specs in &lt;code&gt;spec/truncation&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rspec"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.define_derived_metadata(file_path: %r{spec/truncation}) do |metadata|
    metadata[:truncation_mode] = true
  end

  # rest of DatabaseCleaner config below
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all specs in the directory will run with the &lt;code&gt;:truncation_mode&lt;/code&gt; metadata
and the database strategy will be set to &lt;code&gt;:truncation&lt;/code&gt; as long as it is declared ahead of the additional DatabaseCleaner configuration we referenced earlier.&lt;/p&gt;

&lt;p&gt;Note, this is the &lt;a href="https://github.com/rspec/rspec-rails/blob/a09a6231ceecefa177ec08b27c3066d5947e5899/lib/rspec/rails/configuration.rb#L85"&gt;same method&lt;/a&gt; used in &lt;code&gt;rspec-rails&lt;/code&gt; to add custom behavior to specs in the specific directories, e.g. &lt;code&gt;spec/controllers&amp;#39;,&lt;/code&gt;spec/requests, etc.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;The example above is borrowed from &lt;a href="http://stackoverflow.com/questions/29651981/before-and-after-hooks-for-a-spec-directory-in-rspec"&gt;an answer I recently gave on Stackoverflow&lt;/a&gt;.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Using and Abusing&lt;/h3&gt;

&lt;p&gt;While using RSpec metadata can be a powerful technique for altering test
behavior and application settings in specs, it can also be taken too far.&lt;/p&gt;

&lt;p&gt;As @avdgaag notes in &lt;a href="http://arjanvandergaag.nl/blog/using-abusing-rspec-metadata.html"&gt;his blog post on the topic&lt;/a&gt;, make sure to distinguish between &lt;em&gt;how&lt;/em&gt; spec is run from &lt;em&gt;what&lt;/em&gt; the spec should test. We should probably not use metadata to create records specific to certain tests or authenticate users for a given context, for example.&lt;/p&gt;

&lt;p&gt;One rule of thumb for adding metadata is decide whether it would be generally useful to any Rails app (good) or it is specific to the business logic of your current application (bad). The latter is best set up more explicitly within or alongside your tests.&lt;/p&gt;

&lt;p&gt;Before considering a new metadata tag, I ask the rubber duck &amp;ldquo;Could I extract
this configuration into a gem?&amp;rdquo; To answer yes, the behavior would have to be
non-specific to my application. If so, the behavior &lt;em&gt;might&lt;/em&gt; be useful as metadata.&lt;/p&gt;

&lt;p&gt;While metadata can nicely separate the boilerplate required to setup and teardown test behavior, it also adds a layer of indirection that can cause readability issues when stretched too far. Understand that there is a big increase in mental overhead to permuting test behavior with each new tag option and consider the tradeoffs with the rest of the team.&lt;/p&gt;

&lt;p&gt;Use wisely!&lt;/p&gt;
</content>
  </entry>
</feed>
