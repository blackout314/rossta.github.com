<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-01-26T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>How to write a simple web crawler in Ruby - revisited</title>
    <link rel="alternate" href="/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html"/>
    <id>/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html</id>
    <published>2016-01-26T19:00:00-05:00</published>
    <updated>2016-01-26T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo-f77303e5.jpg"&gt;&lt;/p&gt;

&lt;p&gt;Let’s build a simple web crawler in Ruby. For inspiration, I’d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin’s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We’ll adapt Skork’s original goals and...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo-f77303e5.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build a simple web crawler in Ruby. For inspiration, I&amp;rsquo;d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin&amp;rsquo;s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll adapt Skork&amp;rsquo;s original goals and provide a few of our own:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;must be able to crawl just a single domain&lt;/li&gt;
&lt;li&gt;must be able to limit number of pages to crawl&lt;/li&gt;
&lt;li&gt;the results should be represented as structured data so we don&amp;rsquo;t have an incomprehensible soup of content&lt;/li&gt;
&lt;li&gt;the results should be enumerable so we can have flexibility in how they&amp;rsquo;re handled&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  Caveats! Please keep in mind that there are, of course, &lt;a href="http://webscraper.io/"&gt;many&lt;/a&gt; &lt;a href="http://scrapy.org/"&gt;resources&lt;/a&gt; for
  using resilient, well-tested &lt;a href="https://www.import.io/"&gt;crawlers&lt;/a&gt; in a variety of languages. We have mere academic intentions
  here so we choose to ignore many important concerns, such as client-side rendering, parallelism, and handling failure, as a matter of convenience.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Breaking it down&lt;/h3&gt;

&lt;p&gt;For this exercise, we&amp;rsquo;re going to crawl &lt;a href="http://www.programmableweb.com/"&gt;Programmable Web&lt;/a&gt; to extract data from their &lt;a href="http://www.programmableweb.com/apis/directory"&gt;API directory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than take the naive approach of grabbing all content from any page, we&amp;rsquo;re going to build a webcrawler that emits
structured data. Traversing from the first page of the api directory, our
crawler will visit web pages like a nodes of a tree, collecting data and
additional urls along the way.&lt;/p&gt;

&lt;p&gt;Imagine that the results of our web crawl as a nested collection of
hashes with meaningful key-value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# results
[
  {
    name: &amp;quot;Google Maps&amp;quot;,
    api_provider: &amp;quot;https://google.com&amp;quot;
    api_homepage: &amp;quot;https://developers.google.com/maps/&amp;quot;
    categories: [&amp;quot;Mapping&amp;quot;, &amp;quot;Viewer&amp;quot;],
    provider_formats: [&amp;quot;JSON&amp;quot;, &amp;quot;KML&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
  {
    name: &amp;quot;Twitter&amp;quot;,
    api_provider: &amp;quot;https://twitter.com&amp;quot;
    api_homepage: &amp;quot;https://dev.twitter.com/rest/public&amp;quot;
    categories: [&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;],
    provider_formats: [&amp;quot;Atom&amp;quot;, &amp;quot;JSON&amp;quot;, &amp;quot;REST&amp;quot;, &amp;quot;RSS&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  When using a web crawler, be aware of the limitations described in the website&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard"&gt;robots.txt&lt;/a&gt; file. In this post, we skip automated parsing and detection of &lt;a href="http://www.programmableweb.com/robots.txt"&gt;Programmable Web&amp;rsquo;s robots.txt&lt;/a&gt; to filter out blacklisted urls and set a crawl delay dynamically. If you choose to run this code on your own, please crawl responsibly.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Designing the surface&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve been following my posts lately, you know that &lt;a href="https://rossta.net/blog/ruby-enumerable.html"&gt;I love Enumerable&lt;/a&gt; and you may not be surprised that I&amp;rsquo;d like to model our structured, website data with an &lt;a href="/blog/what-is-enumerator.html"&gt;Enumerator&lt;/a&gt;. This will provide a familiar, flexible interface that can be adapted for logging, storage, transformation, and a wide range of use cases.&lt;/p&gt;

&lt;p&gt;I want to simply ask a &lt;code&gt;spider&lt;/code&gt; object for its results and get back an enumerator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider.results
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll be able to do some interesting things, like stream the
results lazily into a flexible storage engine, e.g. &lt;a href="https://www.mongodb.org/"&gt;mongodb&lt;/a&gt; or &lt;code&gt;PStore&lt;/code&gt;,
available from the &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/pstore/rdoc/PStore.html"&gt;Ruby standard library&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;pstore&amp;quot;
store  = PStore.new(&amp;quot;api_directory.pstore&amp;quot;)

# create `spider`, then ...

spider.results.lazy.take(50).each_with_index do |result, i|
  store.transaction do
    store[result[:name]] = result
    store.commit
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Writing the crawler&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to write a &lt;code&gt;Spider&lt;/code&gt; class to enumerate website data. Our spider implementation borrows heavily from &lt;a href="https://github.com/joeyAghion/spidey"&gt;joeyAghion&amp;rsquo;s spidey&lt;/a&gt; gem, described as a &amp;ldquo;loose framework for crawling and scraping websites&amp;rdquo; and Python&amp;rsquo;s venerable &lt;a href="http://scrapy.org/"&gt;Scrapy&lt;/a&gt; project, which allows you to scrape websites &amp;ldquo;in a fast, simple, yet extensible way.&amp;rdquo; Both resources achieve the goals of being easy-to-use and extensible.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll build our web crawler piece-by-piece, but if you want a full preview of the source, check out it &lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider.rb"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; will maintain a set of urls to visit, data is collects, and a set of url &amp;ldquo;handlers&amp;rdquo; that will describe how each page should be processed. We&amp;rsquo;ll take advantage of one external dependency, &lt;code&gt;mechanize&lt;/code&gt;, to handle interaction with the pages we visit - to extract data, resolve urls, follow redirects, etc. Below is the &lt;code&gt;#enqueue&lt;/code&gt; method to add urls and their handlers to a running list in our spider.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;mechanize&amp;quot; # as of this writing, the latest release is 2.7.4

class Spider
  def enqueue(url, method)
    url = agent.resolve(url).to_s
    return if @handlers[url]
    @urls &amp;lt;&amp;lt; url
    @handlers[url] ||= { method: method, data: {} }
  end

  private

  def agent
    @agent ||= Mechanize.new
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we process each page we&amp;rsquo;ll need a way to record the structured data we extract from various pages. We&amp;rsquo;ll expose a &lt;code&gt;#record&lt;/code&gt; method append a hash of data to the &lt;code&gt;@results&lt;/code&gt; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def record(data = {})
    @results &amp;lt;&amp;lt; data
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our &lt;code&gt;Spider&lt;/code&gt; will only know how to enumerate urls and record data, we&amp;rsquo;ll introduce a collaborator object to contain the implementation for consuming data for a specific site. For now, we&amp;rsquo;ll call this object a &amp;ldquo;processor&amp;rdquo;. The processor will respond to the messages &lt;code&gt;#root&lt;/code&gt; and &lt;code&gt;#handler&lt;/code&gt; - the first url and handler method to enqueue for the spider, respectively. We&amp;rsquo;ll also provide options for enforcing limits on the number of pages to crawl and the delay between each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  REQUEST_INTERVAL = 5
  MAX_URLS = 1000

  def initialize(processor, attrs = {})
    @processor = processor

    @urls     = []
    @results  = []
    @handlers = {}

    @interval = attrs.fetch(:interval, REQUEST_INTERVAL)
    @max_urls = attrs.fetch(:max_urls, MAX_URLS)

    enqueue(processor.root, processor.handler)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Enumerator Two Ways&lt;/h3&gt;

&lt;p&gt;Now for the real meat of our young &lt;code&gt;Spider&lt;/code&gt;. The &lt;code&gt;#results&lt;/code&gt; method is the key public interface: it enumerates the enqueued urls and yields members of the &lt;code&gt;@results&lt;/code&gt; collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def results
    return enum_for(:results) unless block_given?

    index = @results.length
    enqueued_urls.each do |url, handler|

      # process url
      @processor.send(handler[:method], agent.get(url), handler[:data])

      if block_given? &amp;amp;&amp;amp; @results.length &amp;gt; index
        yield @results.last
        index += 1
      end

      # crawl delay
      sleep @interval if @interval &amp;gt; 0
    end
  end

  private

  def enqueued_urls
    Enumerator.new do |y|
      index = 0
      while index &amp;lt; @urls.count &amp;amp;&amp;amp; index &amp;lt;= @max_urls
        url = @urls[index]
        index += 1
        next unless url
        y.yield url, @handlers[url]
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting thing to note is that the size of our url queue and the collected results may be growing as we crawl more pages. For the &lt;code&gt;#enqueued_urls&lt;/code&gt; private method, we&amp;rsquo;re using an &lt;code&gt;Enumerator&lt;/code&gt; to wrap the logic for iterating over the list of &lt;code&gt;@urls&lt;/code&gt; and maintaining state, like the &lt;code&gt;index&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; class is well-suited to represent a lazily generated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def enqueued_urls
  Enumerator.new do |y|
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find it to be a more expressive way to indicate we&amp;rsquo;re enumerating values &amp;ldquo;on demand&amp;rdquo; as opposed to &amp;ldquo;eagerly&amp;rdquo;, like a typical collection.&lt;/p&gt;

&lt;p&gt;Notice we&amp;rsquo;re also returning an enumerator from &lt;code&gt;#results&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def results
  return enum_for(:results) unless block_given?
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique provides the method caller to more flexibility when determining
how to handler the results. While you could pass a block to consume the
results, e.g., &lt;code&gt;spider.results { |r| puts r.inspect }&lt;/code&gt;, this is an eager
operation. We&amp;rsquo;d have to wait for all the pages to be processed before continuing
with the block. Returning an enumerator offers the potential to stream results
to something like a data store.&lt;/p&gt;

&lt;p&gt;Why not include &lt;code&gt;Enumerable&lt;/code&gt; in our &lt;code&gt;Spider&lt;/code&gt; and implement &lt;code&gt;#each&lt;/code&gt; instead? As pointed out in &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Arkency&amp;rsquo;s Stop including Enumerable, return Enumerator
instead&lt;/a&gt;, our
&lt;code&gt;Spider&lt;/code&gt; class doesn&amp;rsquo;t itself represent a collection, so exposing the &lt;code&gt;#results&lt;/code&gt;
method as an enumerator is more appropriate.&lt;/p&gt;

&lt;h3&gt;From Soup to Net Results&lt;/h3&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; is now functional so we can move onto the details of extracting data from an actual website.&lt;/p&gt;

&lt;p&gt;Our processor, &lt;code&gt;ProgrammableWeb&lt;/code&gt; will be responsible for wrappin a &lt;code&gt;Spider&lt;/code&gt; instance and extracting data from
the pages it visits. As mentioned previously, our processor will need to
define a root url and initial handler method, for which defaults are provided, and delegate the &lt;code&gt;#results&lt;/code&gt; method to a &lt;code&gt;Spider&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProgrammableWeb
  attr_reader :root, :handler

  def initialize(root: &amp;quot;https://www.programmableweb.com/apis/directory&amp;quot;, handler: :process_index, **options)
    @root = root
    @handler = handler
    @options = options
  end

  def results(&amp;amp;block)
    spider.results(&amp;amp;block)
  end

  private

  def spider
    @spider ||= Spider.new(self, @options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ProgrammableWeb&lt;/code&gt; will define handler methods that deserialize a web page into additional urls and data to add to our collection of results.
Our spider will invoke the handlers (as seen above with &lt;code&gt;@processor.send(method, agent.get(url), data)&lt;/code&gt;). Each handler method will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def handler_method(page, data = {})
  # enqueue urls and/or record data
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; where &lt;code&gt;page&lt;/code&gt; is an instance of &lt;code&gt;Mechanize::Page&lt;/code&gt; (&lt;a href="http://docs.seattlerb.org/mechanize/Mechanize/Page.html"&gt;docs&lt;/a&gt;) providing a number of methods for interacting with html content:&lt;/p&gt;

&lt;p&gt;The root handler method, &lt;code&gt;ProgrammableWeb#process_index&lt;/code&gt;, will extract api names in the
index list, enqueue api detail pages and additional, paginated indexes. As data
is collected, it may be passed on to handlers further down the tree via
&lt;code&gt;Spider#enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_index(page, data = {})
  page.links_with(href: %r{\?page=\d+}).each do |link|
    spider.enqueue(link.href, :process_index)
  end

  page.links_with(href: %r{/api/\w+$}).each do |link|
    spider.enqueue(link.href, :process_api, name: link.text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process api detail pages, we&amp;rsquo;ll define a separate handler. Since these pages
will represent &amp;ldquo;leaves&amp;rdquo; in this exercise, we&amp;rsquo;ll merge the data passed in with
that extracted from the page and pass it along to &lt;code&gt;Spider#record&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_api(page, data = {})
  fields = page.search(&amp;quot;#tabs-content .field&amp;quot;).each_with_object({}) do |tag, o|
    key = tag.search(&amp;quot;label&amp;quot;).text.strip.downcase.gsub(%r{[^\w]+}, &amp;#39; &amp;#39;).gsub(%r{\s+}, &amp;quot;_&amp;quot;).to_sym
    val = tag.search(&amp;quot;span&amp;quot;).text
    o[key] = val
  end

  categories = page.search(&amp;quot;article.node-api .tags&amp;quot;).first.text.strip.split(/\s+/)

  spider.record data.merge(fields).merge(categories: categories)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw earlier, recorded data is emitted in the &lt;code&gt;Spider#results&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Now we can make use of our &lt;code&gt;ProgrammableWeb&lt;/code&gt; crawler as intended with simple
instantiation and the ability to enumerate results as a stream of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider = ProgrammableWeb.new

spider.results.lazy.take(5).each_with_index do |result, i|
  puts &amp;quot;%-3s: %s&amp;quot; % [i, result.inspect]
end

# 0 : {:name=&amp;gt;&amp;quot;Facebook&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://facebook.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.facebook.com/restserver.php&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.facebook.com/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Webhooks&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, REST&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;http://developers.facebook.com/documentation.php?doc=clients&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.developers.facebook.com/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/fbplatform&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://developers.facebook.com/group.php?gid=2205007948&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developers.facebook.com/tools/explorer&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;API Key, OAuth 2, Username/password&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Webhooks&amp;quot;]}
# 1 : {:name=&amp;gt;&amp;quot;LinkedIn&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.linkedin.com/&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.linkedin.com/v1/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developer.linkedin.com/docs&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Enterprise&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, JSONP, REST, XML&amp;quot;, :other_options=&amp;gt;&amp;quot;JavaScript&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_forum=&amp;gt;&amp;quot;https://developer.linkedin.com/forum&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/linkedindev&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developer.linkedinlabs.com/jsapi-console/#examples/login/simple.html&amp;amp;{&amp;amp;quot;framework&amp;amp;quot;:&amp;amp;quot;platform.linkedin.com/in.js&amp;amp;quot;,&amp;amp;quot;frameworkurl&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;apikey&amp;amp;quot;:&amp;amp;quo&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Enterprise&amp;quot;]}
# 2 : {:name=&amp;gt;&amp;quot;Skype&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_homepage=&amp;gt;&amp;quot;http://www.skype.com/en/developer/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Telephony&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Chat, Messaging, Video, Voice&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Unspecified&amp;quot;, :other_options=&amp;gt;&amp;quot;Skype proprietary&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;https://developer.skype.com/Docs/Web https://developer.skype.com/wiki/Java_API&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;Unspecified&amp;quot;, :categories=&amp;gt;[&amp;quot;Telephony&amp;quot;, &amp;quot;Chat,&amp;quot;, &amp;quot;Messaging,&amp;quot;, &amp;quot;Video,&amp;quot;, &amp;quot;Voice&amp;quot;]}
# 3 : {:name=&amp;gt;&amp;quot;Twitter&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://twitter.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://twitter.com/statuses/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://dev.twitter.com/rest/public&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Blogging&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, JSON, REST, RSS, XML&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/twitter-development-talk&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/twitterapi&amp;quot;, :contact_email=&amp;gt;&amp;quot;api@twitter.com&amp;quot;, :console_url=&amp;gt;&amp;quot;https://dev.twitter.com/console&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2, HTTP Basic Auth, OAuth&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;]}
# 4 : {:name=&amp;gt;&amp;quot;YouTube&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.google.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://gdata.youtube.com/feeds/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.google.com/youtube/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Video&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Media&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, RSS, JSON, XML, GData&amp;quot;, :other_options=&amp;gt;&amp;quot;Atom Publishing Protocol (Atom/RSS)&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;Java, PHP Python, Ruby, ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/youtube-api/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/YouTubeDev/&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://code.google.com/support/bin/topic.py?topic=12357&amp;quot;, :console_url=&amp;gt;&amp;quot;http://code.google.com/apis/ajax/playground/?exp=youtube#simple_embed&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth2&amp;quot;, :categories=&amp;gt;[&amp;quot;Video&amp;quot;, &amp;quot;Media&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;I admit, it&amp;rsquo;s arguable that this implementation is &amp;ldquo;simple&amp;rdquo;. Skorks provided a straightforward, recursive solution to consume unstructured content. Our approach is iterative and requires some work upfront to define which links to consume and how to process them with &amp;ldquo;handlers&amp;rdquo;. However, we were able to achieve an extensible, flexible tool with a nice separation of concerns and a familiar, enumerable interface.&lt;/p&gt;

&lt;p&gt;Modeling results from a multi-level page crawl as a collection may not work for every use case, but, for this exercise, it serves as a nice abstraction for collecting data. It would now be trivial to take our &lt;code&gt;Spider&lt;/code&gt; class and implement a new processor for a site like &lt;a href="https://rubygems.org"&gt;rubygems.org&lt;/a&gt; or &lt;a href="https://craigslist.org"&gt;craigslist&lt;/a&gt; and stream the results to a database like &lt;a href="http://redis.io"&gt;Redis&lt;/a&gt; or &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html"&gt;&lt;code&gt;YAML::Store&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Try it yourself and let me know what you think of this approach (&lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider.rb"&gt;full source&lt;/a&gt;).&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What's new in Ruby 2.3 Enumerable</title>
    <link rel="alternate" href="/blog/whats-new-in-ruby-2-3-enumerable.html"/>
    <id>/blog/whats-new-in-ruby-2-3-enumerable.html</id>
    <published>2016-01-17T19:00:00-05:00</published>
    <updated>2016-01-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo-a158f6e5.jpg"&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We’ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo-a158f6e5.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We&amp;rsquo;ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep allows you to select members of a collection that match an expression. That expression is &lt;code&gt;some_object === item&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What does &amp;ldquo;triple equals&amp;rdquo; do? Well, in Ruby, as in most languages, that answer is complicated. Since we can define this method however we want in our own classes, it can mean anything. But, most commonly, it is a loose way of asking whether an object belongs to a certain group:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;a&lt;/code&gt; === &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is a subset of &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Symbol === :foo     # =&amp;gt; true, :foo is a symbol
String === &amp;quot;foo&amp;quot;    # =&amp;gt; true, &amp;quot;foo&amp;quot; is a string
Symbol === &amp;quot;foo&amp;quot;    # =&amp;gt; false, &amp;quot;foo&amp;quot; is not a symbol
String === :foo     # =&amp;gt; false, :foo is not a string

/foo/ === &amp;quot;foobar&amp;quot;  # =&amp;gt; true, &amp;quot;foobar&amp;quot; matches /foo/
(1..10) === 2       # =&amp;gt; true, 2 is in the range 1..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; use &lt;code&gt;select&lt;/code&gt; to filter out items of a collection with the &lt;code&gt;===&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(20).select { |i| (6..10) === i } # =&amp;gt; [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is what &lt;code&gt;grep&lt;/code&gt; is for:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep(6..8) # =&amp;gt; [6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;grep&lt;/code&gt; is like saying &amp;ldquo;gimme all the items in the given set&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To get all the items &lt;em&gt;not&lt;/em&gt; included, use &lt;code&gt;grep_v&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep_v(6..8)
=&amp;gt; [1, 2, 3, 4, 5, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably most likely that you&amp;rsquo;d use &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; with a regular expression, like
to select all the months that end in &amp;ldquo;er&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MONTHS.grep(/er$/)
=&amp;gt; [&amp;quot;September&amp;quot;, &amp;quot;October&amp;quot;, &amp;quot;November&amp;quot;, &amp;quot;December&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define &lt;code&gt;===&lt;/code&gt; on any class or object to take advantage of filtering with &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; in other contexts.&lt;/p&gt;

&lt;h4&gt;Chunking&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Enumerable&lt;/code&gt; module provides several methods for enumerating adjacent
members of a collection, including &lt;code&gt;slice_when&lt;/code&gt;, &lt;code&gt;slice_before&lt;/code&gt;, &lt;code&gt;slice_after&lt;/code&gt;,
&lt;code&gt;each_cons&lt;/code&gt;, and, not surprisingly, &lt;code&gt;chunk&lt;/code&gt;. Ruby 2.3 offers yet another
chunking method, &lt;code&gt;chunk_while&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before diving into &lt;code&gt;chunk_while&lt;/code&gt;, let&amp;rsquo;s look at its relatives, &lt;code&gt;chunk&lt;/code&gt; and &lt;code&gt;slice_when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the following examples, we&amp;rsquo;ll enumerate over recurring events given by the
&lt;code&gt;Montrose&lt;/code&gt; gem. Montrose provides an api to create recurrences as enumerators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a recurrence that will enumerate over every other Tuesday at noon.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;montrose&amp;quot;

r = Montrose.every(2.weeks, on: :tuesday, at: &amp;#39;12pm&amp;#39;)

r.take(10).to_a
=&amp;gt; [2016-02-02 12:00:00 -0500,
 2016-02-16 12:00:00 -0500,
 2016-03-01 12:00:00 -0500,
 2016-03-15 12:00:00 -0400,
 2016-03-29 12:00:00 -0400,
 2016-04-12 12:00:00 -0400,
 2016-04-26 12:00:00 -0400,
 2016-05-10 12:00:00 -0400,
 2016-05-24 12:00:00 -0400,
 2016-06-07 12:00:00 -0400]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For calendaring, it may be useful to split this array into chunks by month.&lt;/p&gt;

&lt;p&gt;We could use &lt;code&gt;group_by&lt;/code&gt; to return a hash of month numbers to Tuesday time
instances:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month)
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;chunk&lt;/code&gt; method is similar to &lt;code&gt;group_by&lt;/code&gt; as it will divide the collection
into groups based on the given block/proc except it returns an enumerator
instead of a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month)
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I recently &lt;a href="/blog/what-is-enumerator.html"&gt;described some great things you can do with enumerators in Ruby&lt;/a&gt; including transforming the result of chunk into an array of month, time pairs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month).to_a
=&amp;gt; [[2, [2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500]],
 [3, [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400]],
 [4, [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400]],
 [5, [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400]],
 [6, [2016-06-07 12:00:00 -0400]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly enough, passing the previous result to &lt;code&gt;Hash[]&lt;/code&gt; returns the same
result we got with &lt;code&gt;group_by&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Hash[r.take(10).chunk(&amp;amp;:month).to_a]
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we just wanted the groups of times, not the month keys, we could ask for the
&lt;code&gt;group_by&lt;/code&gt; values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month).values
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can replace this computation with &lt;code&gt;slice_when&lt;/code&gt; which will allow us to compare
adjacent members to determine &amp;ldquo;when&amp;rdquo; to start a new slice (or chunk). That means
the block we pass to &lt;code&gt;slice_when&lt;/code&gt; accepts two arguments, the current and
previous collection member, and should return true or false. In this
case, we want a new slice to start when the month of the previous time does not
match the month of the current time as we enumerate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).slice_when { |a, b| a.month != b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the return value of &lt;code&gt;slice_when&lt;/code&gt; is an enumerator like we saw with &lt;code&gt;chunk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out, the most common use cases of &lt;code&gt;slice_when&lt;/code&gt; tend to be negative
comparisons, i.e., &amp;ldquo;slice when the previous thing is not the same as the current
thing&amp;rdquo;. Since this is Ruby after all, wouldn&amp;rsquo;t you prefer to stay positive?&lt;/p&gt;

&lt;p&gt;Which brings us to &lt;code&gt;chunk_while&lt;/code&gt;. Ruby 2.3 introduces this positive complement to
&lt;code&gt;slice_when&lt;/code&gt; so we can say, &amp;ldquo;keep the same chunk if the current thing &lt;em&gt;does&lt;/em&gt;
match the previous thing&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Back to our Tuesday recurrences. Let&amp;rsquo;s replace &lt;code&gt;slice_when&lt;/code&gt; with &lt;code&gt;chunk_while&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk_while { |a, b| a.month == b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in short, &lt;code&gt;Enumerable&lt;/code&gt; in Ruby 2.3 gives us both a negative and a positive variation, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt; respectively, on existing methods.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Looking for a way to handle recurring events in your app? Be sure to check out &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Debugging SystemStackError</title>
    <link rel="alternate" href="/blog/debugging-systemstackerror.html"/>
    <id>/blog/debugging-systemstackerror.html</id>
    <published>2016-01-11T19:00:00-05:00</published>
    <updated>2016-01-11T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo-e275cbe5.jpg"&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words,...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo-e275cbe5.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words, the memory allocated to execute the program exceeded the memory
available on the stack.&lt;/p&gt;

&lt;p&gt;The most common cause of a stack overflow in application code that
recursively calls itself without terminating arguments: an infinite loop in your
code.&lt;/p&gt;

&lt;p&gt;You can reproduce such an error with code like this in a terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ pry --noprompt
def foo
  foo
end
=&amp;gt; :foo
foo
SystemStackError: stack level too deep
from /Users/ross/.gem/ruby/2.1.6/gems/pry-0.10.3/lib/pry/pry_instance.rb:355
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: for the examples in this post, assume I&amp;rsquo;m using Ruby 2.1 unless otherwise
indicated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;$ ruby -v
ruby 2.1.6p336 (2015-04-13 revision 50298) [x86_64-darwin14.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prior to Ruby 2.2 and &lt;a href="https://bugs.ruby-lang.org/issues/6216"&gt;this issue&lt;/a&gt;, the
backtrace for &lt;code&gt;SystemStackError&lt;/code&gt; was reduced to one line. That meant, unless
that one line lead you to an obvious culprit in your source code, it
would be very difficult to unravel the method calls causing the stack to overflow.&lt;/p&gt;

&lt;p&gt;So, first step in debugging the &lt;code&gt;SystemStackError&lt;/code&gt; is upgrade to Ruby 2.2!&lt;/p&gt;

&lt;p&gt;In case that&amp;rsquo;s not possible, there&amp;rsquo;s still hope. Let&amp;rsquo;s try using information
from the error first. Here&amp;rsquo;s the method containing &lt;a href="https://github.com/rossta/montrose/blob/e5b7a12f6832b4f971a52b27800cefe144ecd399/lib/montrose/options.rb#L204"&gt;the line in the backtrace&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# lib/montrose/options.rb:204

def map_arg(arg, &amp;amp;block)
  return nil unless arg

  Array(arg).map(&amp;amp;block)    # line 204
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No obvious culprit. This method doesn&amp;rsquo;t call itself and there are multiple callers
of this method in this class.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try rescuing from the error in a test and printing the execution stack
using &lt;a href="http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-caller"&gt;&lt;code&gt;Kernel.caller&lt;/code&gt;&lt;/a&gt;. I can isolate the application code that produces the stack overflow in a single test and rescue there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;it &amp;quot;a test&amp;quot; do
  # given

  begin
    # when
  rescue SystemStackError
    puts caller
  end

  # then
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what I get:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bin/m spec/rfc_spec.rb:426
/Users/ross/dev/rossta/montrose/spec/rfc_spec.rb:434:in `block (2 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:108:in `block (3 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:205:in `capture_exceptions&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:105:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:256:in `time_it&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:104:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:276:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:103:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:781:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:308:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:296:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `each&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:321:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:294:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `block in __run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `map&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `__run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:129:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runners/minitest_5.rb:9:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/executor.rb:26:in `execute&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runner.rb:17:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m.rb:13:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/bin/m:4:in `&amp;lt;top (required)&amp;gt;&amp;#39;
bin/m:16:in `load&amp;#39;
bin/m:16:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backtrace points to lines in minitest. Since I&amp;rsquo;ve been running tests prior
to this isssue successfully, it&amp;rsquo;s unlikely minitest is the source of the stack overflow error. So rescuing from &lt;code&gt;SytemStackError&lt;/code&gt; doesn&amp;rsquo;t help us either.&lt;/p&gt;

&lt;p&gt;Luckily, we have &lt;a href="https://gist.github.com/jbgo/4493822"&gt;this gist&lt;/a&gt; from
&lt;a href="https://github.com/jbgo"&gt;@jbgo&lt;/a&gt; who highlighted a special feature in Ruby for
tracing function events: &lt;a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-set_trace_func"&gt;&lt;code&gt;Kernel.set_trace_func&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the example from the docs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Test
  def test
    a = 1
    b = 2
  end
end

set_trace_func proc { |event, file, line, id, binding, classname|
  printf &amp;quot;%8s %s:%-2d %10s %8s\n&amp;quot;, event, file, line, id, classname
}
t = Test.new
t.test

    line prog.rb:11               false
  c-call prog.rb:11        new    Class
  c-call prog.rb:11 initialize   Object
c-return prog.rb:11 initialize   Object
c-return prog.rb:11        new    Class
    line prog.rb:12               false
    call prog.rb:2        test     Test
    line prog.rb:3        test     Test
    line prog.rb:4        test     Test
  return prog.rb:4        test     Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method &lt;code&gt;set_trace_func&lt;/code&gt; sets a global proc to be invoked in response to
runtime events including the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c-call&lt;/code&gt; a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-return&lt;/code&gt; return from a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call&lt;/code&gt; a Ruby method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; start a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end&lt;/code&gt; finish a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt; execute code on a new line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raise&lt;/code&gt; raise an exception&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt; return from a Ruby method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we want to isolate the Ruby method causing the infinite loop in our stack,
we&amp;rsquo;ll log the line info for &lt;code&gt;call&lt;/code&gt; events:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb

$trace_out = open(&amp;quot;trace.txt&amp;quot;)

set_trace_func proc { |event, file, line, id, binding, classname|
  if event == &amp;#39;call&amp;#39;
    $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-running the test produces a &lt;code&gt;trace.txt&lt;/code&gt; file that records all the Ruby method
calls encountered during execution. Inspecting this log, we hope to find a
repeating pattern of an identical list of method calls.&lt;/p&gt;

&lt;p&gt;In my case, the start of each pattern pointed to another line in my source where
the stack originates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A useful trick is to keep the trace routine in a separate file that you can
incorporate with an environment variable. You can also leverage &lt;code&gt;Kernel.caller&lt;/code&gt;
here and only log when the stack exceeds an arbitrarily large size.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/support/trace.rb

if ENV[&amp;quot;TRACE&amp;quot;]
  $stack_size = ENV[&amp;quot;TRACE&amp;quot;].to_i
  $trace_out = open(&amp;quot;trace.txt&amp;quot;)

  set_trace_func proc { |event, file, line, id, binding, classname|
    if event == &amp;#39;call&amp;#39; &amp;amp;&amp;amp; caller.length &amp;gt; $stack_size
      $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
    end
  }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt; gem, &lt;a href="https://github.com/rossta/montrose/blob/9600e0b63bde342011b3b9b1e29ab9f76f5f69c3/spec/support/trace.rb"&gt;this file&lt;/a&gt; gets loaded during every test run but the &lt;code&gt;set_trace_func&lt;/code&gt; hook will
only be evaluated when the &lt;code&gt;TRACE&lt;/code&gt; environment variable is present:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ TRACE=500 bin/m spec/montrose/recurrence_spec.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, you won&amp;rsquo;t need to resort to this workaround for &lt;code&gt;SystemStackError&lt;/code&gt; in Ruby
2.2+, but keep this in mind next time you get stuck &amp;ldquo;in the loop&amp;rdquo;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using RSpec Metadata</title>
    <link rel="alternate" href="/blog/using-rspec-metadata.html"/>
    <id>/blog/using-rspec-metadata.html</id>
    <published>2015-12-28T19:00:00-05:00</published>
    <updated>2015-12-28T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Fall" src="/assets/images/blog/stock/fall-leaves-pexels-photo-3210b976.jpg"&gt;&lt;/p&gt;

&lt;p&gt;A useful feature of RSpec is the ability to pass metadata to tests and suites.&lt;/p&gt;

&lt;p&gt;You may already be familiar with how &lt;a href="https://github.com/jnicklas/capybara"&gt;Capybara&lt;/a&gt; uses the &lt;code&gt;:js&lt;/code&gt; option to enable the javascript driver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;describe "a javascript feature", :js do
  # tests run against the...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Fall" src="/assets/images/blog/stock/fall-leaves-pexels-photo-3210b976.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;A useful feature of RSpec is the ability to pass metadata to tests and suites.&lt;/p&gt;

&lt;p&gt;You may already be familiar with how &lt;a href="https://github.com/jnicklas/capybara"&gt;Capybara&lt;/a&gt; uses the &lt;code&gt;:js&lt;/code&gt; option to enable the javascript driver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;describe &amp;quot;a javascript feature&amp;quot;, :js do
  # tests run against the Capyabara.javascript_driver
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Capybara &lt;a href="https://github.com/jnicklas/capybara/blob/957c35f580b68e8a140b5bbe7818fdcf06bc4521/lib/capybara/rspec.rb#L27"&gt;provides an RSpec configuration hook&lt;/a&gt; that changes the web driver for any example where &lt;code&gt;:js&lt;/code&gt; metadata is present. Here it is, oversimplified:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# capybara/rspec.rb
RSpec.configure do |config|
  config.before do
    Capybara.current_driver = Capybara.javascript_driver if example.metadata[:js]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We may reach a point in the maturity of our test suite when it makes sense add our own configuration options.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
The examples in the post are based on RSpec version &lt;code&gt;~&gt; 3&lt;/code&gt;.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Changing Test Runner Behavior&lt;/h3&gt;

&lt;p&gt;Testing libraries like RSpec and Capybara do some heavy lifting to set up the
Rails environment and make it suitable for running in test mode. For performance
reasons, it may be beneficial to run each of our specs in a database
transaction so test data can be easily rolled back at the start of each spec.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a common base configuration for using the popular &lt;a href="https://github.com/DatabaseCleaner/database_cleaner"&gt;DatabaseCleaner&lt;/a&gt; gem to
set up transactional database behavior for RSpec:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not all specs can be run this way - once we add a javascript acceptance specs, for
example, the javascript driver will likely need its own connection to the
database so it won&amp;rsquo;t have access to data setup in the tests. We need to run
javascript acceptance specs in &lt;em&gt;truncation&lt;/em&gt; mode to ensure database changes are
committed to the database so multiple database connections will have access to the same data.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use RSpec metadata to toggle database behavior automatically when using
the javascript driver (i.e., not the default &lt;code&gt;:rack_test&lt;/code&gt; driver). We&amp;rsquo;ll add the
following hooks, borrowed from the DatabaseCleaner &lt;a href="https://github.com/DatabaseCleaner/database_cleaner/tree/f32abebc4f28faa6ff944c4d1d4fee3f21ceb0bb#rspec-example"&gt;README&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
config.before(:each, type: :feature) do
  # :rack_test driver&amp;#39;s Rack app under test shares database connection
  # with the specs, so continue to use transaction strategy for speed.
  driver_shares_db_connection_with_specs = Capybara.current_driver == :rack_test

  if !driver_shares_db_connection_with_specs
    # Driver is probably for an external browser with an app
    # under test that does *not* share a database connection with the
    # specs, so use truncation strategy.
    DatabaseCleaner.strategy = :truncation
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also run into problems with ActiveRecord &lt;code&gt;after_commit&lt;/code&gt; callbacks - when running
tests in transaction mode, these callbacks will never fire. We can also
add an option for enabling truncation mode outside of acceptance specs when
isolated specs are needed for these callbacks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/model/user_spec.rb
it &amp;quot;triggers background job after creating new user&amp;quot;, :truncation_mode do
  # test after_commit callback
end

# spec/spec_helper.rb
config.before(:each, :truncation_mode) do
  DatabaseCleaner.strategy = :truncation
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a consolidated configuration for providing hooks for the issues related
to database truncation mentioned above:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.use_transactional_fixtures = false

  config.before(:suite) do
    DatabaseCleaner.clean_with(:truncation)
  end

  config.before(:each) do
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each, type: :feature) do
    driver_shares_db_connection_with_specs = Capybara.current_driver == :rack_test

    if !driver_shares_db_connection_with_specs
      DatabaseCleaner.strategy = :truncation
    end
  end

  config.before(:each, :truncation_mode) do
    DatabaseCleaner.strategy = :truncation
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Changing Application Settings&lt;/h3&gt;

&lt;p&gt;Rails provides a number of settings that can be easily configured based on the
environment, so we avoid undesired work in development or test environments,
such as sending emails. For any mature Rails application, we&amp;rsquo;ll likely have
our own custom settings layered on top of the Rails defaults.&lt;/p&gt;

&lt;p&gt;There are many cases where we&amp;rsquo;ll still want to test the production settings in
our test environments.  For example, by default, controller caching is disabled in tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# config/initializers/test.rb
Rails.application.configure do
  # ...
  config.action_controller.perform_caching = false

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For selected acceptances specs, we may still want to test behavior of caching at
the view layer, say that users can see new info when a model attribute changes. We don&amp;rsquo;t need this caching behavior is all test, so it may be useful to toggle specs on/off during the test run.&lt;/p&gt;

&lt;h4&gt;First attempt&lt;/h4&gt;

&lt;p&gt;We could try to stub the setting in the context of a single spec run with the enabled state.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.before(:each, :caching) do
    allow_any_instance_of(ActionController::Base).to receive(:perform_caching).and_return true
  end

  config.after(:each, :caching) do
    Rails.cache.clear
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may require changing behavior of instances which is &lt;a href="https://relishapp.com/rspec/rspec-mocks/docs/working-with-legacy-code/any-instance"&gt;typically discouraged&lt;/a&gt;. We may also need to clean up other global state, like clearing the Rails cache after the test run.&lt;/p&gt;

&lt;h4&gt;Better attempt&lt;/h4&gt;

&lt;p&gt;Alternatively, we can set the actual values on while settings are derived.
Here&amp;rsquo;s how it might look for enabling controller caching with an &lt;code&gt;around&lt;/code&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.around(:each, :caching) do |example|
    caching = ActionController::Base.perform_caching
    ActionController::Base.perform_caching = example.metadata[:caching]

    example.run

    Rails.cache.clear
    ActionController::Base.perform_caching = caching
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;around&lt;/code&gt; block takes the RSpec example object as an argument. When running specs, the given block is triggered when &lt;code&gt;:caching&lt;/code&gt; is detected as a key in an example’s metadata. The example object provides a number of methods for test introspection, allowing us to make changes before and after calling run to execute the spec.&lt;/p&gt;

&lt;p&gt;As a result, we now have a simple, explicit mechanism for introducing caching to individual specs and suites:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/features/homepage_spec.rb
describe &amp;quot;visit the homepage&amp;quot;, :caching do
  it &amp;quot;expires cache&amp;quot; do
    # test cached stuff
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main concern with this approach is that modifying a global state can affect
other tests unintentionally - a big no-no.&lt;/p&gt;

&lt;p&gt;To avoid this, &lt;strong&gt;we need to reset the original value when the example completes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Here, we are storing the previously set value of &lt;code&gt;ActionContoller::Base.perform_caching&lt;/code&gt;, setting it for the local suite, and resetting it back to the original value after it completes.&lt;/p&gt;

&lt;p&gt;This technique may come into play when integrating with certain gems like
&lt;a href="https://github.com/airblade/paper_trail"&gt;PaperTrail&lt;/a&gt; which may generate expensive logic or queries not need in most
situations. PaperTrail even &lt;a href="https://github.com/airblade/paper_trail/blob/eef918bca42bab85c4467541037897f0788b6062/lib/paper_trail/frameworks/rspec.rb"&gt;provides a helper&lt;/a&gt; to take advantage of RSpec. It may be worth considering whether to provide an interface to toggle behavior and RSpec helpers next time we write a gem.
metadata to toggle behavior in specs.&lt;/p&gt;

&lt;h3&gt;Filtering Specs&lt;/h3&gt;

&lt;p&gt;One useful technique while developing is to run a selected set of specs. We may
be editing acceptances specs, model validations, and other disparate tests while test driving a
feature from &lt;a href="http://everydayrails.com/2014/01/15/outside-in-example-ruby-tapas.html"&gt;outside to in&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Manual tagging&lt;/h4&gt;

&lt;p&gt;Adding arbitrary metadata like &lt;code&gt;:focus&lt;/code&gt; to set of specs is one way to approach
this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# spec/models/user_spec.rb
it &amp;quot;validates a user&amp;quot;, :focus do
  # unit test
end

# spec/features/sign_up_spec.rb
it &amp;quot;displays error message&amp;quot;, :focus do
  # acceptance spec
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now filter our test run to a subset at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ rspec --tag focus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also add some global configuration so this will be the default behavior
when using &lt;code&gt;:focus&lt;/code&gt; specs, as long as we don&amp;rsquo;t make the mistake of filtering on the build server unintentionally.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rspec"&gt;RSpec.configure do |config|
  # enable auto-focus only when running locally
  config.filter_run_including focus: ENV[&amp;#39;CI_SERVER_SETTING&amp;#39;].blank?

  config.run_all_when_everything_filtered = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, avoid running broken or flaky specs when tagged accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;it &amp;quot;test that fails intermittently&amp;quot;, :flaky do
  # probably a javascript test
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using either a command line option&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;$ rspec --tag ~flaky
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or a configuration option, we can filter out specs we wish to ignore.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;RSpec.configure do |c|
  c.filter_run_excluding flaky: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Auto Tagging&lt;/h4&gt;

&lt;p&gt;A less-known feature of RSpec 3 is an API for telling RSpec to derive additional metadata
automatically based on &lt;em&gt;other&lt;/em&gt; metadata.&lt;/p&gt;

&lt;p&gt;For example, each spec example has metadata that includes its file path. This,
along with the &lt;code&gt;RSpec::Core::Configuration#define_derived_metadata&lt;/code&gt; method,
allows us to alter spec behavior based on the spec directories, for example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why is this useful and how do we use it?&lt;/em&gt; Glad you asked.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to isolate model specs that require database truncation since
they are more like functional specs than unit specs. We may set up our spec
directory like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spec/
  truncation/
    example1_spec.rb
    example2_spec.rb
    ...
  transaction/
    example1_spec.rb
    example2_spec.rb
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of manually tagging each file with our &lt;code&gt;:truncation_mode&lt;/code&gt; metadata we
used earlier to toggle DatabaseCleaner&amp;rsquo;s truncation strategy, we can configure
all the specs in &lt;code&gt;spec/truncation&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rspec"&gt;# spec/spec_helper.rb
RSpec.configure do |config|
  config.define_derived_metadata(file_path: %r{spec/truncation}) do |metadata|
    metadata[:truncation_mode] = true
  end

  # rest of DatabaseCleaner config below
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all specs in the directory will run with the &lt;code&gt;:truncation_mode&lt;/code&gt; metadata
and the database strategy will be set to &lt;code&gt;:truncation&lt;/code&gt; as long as it is declared ahead of the additional DatabaseCleaner configuration we referenced earlier.&lt;/p&gt;

&lt;p&gt;Note, this is the &lt;a href="https://github.com/rspec/rspec-rails/blob/a09a6231ceecefa177ec08b27c3066d5947e5899/lib/rspec/rails/configuration.rb#L85"&gt;same method&lt;/a&gt; used in &lt;code&gt;rspec-rails&lt;/code&gt; to add custom behavior to specs in the specific directories, e.g. &lt;code&gt;spec/controllers&amp;#39;,&lt;/code&gt;spec/requests, etc.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;The example above is borrowed from &lt;a href="http://stackoverflow.com/questions/29651981/before-and-after-hooks-for-a-spec-directory-in-rspec"&gt;an answer I recently gave on Stackoverflow&lt;/a&gt;.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Using and Abusing&lt;/h3&gt;

&lt;p&gt;While using RSpec metadata can be a powerful technique for altering test
behavior and application settings in specs, it can also be taken too far.&lt;/p&gt;

&lt;p&gt;As @avdgaag notes in &lt;a href="http://arjanvandergaag.nl/blog/using-abusing-rspec-metadata.html"&gt;his blog post on the topic&lt;/a&gt;, make sure to distinguish between &lt;em&gt;how&lt;/em&gt; spec is run from &lt;em&gt;what&lt;/em&gt; the spec should test. We should probably not use metadata to create records specific to certain tests or authenticate users for a given context, for example.&lt;/p&gt;

&lt;p&gt;One rule of thumb for adding metadata is decide whether it would be generally useful to any Rails app (good) or it is specific to the business logic of your current application (bad). The latter is best set up more explicitly within or alongside your tests.&lt;/p&gt;

&lt;p&gt;Before considering a new metadata tag, I ask the rubber duck &amp;ldquo;Could I extract
this configuration into a gem?&amp;rdquo; To answer yes, the behavior would have to be
non-specific to my application. If so, the behavior &lt;em&gt;might&lt;/em&gt; be useful as metadata.&lt;/p&gt;

&lt;p&gt;While metadata can nicely separate the boilerplate required to setup and teardown test behavior, it also adds a layer of indirection that can cause readability issues when stretched too far. Understand that there is a big increase in mental overhead to permuting test behavior with each new tag option and consider the tradeoffs with the rest of the team.&lt;/p&gt;

&lt;p&gt;Use wisely!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Handling Paginated Resources in Ruby</title>
    <link rel="alternate" href="/blog/paginated-resources-in-ruby.html"/>
    <id>/blog/paginated-resources-in-ruby.html</id>
    <published>2015-12-14T19:00:00-05:00</published>
    <updated>2015-12-14T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;The thing with paginated data is we can’t get it all at once.&lt;/p&gt;

&lt;p&gt;Let’s say we’re using the &lt;a href="https://developers.trello.com/"&gt;Trello API&lt;/a&gt;. There are a number of Trello endpoints that return paginated data sets, such as boards, lists,
cards, and actions (like comments, copies, moves, etc...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;The thing with paginated data is we can&amp;rsquo;t get it all at once.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re using the &lt;a href="https://developers.trello.com/"&gt;Trello API&lt;/a&gt;. There are a number of Trello endpoints that return paginated data sets, such as boards, lists,
cards, and actions (like comments, copies, moves, etc).&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re querying for Trello cards marked as completed each month since last January, for example, we may need to request several pages of &amp;ldquo;cards&amp;rdquo; &lt;img src="/assets/images/icons/noun_63447-2fa20b1a.png" class="icon-image inline" /&gt; &lt;img src="/assets/images/icons/noun_63453-5cc436ec.png" class="icon-image inline" /&gt;&lt;/p&gt;

&lt;p&gt;In most cases, Trello will provide a default limit, typically 50, on the number of resources returned in a single request. But what if you need more than that? In this post, we&amp;rsquo;ll examine a few ways to collect paginated results in Ruby.&lt;/p&gt;

&lt;h3&gt;Trello World&lt;/h3&gt;

&lt;p&gt;The &lt;a href="https://developers.trello.com/"&gt;Trello developer docs&lt;/a&gt; provide a quickstart in javascript - here&amp;rsquo;s the unofficial Ruby version.&lt;/p&gt;

&lt;p&gt;While logged into your Trello account (you&amp;rsquo;ll need one first), &lt;strong&gt;&lt;a href="https://trello.com/app-key"&gt;retrieve your app key&lt;/a&gt;&lt;/strong&gt;. We won&amp;rsquo;t need the &amp;ldquo;secret&amp;rdquo; for this article.&lt;/p&gt;

&lt;p&gt;Next, you&amp;rsquo;ll generate an &lt;strong&gt;app token&lt;/strong&gt;. Paste the following URL into your browser with your app &lt;strong&gt;key&lt;/strong&gt; subsituted for the placeholder.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;https://trello.com/1/authorize?expiration=never&amp;amp;scope=read,write,account&amp;amp;response_type=token&amp;amp;name=Trello%20World&amp;amp;key=YOUR_KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have an app key and token, we can make authenticated requests to the Trello API. As a quick test, paste the following url  with your own key and token as pararameters into your web browser (or use &lt;code&gt;curl&lt;/code&gt;) to read your member data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;https://api.trello.com/1/members/me?key=YOUR_KEY&amp;amp;token=YOUR_TOKEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see a JSON response with attributes like your Trello id, username, bio, etc.&lt;/p&gt;

&lt;h3&gt;Script mode&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s fetch some paginated data in Ruby. For the following examples, we&amp;rsquo;ll be using Ruby 2.2.&lt;/p&gt;

&lt;aside class="callout panel"&gt;&lt;p&gt;

For academic reasons, we&amp;rsquo;re ignoring available Ruby clients for the Trello API like &lt;strong&gt;&lt;a href="https://github.com/jeremytregunna/ruby-trello"&gt;ruby-trello&lt;/a&gt;&lt;/strong&gt;, a popular library which aims to provide some ActiveRecord-like abstractions over Trello resources, and &lt;strong&gt;&lt;a href="https://github.com/rossta/tacokit.rb"&gt;tacokit.rb&lt;/a&gt;&lt;/strong&gt;, a client with different design goals including simplicity and flexibility, inspired by the ideas presented in this post and the GitHub API Ruby wrapper, &lt;a href="https://github.com/octokit/octokit.rb"&gt;octokit.rb&lt;/a&gt;, in aiming to be a &amp;ldquo;flat API client&amp;hellip; that requires little knowledge of REST&amp;rdquo;.

&lt;/p&gt;&lt;/aside&gt;

&lt;p&gt;To make HTTP requests, we&amp;rsquo;ll also use the &lt;a href="https://github.com/httprb/http"&gt;http.rb&lt;/a&gt;, but feel free to subsitute with your HTTP client of choice. Install the gem yourself with &lt;code&gt;gem install http&lt;/code&gt; or add it to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Gemfile

gem &amp;quot;http&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make things easier for the remainder, add the key and token as environment variables in your shell. For Mac/Linux users, something like this will work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;# command line
export TRELLO_APP_KEY=your-key
export TRELLO_APP_TOKEN=your-token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s run Ruby version of our Trello World test.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_eager.rb
require &amp;quot;http&amp;quot;

def app_key
  ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;)
end

def app_token
  ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;)
end

url = &amp;quot;https://api.trello.com/1/members/me?key=#{app_key}&amp;amp;token=#{app_token}&amp;quot;
puts HTTP.get(url).parse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it worked correctly, you should see the same result we saw in your browser earlier.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s extract a few helpers to build the url. We&amp;rsquo;ll use &lt;code&gt;Addressable::URI&lt;/code&gt;, which is available as a dependency of the http.rb gem as of version &lt;code&gt;1.0.0.pre1&lt;/code&gt; or otherwise may be installed as &lt;code&gt;gem install addressable&lt;/code&gt; or &lt;code&gt;gem &amp;quot;addressable&amp;quot;&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;http&amp;quot;
require &amp;quot;addressable/uri&amp;quot;

def app_key
  ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;)
end

def app_token
  ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;)
end

def trello_url(path, params = {})
  auth_params = { key: app_key, token: app_token }

  Addressable::URI.new({
    scheme: &amp;quot;https&amp;quot;,
    host: &amp;quot;api.trello.com&amp;quot;,
    path: File.join(&amp;quot;1&amp;quot;, path),
    query_values: auth_params.merge(params)
  })
end

def get(path)
  HTTP.get(trello_url(path)).parse
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Let&amp;rsquo;s Paginate&lt;/h3&gt;

&lt;p&gt;Now we&amp;rsquo;ll add an alternative method to &lt;code&gt;#get&lt;/code&gt; that can handle pagination.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MAX = 1000

def paginated_get(path, options = {})
  params  = options.dup
  page    = params.delete(:page) { 1 }
  limit   = params.fetch(:limit) { 50 }
  results = []

  loop do
    data = get(path, { page: page }.merge(params))

    page += 1
    results += data

    break if (data.empty? || page * limit &amp;gt;= MAX)
  end

  results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given a path and hash of parameter options, we&amp;rsquo;ll build up an array of results by fetching the endpoint and incrementing the page number each time. Once either the max is reached or no more results are returned from the API, we&amp;rsquo;ll exit the loop.&lt;/p&gt;

&lt;p&gt;As a starting point, this works nicely. We can simply use &lt;code&gt;paginated_get&lt;/code&gt; to collect up to 1000 results for a given resource without the caller caring about pages. Here&amp;rsquo;s how we can grab the all the comments we&amp;rsquo;ve added to Trello cards:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def comments(params = {})
  paginated_get(&amp;quot;members/me/actions&amp;quot;, filter: &amp;quot;commentCard&amp;quot;)
end

comments
#=&amp;gt; [{&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;abcd&amp;quot;, &amp;quot;idMemberCreator&amp;quot;=&amp;gt;&amp;quot;wxyz&amp;quot;, &amp;quot;data&amp;quot;=&amp;gt; {...} ...}, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main problem with this approach is that it forces the results to be eager loaded. Unless a max is specified in the method call, we could be waiting for up to 1000 comments to load - 20 requests of 50 comments each - to execute before the results are returned.&lt;/p&gt;

&lt;h3&gt;Stop, enumerate, and listen&lt;/h3&gt;

&lt;p&gt;Next step is to refactor our &lt;code&gt;paginated_get&lt;/code&gt; method to take advantage of Ruby&amp;rsquo;s &lt;code&gt;Enumerator&lt;/code&gt;. I previously &lt;a href="/blog/what-is-enumerator.html"&gt;described Enumerator&lt;/a&gt; and showed how it can be used to &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;generate infinite sequences in Ruby&lt;/a&gt;, including &lt;a href="/blog/pascals-triangle-with-rubys-enumerator.html"&gt;Pascal&amp;rsquo;s Triangle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main advantage of using &lt;code&gt;Enumerator&lt;/code&gt; will be to give callers flexibility to work with the results including filtering, searching, and lazy enumeration.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_enumerator.rb

def paginated_get(path, options = {})
  Enumerator.new do |y|
    params  = options.dup
    page    = params.delete(:page) { 1 }
    limit   = params.fetch(:limit) { 50 }

    loop do
      data = get(path, { page: page }.merge(params))

      data.each do |element|
        y.yield element
      end

      break if (data.empty? || page * limit &amp;gt;= MAX)

      page += 1
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve got a few similarities with our first implementation. We still loop over repeated requests for successive pages until either the max is reach or no data is returned from the API. There are a few big differences though.&lt;/p&gt;

&lt;p&gt;First, you&amp;rsquo;ll notice we&amp;rsquo;ve wrapped our expression in &lt;code&gt;Enumerator&lt;/code&gt; which will serve as the return value for &lt;code&gt;#paginated_get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using an enumerator may look strange but it offers a huge advantage over our first iteration. Enumerators allow callers to interact with data &lt;strong&gt;as it is generated&lt;/strong&gt;. Conceptually, the enumerator represents the algorithm for retrieving or generating data in &lt;code&gt;Enumerable&lt;/code&gt; form.&lt;/p&gt;

&lt;p&gt;An enumerator implements the &lt;code&gt;Enumerable&lt;/code&gt; module which means we can call familiar methods like &lt;code&gt;#map&lt;/code&gt;, &lt;code&gt;#select&lt;/code&gt;, &lt;code&gt;#take&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;Instead of building up an internal array of results, enumerators provide a mechanism for yielding each element even though a block may not be given to the method (how mind blowing is that?).&lt;/p&gt;

&lt;p&gt;Now we can use enumerator chains to doing something like the following, where we request comment data lazily, transform the API hash to comment text and select the first two addressed to a colleague.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;comments.lazy.
  map { |a| a[&amp;quot;data&amp;quot;][&amp;quot;text&amp;quot;] }.
  select { |t| t.start_with?(&amp;quot;@personIWorkWith&amp;quot;) }.
  take(2).force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We may not need to load all 1000 results to because the enumerators chain is evaluated for each item as it is yielded. This technique provides the caller with a great deal of flexibility. Eager loading can be delayed or avoided altogther - a potential performance gain.&lt;/p&gt;

&lt;p&gt;Here are magic lines from &lt;code&gt;#paginated_get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;data.each do |element|
  y.yield element
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;y.yield&lt;/code&gt; is not the keyword &lt;code&gt;yield&lt;/code&gt;, but the invokation of the &lt;code&gt;#yield&lt;/code&gt; method of &lt;code&gt;Enumerator::Yielder&lt;/code&gt;, an object the enumerator uses internally to pass values through to the first block used in the enumerator chain. For a more detailed look at how enumerators work under the hood, read more about how &lt;a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy"&gt;Ruby works hard so you can be lazy&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;A cursor-y example&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s do one more iteration on our &lt;code&gt;#paginated_get&lt;/code&gt; refactoring. Up to this point, we&amp;rsquo;ve been using a &amp;ldquo;functional&amp;rdquo; approach; we&amp;rsquo;ve just been using a bunch of methods defined in the outermost lexical scope.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll extract a &lt;code&gt;Client&lt;/code&gt; responsible for sending requests to the Trello API and parsing the responses as JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_client.rb

require &amp;quot;http&amp;quot;
require &amp;quot;addressable/uri&amp;quot;

class Client
  def initialize(opts = {})
    @app_key   = opts.fetch(:app_key, ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;))
    @app_token = opts.fetch(:app_token, ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;))
  end

  def get(path, params = {})
    HTTP.get(trello_url(path, params)).parse
  end

  private

  def trello_url(path, params = {})
    auth_params = { key: @app_key, token: @app_token }

    Addressable::URI.new({
      scheme: &amp;quot;https&amp;quot;,
      host: &amp;quot;api.trello.com&amp;quot;,
      path: File.join(&amp;quot;1&amp;quot;, path),
      query_values: auth_params.merge(params)
    })
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we&amp;rsquo;ll provide a class to represent the paginated collection of results to replace our implementation of &lt;code&gt;#paginated_get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The Twitter API uses &lt;a href="https://dev.twitter.com/overview/api/cursoring"&gt;cursors&lt;/a&gt; to navigate through pages, a concept similar to &amp;ldquo;next&amp;rdquo; and &amp;ldquo;previous&amp;rdquo; links on websites. Although Trello doesn&amp;rsquo;t provide explicit cursors in their API, we can still wrap the paginated results in an enumerable class to get similar behavior.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_cursor.rb
require_relative &amp;quot;./trello_client&amp;quot;

class Cursor
  def initialize(path, options = {})
    @path       = path
    @params     = options.dup

    @collection = []
    @page       = params.fetch(:page, 1)
    @limit      = params.fetch(:limit, 50)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Cursor&lt;/code&gt; will be initialized with a path and params, like our &lt;code&gt;paginated_get&lt;/code&gt;. We&amp;rsquo;ll also maintain an internal &lt;code&gt;@collection&lt;/code&gt; array to cache elements as they are returned from Trello.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Cursor
  private

  def client
    @client ||= Client.new
  end

  def fetch_next_page
    response              = client.get(@path, @params.merge(page: @page))
    @last_response_empty  = response.empty?
    @collection          += response
    @page                += 1
  end

  MAX = 1000

  def last?
    @last_response_empty || @page * @limit &amp;gt;= MAX
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll introduce a dependency on the &lt;code&gt;Client&lt;/code&gt; to interface with Trello through the private client method. We&amp;rsquo;ll use our client to fetch the next page, append the latest results to our cached &lt;code&gt;@collection&lt;/code&gt; and increment the page number. Now for the key public method:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Cursor
  include Enumerable

  def each(start = 0)
    return to_enum(:each, start) unless block_given?

    Array(@collection[start..-1]).each do |element|
      yield(element)
    end

    unless last?
      start = [@collection.size, start].max

      fetch_next_page

      each(start, &amp;amp;Proc.new)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve chosen to have our &lt;code&gt;Cursor&lt;/code&gt; expose the Enumerable API by including the &lt;code&gt;Enumerable&lt;/code&gt; module and implementing &lt;code&gt;#each&lt;/code&gt;. This will give cursor instances enumerable behavior so we can simply replace our paginated_get definition to return a new &lt;code&gt;Cursor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def paginated_get(path, params)
  Cursor.new(path, param)
end

def comments(params = {})
  paginated_get(&amp;quot;members/me/actions&amp;quot;, filter: &amp;quot;commentCard&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break down &lt;code&gt;Cursor#each&lt;/code&gt; a bit further. The first line allows us retain the &lt;code&gt;Enumerator&lt;/code&gt; behavior before.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;return to_enum(:each, start) unless block_given?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It invokes &lt;code&gt;Kernel#to_enum&lt;/code&gt; when no block is given to an &lt;code&gt;each&lt;/code&gt; method call. In this case, the method returns an &lt;code&gt;Enumerator&lt;/code&gt; that packages the behavior of &lt;code&gt;#each&lt;/code&gt; for an enumerator chain similar to before:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;puts comments.each.lazy.
  map { |axn| axn[&amp;quot;data&amp;quot;][&amp;quot;text&amp;quot;] }.
  select { |txt| txt.start_with?(&amp;quot;@mgerrior&amp;quot;) }.
  take(2).force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more info on using &lt;code&gt;#to_enum&lt;/code&gt;, check out Arkency&amp;rsquo;s &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Stop including Enumerable, use Enumerable instead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We also need to &lt;code&gt;yield&lt;/code&gt; each element in the &lt;code&gt;@collection&lt;/code&gt; to pass elements to callers of &lt;code&gt;#each&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Array(@collection[start..-1]).each do |element|
  yield(element)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We iterate from the start of the collection to the end with &lt;code&gt;Array(@collection[start..-1]).each&lt;/code&gt;&amp;hellip; but wait! when we start iterating, the &lt;code&gt;@collection&lt;/code&gt; is empty:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def initialize
  # ...
  @collection = []
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat?&lt;/p&gt;

&lt;p&gt;The key comes in the lines that follow in &lt;code&gt;#each&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;unless last?
  start = [@collection.size, start].max

  fetch_next_page

  each(start, &amp;amp;Proc.new)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless we&amp;rsquo;ve encountered the last page, we fetch the next page, which appends the latest results to the collection and we recursively invoke &lt;code&gt;#each&lt;/code&gt; with a starting point. This means &lt;code&gt;#each&lt;/code&gt; will be invoked again with new results until no new data is encountered. Sweet!&lt;/p&gt;

&lt;p&gt;A neat trick is how we forward the block given to &lt;code&gt;#each&lt;/code&gt;. When we &lt;code&gt;Proc.new&lt;/code&gt; without explicitly passing a block or proc object, it will instantiate with the block given to its surrounding method if there is one. The behavior is similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def each(start = 0, &amp;amp;block)
  # ...
  each(start, &amp;amp;block)
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main benefit being we don&amp;rsquo;t needlessly invoke &lt;code&gt;Proc.new&lt;/code&gt; by omitting &lt;code&gt;&amp;amp;block&lt;/code&gt; in the arguments. For more on this, read up on &lt;a href="http://mudge.name/2011/01/26/passing-blocks-in-ruby-without-block.html"&gt;Passing Blocks in Ruby without &amp;amp;block&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Recursive each&amp;rdquo; is a powerful technique for providing a seamless, enumerable interface to paginated or cursored results. I first encountered &lt;a href="https://github.com/sferik/twitter/blob/c6c2fe44e4a56c3e3544a3c08492a8b83b549635/lib/twitter/enumerable.rb"&gt;this approach&lt;/a&gt; in the &lt;a href="https://github.com/sferik"&gt;sferik&amp;rsquo;s&lt;/a&gt; &lt;a href="https://github.com/sferik/twitter"&gt;Twitter gem&lt;/a&gt; - a great resource for those considering writing an API wrapper in Ruby.&lt;/p&gt;

&lt;h3&gt;On your own&lt;/h3&gt;

&lt;p&gt;Give it a shot! Pick out an API you like to use and play with techniques for modeling its collection resources. This is a great way to get more experience with Ruby&amp;rsquo;s &lt;a href="/blog/series/enumerable.html"&gt;Enumerable&lt;/a&gt;. Consider one of these approaches when you need to traverse paginated or partitioned subsets of data in an external or internal API.&lt;/p&gt;

&lt;p&gt;Think less about &lt;strong&gt;pages&lt;/strong&gt; and more about &lt;strong&gt;data&lt;/strong&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;Credits&lt;/h3&gt;

&lt;p&gt;Icons via the &lt;a href="https://thenounproject.com/"&gt;Noun Project&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://thenounproject.com/pixelbazaar/"&gt;Arrows by Zlatko Najdenovski&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Use inverse_of</title>
    <link rel="alternate" href="/blog/use-inverse_of.html"/>
    <id>/blog/use-inverse_of.html</id>
    <published>2015-12-01T19:00:00-05:00</published>
    <updated>2015-12-01T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is to set the &amp;ldquo;inverse of&amp;rdquo; your current relation.&lt;/p&gt;

&lt;p&gt;This option name can be a little confusing at first so let&amp;rsquo;s use an example. Let&amp;rsquo;s say we have an
&lt;code&gt;Author&lt;/code&gt; class and it &lt;code&gt;has_many :posts&lt;/code&gt;. This means we should have a &lt;code&gt;Post&lt;/code&gt; class that maintains a
column, &lt;code&gt;:author_id&lt;/code&gt;, so it we can say it &lt;code&gt;belongs_to :author&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so we know this means if we have an author, we can ask for her posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Loading development environment (Rails 4.2.5)
author = Author.find(1)
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;

author.posts
#  Post Load (0.4ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [#&amp;lt;Post:0x007fde810cb4a0 id: 1, ... &amp;gt;, #&amp;lt;Post:0x007fde810cb248 id: 2, ... &amp;gt;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also query for a post and ask for its author.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;post = Post.find(1)
#  Post Load (0.3ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Post:0x007fde81c7d730 id: 1, ... &amp;gt;

post.author
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde7a5c8518 id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;What It&amp;rsquo;s For&lt;/h3&gt;

&lt;p&gt;Now, for most of our associations, Rails helps us find the &lt;strong&gt;inverse&lt;/strong&gt; relation. For example, if we
start with an author, then ask for her posts, each post will &amp;ldquo;know&amp;rdquo; that the inverse instance of this
relationship is the author. If we iterate over each of &lt;code&gt;author.posts&lt;/code&gt; and ask each post for its
author, we expect to get the same author record:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.posts.map { |post| post.author }
# =&amp;gt; [#&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For consistency, we want each post&amp;rsquo;s author not only to be the same record, but the same
&lt;strong&gt;instance&lt;/strong&gt; in memory. If I modify one author&amp;rsquo;s attributes, I expect that change to be reflected no
matter with inverse I&amp;rsquo;m working with. Let&amp;rsquo;s confirm by inspecting the &lt;code&gt;:object_id&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.object_id
# =&amp;gt; 70296816370740

object_ids = [author.object_id] + author.posts.map { |post| post.author.object_id }
# =&amp;gt; [70296816370740, 70296816370740, 70296816370740, ... ]

object_ids.uniq.size == 1
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!, This means we can say that, for the &lt;code&gt;Author&lt;/code&gt; class, &lt;code&gt;:author&lt;/code&gt; is the &amp;ldquo;inverse of&amp;rdquo; the
&lt;code&gt;has_many :posts&lt;/code&gt; association. So we could add the &lt;code&gt;:inverse_of&lt;/code&gt; option to specify the name of the
inverse association to ensure our object instances match up.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts, inverse_of: :author
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :post
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this example, providing this option will not change the behavior because Rails is already
setting the correct inverse instances as we might expect.&lt;/p&gt;

&lt;p&gt;It may seem obvious, but Rails has to do some work to set the inverse instance on records in an association and must infer the object based on the class name and association name.&lt;/p&gt;

&lt;p&gt;So it should &lt;strong&gt;just work™&lt;/strong&gt;!&lt;/p&gt;

&lt;h3&gt;It Doesn&amp;rsquo;t Always Work&lt;/h3&gt;

&lt;p&gt;I noticed something odd the other day.&lt;/p&gt;

&lt;p&gt;I was reviewing code for our Rails app which introduced abstraction to render a list of items given by a &lt;code&gt;has_many&lt;/code&gt; association. The code was passing around the inverse instance (the original owner of the association) all over the place.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t we expect the inverse to be available on our &lt;code&gt;has_many&lt;/code&gt; items?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an oversimplified example of what we were dealing with. Building on our &lt;code&gt;Author&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt; from earlier, we&amp;rsquo;ll add a &lt;code&gt;Tweet&lt;/code&gt; class. Using ActiveRecord&amp;rsquo;s single-table inheritance mechanism, &lt;code&gt;Tweet&lt;/code&gt; inherits functionality from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
  has_many :tweets, class_name: &amp;#39;Tweet&amp;#39;
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end

# app/models/tweet.rb
class Tweet &amp;lt; Post
  validates :text, length: { maximum: 140 }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Author&lt;/code&gt; class &lt;code&gt;has_many :tweets&lt;/code&gt; and each tweet has an author since it inherits its associations from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet = Tweet.last
#=&amp;gt; #&amp;lt;Tweet:0x007fc24c1dadd8 id: 10, ... &amp;gt;

tweet.author
#=&amp;gt; #&amp;lt;Author:0x007fc248e11998# id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code was rendering each tweet in a list and each tweet needed to refer back to the author for additional data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It seemed odd to pass the author author around.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;tweet&lt;/code&gt; defines its &lt;code&gt;author&lt;/code&gt; association since it inherits from &lt;code&gt;Post&lt;/code&gt;. I knew my colleague would have had a good reason for passing the &lt;code&gt;author&lt;/code&gt; instance along so I opened up a &lt;code&gt;rails console&lt;/code&gt; to find out what happened if I used the inverse association instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# ...
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot of database queries for one author!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s the classic problem with &lt;code&gt;has_many&lt;/code&gt; associations: the &amp;ldquo;N+1&amp;rdquo; query. After the initial &lt;code&gt;author.tweet&lt;/code&gt; query, &amp;ldquo;N&amp;rdquo; additional queries are needed to call each &lt;code&gt;tweet.author&lt;/code&gt; back through the &lt;code&gt;belongs_to&lt;/code&gt; association. We were avoiding the extra lookups by passing around the original author instance.&lt;/p&gt;

&lt;p&gt;This is unfortunate because we, as we have seen, it should be possible to avoid these extra queries so that each tweet&amp;rsquo;s author points to the same author object in memory.&lt;/p&gt;

&lt;p&gt;Not only do we want to avoid the extra queries, but if modifications are made in one place, we&amp;rsquo;d like them to be reflected elsewhere. I want to avoid something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet_1 = author.tweets.first
tweet_2 = author.tweets.second

tweet_1.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;

tweet_1.author.name = &amp;quot;Martha&amp;quot;

tweet_1.author.name # =&amp;gt; &amp;quot;Martha&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So passing the &lt;code&gt;author&lt;/code&gt; instance variable into the block, as an additional argument to method calls, or down to a view template is one workaround. But this can be difficult to maintain, especially if we&amp;rsquo;re dealing with more than one author&amp;rsquo;s posts. Wouldn&amp;rsquo;t it be better not to make those unnecessary queries?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s possible! &lt;code&gt;:inverse_of&lt;/code&gt; to the rescue.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Author &amp;lt; ActiveRecord::Base
  has_many :tweets, inverse_of: :author
end

class Tweet &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :tweets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when iterate over the tweets and reference the author, &lt;strong&gt;no additional queries
are needed&lt;/strong&gt; because each tweet can now assign its author association from the
instance that exists already in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24c65c028 ... &amp;gt;
author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
=&amp;gt; [&amp;quot;vicenta&amp;quot;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that additional queries for the author (&lt;code&gt;Author Load...&lt;/code&gt;) don&amp;rsquo;t appear in the query log: no more &amp;ldquo;N+1&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;You might be asking&amp;hellip; why doesn&amp;rsquo;t Rails just do this by default all the time? That&amp;rsquo;s a good question. Turns out, it&amp;rsquo;s not so easy. The &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Rails guides&lt;/a&gt; say:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every association will attempt to automatically find the inverse association and set the &lt;code&gt;:inverse_of&lt;/code&gt; option heuristically (based on the association name). Most associations with standard names will be supported.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So Rails will &amp;ldquo;try hard&amp;rdquo; to make the inverse association work automatically to prevent the extra queries. If no name is found with the &lt;code&gt;:inverse_of&lt;/code&gt; key in the association options, ActiveRecord will try to find the inverse association automatically inferring the class name from the association name, i.e. as &lt;code&gt;Post&lt;/code&gt; is implied by &lt;code&gt;has_many :posts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To summarize, when the name of the association and the name of the class Rails expects to find in the
association don&amp;rsquo;t match, or other certain other options are uses, automatic inverse lookup won&amp;rsquo;t happen. Then you may see extra
queries for objects that already exist in memory.&lt;/p&gt;

&lt;h3&gt;Avoid Uncertainty, Be Explicit&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s my recommendation:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set the &lt;code&gt;:inverse_of&lt;/code&gt; option wherever you can.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yeah, Rails will try hard to do automatic inverses on your behalf, but &lt;strong&gt;leaving it up to Rails adds uncertainty&lt;/strong&gt;. The uncertainty makes me uncomfortable.&lt;/p&gt;

&lt;p&gt;Also know that &lt;strong&gt;other ActiveRecord options can interfere with automatic inverses&lt;/strong&gt;: for example, using &lt;code&gt;:foreign_key&lt;/code&gt; in your association will make it impossible to guess the inverse. In these cases, if you expect to have inverses set properly, using &lt;code&gt;:inverse_of&lt;/code&gt; is necessary.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an opportunity to reduce the chances that a name change or a Rails upgrade will introduce unexpected behavior to your application. I don&amp;rsquo;t really want to write tests to be sure I&amp;rsquo;m not unintentionally generating a &amp;ldquo;N+1&amp;rdquo; queries for my associations. I want to make it easier to introduce other changes into my app later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Beware of the gotchas&lt;/strong&gt;: &lt;code&gt;:inverse_of&lt;/code&gt; will only work with &lt;code&gt;has_many&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt;, and &lt;code&gt;belong_to&lt;/code&gt; associations and they will not work with the &lt;code&gt;:as&lt;/code&gt;, &lt;code&gt;:polymorphic&lt;/code&gt;, and &lt;code&gt;:through&lt;/code&gt; options. &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Check out to the Rails docs on bi-directional associations&lt;/a&gt; for more info.&lt;/p&gt;

&lt;p&gt;Save yourself the trouble and set &lt;code&gt;:inverse_of&lt;/code&gt; for valid &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;has_one&lt;/code&gt; associations.&lt;/p&gt;
</content>
  </entry>
</feed>
