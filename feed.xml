<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2015-12-01T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Use inverse_of</title>
    <link rel="alternate" href="/blog/use-inverse_of.html"/>
    <id>/blog/use-inverse_of.html</id>
    <published>2015-12-01T19:00:00-05:00</published>
    <updated>2015-12-01T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is to set the &amp;ldquo;inverse of&amp;rdquo; your current relation.&lt;/p&gt;

&lt;p&gt;This option name can be a little confusing at first so let&amp;rsquo;s use an example. Let&amp;rsquo;s say we have an
&lt;code&gt;Author&lt;/code&gt; class and it &lt;code&gt;has_many :posts&lt;/code&gt;. This means we should have a &lt;code&gt;Post&lt;/code&gt; class that maintains a
column, &lt;code&gt;:author_id&lt;/code&gt;, so it we can say it &lt;code&gt;belongs_to :author&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so we know this means if we have an author, we can ask for her posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Loading development environment (Rails 4.2.5)
author = Author.find(1)
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;

author.posts
#  Post Load (0.4ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [#&amp;lt;Post:0x007fde810cb4a0 id: 1, ... &amp;gt;, #&amp;lt;Post:0x007fde810cb248 id: 2, ... &amp;gt;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also query for a post and ask for its author.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;post = Post.find(1)
#  Post Load (0.3ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Post:0x007fde81c7d730 id: 1, ... &amp;gt;

post.author
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde7a5c8518 id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;What It&amp;rsquo;s For&lt;/h3&gt;

&lt;p&gt;Now, for most of our associations, Rails helps us find the &lt;strong&gt;inverse&lt;/strong&gt; relation. For example, if we
start with an author, then ask for her posts, each post will &amp;ldquo;know&amp;rdquo; that the inverse instance of this
relationship is the author. If we iterate over each of &lt;code&gt;author.posts&lt;/code&gt; and ask each post for its
author, we expect to get the same author record:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.posts.map { |post| post.author }
# =&amp;gt; [#&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For consistency, we want each post&amp;rsquo;s author not only to be the same record, but the same
&lt;strong&gt;instance&lt;/strong&gt; in memory. If I modify one author&amp;rsquo;s attributes, I expect that change to be reflected no
matter with inverse I&amp;rsquo;m working with. Let&amp;rsquo;s confirm by inspecting the &lt;code&gt;:object_id&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.object_id
# =&amp;gt; 70296816370740

object_ids = [author.object_id] + author.posts.map { |post| post.author.object_id }
# =&amp;gt; [70296816370740, 70296816370740, 70296816370740, ... ]

object_ids.uniq.size == 1
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!, This means we can say that, for the &lt;code&gt;Author&lt;/code&gt; class, &lt;code&gt;:author&lt;/code&gt; is the &amp;ldquo;inverse of&amp;rdquo; the
&lt;code&gt;has_many :posts&lt;/code&gt; association. So we could add the &lt;code&gt;:inverse_of&lt;/code&gt; option to specify the name of the
inverse association to ensure our object instances match up.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts, inverse_of: :author
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :post
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this example, providing this option will not change the behavior because Rails is already
setting the correct inverse instances as we might expect.&lt;/p&gt;

&lt;p&gt;It may seem obvious, but Rails has to do some work to set the inverse instance on records in an association and must infer the object based on the class name and association name.&lt;/p&gt;

&lt;p&gt;So it should &lt;strong&gt;just work™&lt;/strong&gt;!&lt;/p&gt;

&lt;h3&gt;It Doesn&amp;rsquo;t Always Work&lt;/h3&gt;

&lt;p&gt;I noticed something odd the other day.&lt;/p&gt;

&lt;p&gt;I was reviewing code for our Rails app which introduced abstraction to render a list of items given by a &lt;code&gt;has_many&lt;/code&gt; association. The code was passing around the inverse instance (the original owner of the association) all over the place.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t we expect the inverse to be available on our &lt;code&gt;has_many&lt;/code&gt; items?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an oversimplified example of what we were dealing with. Building on our &lt;code&gt;Author&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt; from earlier, we&amp;rsquo;ll add a &lt;code&gt;Tweet&lt;/code&gt; class. Using ActiveRecord&amp;rsquo;s single-table inheritance mechanism, &lt;code&gt;Tweet&lt;/code&gt; inherits functionality from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
  has_many :tweets, class_name: &amp;#39;Tweet&amp;#39;
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end

# app/models/tweet.rb
class Tweet &amp;lt; Post
  validates :text, length: { maximum: 140 }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Author&lt;/code&gt; class &lt;code&gt;has_many :tweets&lt;/code&gt; and each tweet has an author since it inherits its associations from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet = Tweet.last
#=&amp;gt; #&amp;lt;Tweet:0x007fc24c1dadd8 id: 10, ... &amp;gt;

tweet.author
#=&amp;gt; #&amp;lt;Author:0x007fc248e11998# id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code was rendering each tweet in a list and each tweet needed to refer back to the author for additional data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It seemed odd to pass the author author around.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;tweet&lt;/code&gt; defines its &lt;code&gt;author&lt;/code&gt; association since it inherits from &lt;code&gt;Post&lt;/code&gt;. I knew my colleague would have had a good reason for passing the &lt;code&gt;author&lt;/code&gt; instance along so I opened up a &lt;code&gt;rails console&lt;/code&gt; to find out what happened if I used the inverse association instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# ...
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot of database queries for one author!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s the classic problem with &lt;code&gt;has_many&lt;/code&gt; associations: the &amp;ldquo;N+1&amp;rdquo; query. After the initial &lt;code&gt;author.tweet&lt;/code&gt; query, &amp;ldquo;N&amp;rdquo; additional queries are needed to call each &lt;code&gt;tweet.author&lt;/code&gt; back through the &lt;code&gt;belongs_to&lt;/code&gt; association. We were avoiding the extra lookups by passing around the original author instance.&lt;/p&gt;

&lt;p&gt;This is unfortunate because we, as we have seen, it should be possible to avoid these extra queries so that each tweet&amp;rsquo;s author points to the same author object in memory.&lt;/p&gt;

&lt;p&gt;Not only do we want to avoid the extra queries, but if modifications are made in one place, we&amp;rsquo;d like them to be reflected elsewhere. I want to avoid something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet_1 = author.tweets.first
tweet_2 = author.tweets.second

tweet_1.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;

tweet_1.author.name = &amp;quot;Martha&amp;quot;

tweet_1.author.name # =&amp;gt; &amp;quot;Martha&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So passing the &lt;code&gt;author&lt;/code&gt; instance variable into the block, as an additional argument to method calls, or down to a view template is one workaround. But this can be difficult to maintain, especially if we&amp;rsquo;re dealing with more than one author&amp;rsquo;s posts. Wouldn&amp;rsquo;t it be better not to make those unnecessary queries?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s possible! &lt;code&gt;:inverse_of&lt;/code&gt; to the rescue.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Author &amp;lt; ActiveRecord::Base
  has_many :tweets, inverse_of: :author
end

class Tweet &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :tweets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when iterate over the tweets and reference the author, &lt;strong&gt;no additional queries
are needed&lt;/strong&gt; because each tweet can now assign its author association from the
instance that exists already in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24c65c028 ... &amp;gt;
author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
=&amp;gt; [&amp;quot;vicenta&amp;quot;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that additional queries for the author (&lt;code&gt;Author Load...&lt;/code&gt;) don&amp;rsquo;t appear in the query log: no more &amp;ldquo;N+1&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;You might be asking&amp;hellip; why doesn&amp;rsquo;t Rails just do this by default all the time? That&amp;rsquo;s a good question. Turns out, it&amp;rsquo;s not so easy. The &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Rails guides&lt;/a&gt; say:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every association will attempt to automatically find the inverse association and set the &lt;code&gt;:inverse_of&lt;/code&gt; option heuristically (based on the association name). Most associations with standard names will be supported.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So Rails will &amp;ldquo;try hard&amp;rdquo; to make the inverse association work automatically to prevent the extra queries. If no name is found with the &lt;code&gt;:inverse_of&lt;/code&gt; key in the association options, ActiveRecord will try to find the inverse association automatically inferring the class name from the association name, i.e. as &lt;code&gt;Post&lt;/code&gt; is implied by &lt;code&gt;has_many :posts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To summarize, when the name of the association and the name of the class Rails expects to find in the
association don&amp;rsquo;t match, or other certain other options are uses, automatic inverse lookup won&amp;rsquo;t happen. Then you may see extra
queries for objects that already exist in memory.&lt;/p&gt;

&lt;h3&gt;Avoid Uncertainty, Be Explicit&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s my recommendation:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set the &lt;code&gt;:inverse_of&lt;/code&gt; option wherever you can.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yeah, Rails will try hard to do automatic inverses on your behalf, but &lt;strong&gt;leaving it up to Rails adds uncertainty&lt;/strong&gt;. The uncertainty makes me uncomfortable.&lt;/p&gt;

&lt;p&gt;Also know that &lt;strong&gt;other ActiveRecord options can interfere with automatic inverses&lt;/strong&gt;: for example, using &lt;code&gt;:foreign_key&lt;/code&gt; in your association will make it impossible to guess the inverse. In these cases, if you expect to have inverses set properly, using &lt;code&gt;:inverse_of&lt;/code&gt; is necessary.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an opportunity to reduce the chances that a name change or a Rails upgrade will introduce unexpected behavior to your application. I don&amp;rsquo;t really want to write tests to be sure I&amp;rsquo;m not unintentionally generating a &amp;ldquo;N+1&amp;rdquo; queries for my associations. I want to make it easier to introduce other changes into my app later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Beware of the gotchas&lt;/strong&gt;: &lt;code&gt;:inverse_of&lt;/code&gt; will only work with &lt;code&gt;has_many&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt;, and &lt;code&gt;belong_to&lt;/code&gt; associations and they will not work with the &lt;code&gt;:as&lt;/code&gt;, &lt;code&gt;:polymorphic&lt;/code&gt;, and &lt;code&gt;:through&lt;/code&gt; options. &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Check out to the Rails docs on bi-directional associations&lt;/a&gt; for more info.&lt;/p&gt;

&lt;p&gt;Save yourself the trouble and set &lt;code&gt;:inverse_of&lt;/code&gt; for valid &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;has_one&lt;/code&gt; associations.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Pascal's Triangle with Ruby's Enumerator</title>
    <link rel="alternate" href="/blog/pascals-triangle-with-rubys-enumerator.html"/>
    <id>/blog/pascals-triangle-with-rubys-enumerator.html</id>
    <published>2015-11-29T19:00:00-05:00</published>
    <updated>2015-11-29T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Pascal’s Triangle is a fun sequence. Here’s what it looks like:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_color.jpg?1448546389"&gt;&lt;/p&gt;

&lt;p&gt;It represents a &lt;a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle"&gt;“triangular array of the binomial coefficients”&lt;/a&gt;. Each row contains an increases in size and contains numbers which can be derived by adding adjacent members of the previous...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Pascal&amp;rsquo;s Triangle is a fun sequence. Here&amp;rsquo;s what it looks like:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_color.jpg?1448546389" /&gt;&lt;/p&gt;

&lt;p&gt;It represents a &lt;a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle"&gt;&amp;ldquo;triangular array of the binomial coefficients&amp;rdquo;&lt;/a&gt;. Each row contains an increases in size and contains numbers which can be derived by adding adjacent members of the previous row.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_animated.gif?1448546389" /&gt;&lt;/p&gt;

&lt;p&gt;We can model this in Ruby as an array of arrays. The first array member is &lt;code&gt;[1]&lt;/code&gt;. Each successive array (or &amp;ldquo;row&amp;rdquo;) will increase in size, and each array member will be the sum of the member at the same index &lt;code&gt;n&lt;/code&gt; in the &lt;code&gt;k-1&lt;/code&gt; row, where &lt;code&gt;k&lt;/code&gt; is the current row, and the &lt;code&gt;n-1&lt;/code&gt; member in the &lt;code&gt;k-1&lt;/code&gt; row or 0. In other words, add the number above and the number above to the left (or zero) to get the current number. We can express the first five rows as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[
  [1],
  [1, 1],
  [1, 2, 1],
  [1, 3, 3, 1],
  [1, 4, 6, 4, 1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s solve this with Ruby. While there are a number of approaches to generating Pascal&amp;rsquo;s Triangle, including both recursive and iterative solutions, we&amp;rsquo;ll explore an approach to treating this as &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;an enumerable&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Starting with the first row, &lt;code&gt;[1]&lt;/code&gt;, we can write a Ruby method that will generate the next row &lt;code&gt;[1, 1]&lt;/code&gt;. Let&amp;rsquo;s write this in a way so it will be possible to generate any row &lt;code&gt;k&lt;/code&gt; from row &lt;code&gt;k-1&lt;/code&gt;. Here&amp;rsquo;s what the usage of this method will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascal_row([1])
=&amp;gt; [1, 1]
pascal_row([1, 3, 3, 1])
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll use Test-Driven Development to validate our implementation starting with a few assertions to ensure the first several rows are returned as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_row(row)
  # yo no se
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_row
    assert_equal [1, 1], pascals_row([1])
    assert_equal [1, 2, 1], pascals_row([1, 1])
    assert_equal [1, 3, 3, 1], pascals_row([1, 2, 1])
    assert_equal [1, 4, 6, 4, 1], pascals_row([1, 3, 3, 1])
    assert_equal [1, 5, 10, 10, 5, 1], pascals_row([1, 4, 6, 4, 1])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our failing test run will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;$ ruby pascals_triangle_test.rb
Run options: --seed 45117

# Running:

F

Finished in 0.001035s, 966.0380 runs/s, 966.0380 assertions/s.

  1) Failure:
TestPascalsTriangle#test_pascals_row [code/pascals_row_test.rb:8]:
Expected: [1, 1]
  Actual: nil

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To extract a general method, let&amp;rsquo;s deconstruct a single row, the fifth: &lt;code&gt;[1, 4, 6, 4, 1]&lt;/code&gt;. Each member is the sum of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n-1&lt;/code&gt; from the previous row, &lt;code&gt;[1, 3, 3, 1]&lt;/code&gt;. We substitute zero when &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;n-1&lt;/code&gt; is missing. Therefore, we can rewrite the fifth row as&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby_"&gt;[(0 + 1), (1 + 3), (3 + 3), (3 + 1), (1 + 0)]
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also represent this as a nested array of number pairs then collect the sum of each pair like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]].collect { |a, b| a + b }
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking closely at the pairs, taking just first members of each pair form the array we get &lt;code&gt;[0, 1, 3, 3, 1]&lt;/code&gt;. The second members of each pair are &lt;code&gt;[1, 3, 3, 1, 0]&lt;/code&gt;. Written differently, the groups are &lt;code&gt;([0] + [1, 3, 3, 1])&lt;/code&gt; and &lt;code&gt;([1, 3, 3, 1] + [0])&lt;/code&gt;. In each we see the members of row four, &lt;code&gt;[1, 3, 3, 1]&lt;/code&gt; augmented by prepending zero or appending zero respectively.&lt;/p&gt;

&lt;p&gt;Getting the nested array pairs from these groups is perfect for the &lt;code&gt;Enumerable#zip&lt;/code&gt; method: &lt;code&gt;zip&lt;/code&gt; groups members of given arrays by position. Therefore, we can &amp;ldquo;zip&amp;rdquo; &lt;code&gt;[0, 1, 3, 3, 1]&lt;/code&gt; with &lt;code&gt;[1, 3, 3, 1, 0]&lt;/code&gt; to produce &lt;code&gt;[[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;[0, 1, 3, 3, 1].zip([1, 3, 3, 1, 0])
=&amp;gt; [[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s extract a variable to represent row four:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1, 3, 3, 1]
([0] + row).zip(row + [0])
=&amp;gt; [[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting it altogether, we can now produce the fifth row from the fourth:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1, 3, 3, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s confirm this expression works with for other row conversions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 1]

row = [1, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 2, 1]

row = [1, 2, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 3, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes! We now have the implementation for our method to produce any row for Pascal&amp;rsquo;s Triangle given the preceding row:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def pascal_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plugging in this implementation&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_row
    assert_equal [1, 1], pascals_row([1])
    assert_equal [1, 2, 1], pascals_row([1, 1])
    assert_equal [1, 3, 3, 1], pascals_row([1, 2, 1])
    assert_equal [1, 4, 6, 4, 1], pascals_row([1, 3, 3, 1])
    assert_equal [1, 5, 10, 10, 5, 1], pascals_row([1, 4, 6, 4, 1])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; we get passing tests&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby code/pascals_row_test.rb
Run options: --seed 61039

# Running:

.

Finished in 0.001020s, 980.6882 runs/s, 4903.4412 assertions/s.

1 runs, 5 assertions, 0 failures, 0 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;In Sequence&lt;/h3&gt;

&lt;p&gt;Now that we have a method to convert one row to its successor, we have a nice building block for an infinite sequence. We can call &lt;code&gt;pascals_row&lt;/code&gt; repeatedly to generate the triangle rows infinitely. I previously wrote about creating &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;infinite sequences in Ruby&lt;/a&gt; with Enumerator and we&amp;rsquo;ll apply this approach here.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;d like to be able to call a method and enumerate the rows representing Pascal&amp;rsquo;s Triangle as we would for an array. Since we&amp;rsquo;ll be using &lt;code&gt;Enumerator&lt;/code&gt;, which exposes the &lt;code&gt;Enumerable&lt;/code&gt; api, we can use external enumeration with &lt;code&gt;Enumerator#next&lt;/code&gt; to extract rows in succession. Let&amp;rsquo;s rewrite our previous test to demonstrate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_triangle
  # Enumerator, please
end

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_triangle
    rows = pascals_triangle
    assert_equal [1], rows.next
    assert_equal [1, 1], rows.next
    assert_equal [1, 2, 1], rows.next
    assert_equal [1, 3, 3, 1], rows.next
    assert_equal [1, 4, 6, 4, 1], rows.next
    assert_equal [1, 5, 10, 10, 5, 1], rows.next
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With no implementation, the test fails on calling &lt;code&gt;next&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby pascals_triangle_test.rb
Run options: --seed 62081

# Running:

E

Finished in 0.000949s, 1053.4832 runs/s, 0.0000 assertions/s.

  1) Error:
TestPascalsTriangle#test_pascals_rows:
NoMethodError: undefined method `next&amp;#39; for nil:NilClass
    code/pascals_row_test.rb:14:in `test_pascals_rows&amp;#39;

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our enumerator needs to call the &lt;code&gt;pascals_row&lt;/code&gt; method repeatedly with the
previous result. We&amp;rsquo;ll maintain the current row as &lt;code&gt;current&lt;/code&gt;, pass this as the
arg to &lt;code&gt;pascals_row&lt;/code&gt;, replace it with the result and repeat in a loop. Returning the
&lt;code&gt;Enumerator&lt;/code&gt; from the method will allow the caller to control how it&amp;rsquo;s
enumerated.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what the implementation could look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;current = [1]
Enumerator.new do |y|
  loop do
    y &amp;lt;&amp;lt; current
    current = pascals_row(current)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s plug this into our method and rerun:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_triangle(row = [1])
  current = row
  Enumerator.new do |y|
    loop do
      y &amp;lt;&amp;lt; current
      current = pascals_row(current)
    end
  end
end

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_rows
    rows = pascals_triangle
    assert_equal [1], rows.next
    assert_equal [1, 1], rows.next
    assert_equal [1, 2, 1], rows.next
    assert_equal [1, 3, 3, 1], rows.next
    assert_equal [1, 4, 6, 4, 1], rows.next
    assert_equal [1, 5, 10, 10, 5, 1], rows.next
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The exciting thing about this implementation is we can treat our sequence like a collection and call enumerable methods. We can also chain enumerable methods like &lt;code&gt;Enumerator#with_index&lt;/code&gt; and &lt;code&gt;Enumerator#each&lt;/code&gt; to print a &amp;ldquo;pretty&amp;rdquo; triangle of each row with its row number.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascals_triangle.with_index(1).take(10).each do |row, i|
  puts &amp;quot;%d:%#{20+(row.inspect.length/2)}s&amp;quot; % [i, row.inspect]
end

1:                  [1]
2:                 [1, 1]
3:               [1, 2, 1]
4:              [1, 3, 3, 1]
5:            [1, 4, 6, 4, 1]
6:          [1, 5, 10, 10, 5, 1]
7:        [1, 6, 15, 20, 15, 6, 1]
8:      [1, 7, 21, 35, 35, 21, 7, 1]
9:    [1, 8, 28, 56, 70, 56, 28, 8, 1]
10: [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]

=&amp;gt;
[[[1], 1],
 [[1, 1], 2],
 [[1, 2, 1], 3],
 [[1, 3, 3, 1], 4],
 [[1, 4, 6, 4, 1], 5],
 [[1, 5, 10, 10, 5, 1], 6],
 [[1, 6, 15, 20, 15, 6, 1], 7],
 [[1, 7, 21, 35, 35, 21, 7, 1], 8],
 [[1, 8, 28, 56, 70, 56, 28, 8, 1], 9],
 [[1, 9, 36, 84, 126, 126, 84, 36, 9, 1], 10]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the return value combines the each row with its index, an interesting outcome of how enumerator
chains can augment the enumerated values.&lt;/p&gt;

&lt;p&gt;We can also take advantage of &lt;code&gt;Enumerator#lazy&lt;/code&gt; to operate on rows without relying on eager evaluation. Here we use a lazy enumerator chain to demonstrate that the sum of numbers in each row is 2^n:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascals_triangle.lazy.map { |row| Math.log(row.reduce(:+), 2) }.take_while { |n| n &amp;lt; 9 }.force
=&amp;gt; [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enumerators allow us to provide an enumerable interface to generated data in much the same way we do for collections. Try test-driving an enumerable implementation of &lt;a href="https://edublognss.wordpress.com/2013/04/16/famous-mathematical-sequences-and-series/"&gt;other sequences&lt;/a&gt; on your own.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Infinite Sequences in Ruby</title>
    <link rel="alternate" href="/blog/infinite-sequences-in-ruby.html"/>
    <id>/blog/infinite-sequences-in-ruby.html</id>
    <published>2015-11-20T19:00:00-05:00</published>
    <updated>2015-11-20T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Functional languages like Clojure have &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;. Sequences are pretty amazing: they let us treat algorithms as data structures. We can call functions on the data as it is produced, allowing us to interact with the results like a collection even when...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Functional languages like Clojure have &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;. Sequences are pretty amazing: they let us treat algorithms as data structures. We can call functions on the data as it is produced, allowing us to interact with the results like a collection even when the sequence is infinite.&lt;/p&gt;

&lt;p&gt;The Ruby standard library doesn’t have an official sequence class or module, but we can get pretty far with the &lt;code&gt;Enumerable&lt;/code&gt; module. Rubyists are typically introduced to &lt;code&gt;Enumerable&lt;/code&gt; through methods on &lt;code&gt;Array&lt;/code&gt;,  like &lt;code&gt;#map&lt;/code&gt; and &lt;code&gt;#select&lt;/code&gt;. Arrays like &lt;code&gt;[1,2,3,4]&lt;/code&gt; may be thought of as finite, eagerly loaded sequences; they already contains all the members we want to enumerate with methods. We can also extend this API to sequences like “give me multiples of 5” in Ruby.&lt;/p&gt;

&lt;h3&gt;Enumerable Fibonacci&lt;/h3&gt;

&lt;p&gt;Consider an infinite sequence like fibonacci. We could create a method that generates the first &lt;code&gt;n&lt;/code&gt; fibonacci members given &lt;code&gt;n&lt;/code&gt; as a paramter. This implementation could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def eager_fibonacci(n)
  a = b = 1
  result = []

  loop do
    break if result.size &amp;gt;= n

    result &amp;lt;&amp;lt; a
    a, b = b, a + b
  end

  result
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but we can go one step further. Instead of returning an eagerly-loaded array, we can return an &lt;code&gt;Enumerator&lt;/code&gt;. We&amp;rsquo;ll yield each member to the &lt;code&gt;Enumerator&lt;/code&gt; as it is generated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def fibonacci
  Enumerator.new do |y|
    a = b = 1

    loop do
      y &amp;lt;&amp;lt; a
      a, b = b, a + b
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What the heck is an &lt;code&gt;Enumerator&lt;/code&gt;? It’s an enumerable object that can be used for either internal or external enumeration of a collection - for more details, check out my &lt;a href="https://rossta.net/blog/what-is-enumerator.html"&gt;previous post&lt;/a&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; initialize method take a block that acts like a template for an enumerable algorithm. The block takes a parameter, &lt;code&gt;y&lt;/code&gt;, which is an instance of an &lt;code&gt;Enumerator::Yielder&lt;/code&gt;, which let&amp;rsquo;s us yield each member of the &lt;code&gt;Enumerator&lt;/code&gt; to blocks passed to &lt;code&gt;Enumerable&lt;/code&gt; method calls. In short, this means we can treat an &lt;code&gt;Enumerator&lt;/code&gt; like an &lt;code&gt;Array&lt;/code&gt;, though we can also do so much more.&lt;/p&gt;

&lt;p&gt;To retrieve the first ten members of our enumerable fibonacci method, we’d instead do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.take(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can still enumerate over the fibonacci sequence as before:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.take(10).each { |i| puts i }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;Enumerator#lazy&lt;/code&gt; method, we can avoid eager enumeration and run queries or calculations as each member is generated. This opens the door to some interesting use cases, like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.lazy.select(&amp;amp;:even?).first(10)
#=&amp;gt; [2, 8, 34, 144, 610, 2584, 10946, 46368, 196418, 832040]

fibonacci.lazy.select(&amp;amp;:odd?).first(10)
#=&amp;gt; [1, 1, 3, 5, 13, 21, 55, 89, 233, 377]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can filter for the first 10 even or odd numbers generated by fibonacci. Inserting the &lt;code&gt;with_index&lt;/code&gt; enumerator method, we can see how many items we need to enumerate to get either the first 10 even or odd numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.lazy.with_index.select { |n, i| n.odd? }.first(10)
#=&amp;gt; [[1, 0], [1, 1], [3, 3], [5, 4], [13, 6], [21, 7], [55, 9], [89, 10], [233, 12], [377, 13]]

fibonacci.lazy.with_index.select { |n, i| n.even? }.first(10)
#=&amp;gt; [[2, 2], [8, 5], [34, 8], [144, 11], [610, 14], [2584, 17], [10946, 20], [46368, 23], [196418, 26], [832040, 29]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice we only need to enumerate 13 items to retrieve 10 odd numbers from fibonacci, while 29 are needed to retrieve the first 10 evens. These results wouldn’t be easily achieved with our previous fibonacci implementation in which the number of desired members must be known ahead of time.&lt;/p&gt;

&lt;p&gt;Try creating other numerical sequences with enumerators on your own, like multiples of &lt;code&gt;n&lt;/code&gt;, factorials for the first &lt;code&gt;n&lt;/code&gt; integers or enumerating sums of squares. Also be sure to check out Pat Shaughnessy&amp;rsquo;s &lt;a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy"&gt;great primer on lazy enumerators&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Sequence Functions&lt;/h3&gt;

&lt;p&gt;Clojure also has a number of useful functions that allow us to generate sequences from other functions. Let’s look at &lt;code&gt;repeatedly&lt;/code&gt; which simply calls the given function over and over, emitting the results as a sequence. To get a sequence of five random numbers between 0 - 100:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;(take 5 (repeatedly #(rand-int 100)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax may look odd, but read in plain English, this expression “takes the first 5 results of repeatedly asking for a random integer of 0 to 100”, returning sequence.&lt;/p&gt;

&lt;p&gt;We can use Ruby enumerators to do something similar in Ruby. Let’s create our own version of &lt;code&gt;repeatedly&lt;/code&gt;, which takes a will call a given block over and over again. Let’s start with a naive implementation which use a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly_foo(&amp;amp;block)
 loop do
    block.call
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method is not useful because the function will never return; it&amp;rsquo;s an infinite loop! You’ll have to issue a kill signal to stop the execution (Ctrl-C!). We could give &lt;code&gt;repeatedly_foo&lt;/code&gt; a limit &lt;code&gt;n&lt;/code&gt; and break out of the loop with a counter.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly_foo(n, &amp;amp;block)
  result = []

  loop do
    break if result.size &amp;gt;= n

    result &amp;lt;&amp;lt; block.call
  end

  result
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an improvement, but like our fibonacci example earlier, it means we need to load the desired number eagerly in the &lt;code&gt;result&lt;/code&gt; array and have less control over the results.&lt;/p&gt;

&lt;p&gt;Again, we&amp;rsquo;ll wrap the loop in an &lt;code&gt;Enumerator&lt;/code&gt; so we can treat the result as a sequence. We’ll “yield” the result of calling the block to the &lt;code&gt;Enumerator::Yielder&lt;/code&gt; object (the &lt;code&gt;y &amp;lt;&amp;lt; block.call&lt;/code&gt;) expression in our loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly(&amp;amp;block)
  Enumerator.new do |y|
    loop do
      y &amp;lt;&amp;lt; block.call # &amp;quot;yield&amp;quot; the result to the Enumerator::Yielder
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an abstraction that can be chained to other enumerator methods. It also has a similar terse feel to the Clojure inspiration we saw earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;repeatedly { rand(100) }.take(5)
=&amp;gt; [48, 48, 72, 41, 70] # your results will vary... they&amp;#39;re random!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;To Infinity and Beyond&lt;/h3&gt;

&lt;p&gt;Of course, sequences of numbers aren’t the only concept that can be modeled this way in Ruby. Any collection of unknown size, for example, results from a search query, paginated resources from an API client library, data from a web crawl, etc., are also great use cases for exposure as enumerables. Consider wrapping your generated collections in an Enumerator to provide callers with flexible, composable results.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What the Heck is a Ruby Enumerator?</title>
    <link rel="alternate" href="/blog/what-is-enumerator.html"/>
    <id>/blog/what-is-enumerator.html</id>
    <published>2015-11-17T19:00:00-05:00</published>
    <updated>2015-11-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s pretend we know about Ruby’s &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module - that it’s included in
Ruby’s core collection classes like Array and Hash and provides a bunch of
methods for traversal, searching and sorting, and that we can can introduce it
to plain old ruby...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s pretend we know about Ruby&amp;rsquo;s &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module - that it&amp;rsquo;s included in
Ruby&amp;rsquo;s core collection classes like Array and Hash and provides a bunch of
methods for traversal, searching and sorting, and that we can can introduce it
to plain old ruby classes through inclusion and implementing the &lt;code&gt;#each&lt;/code&gt; method.
Check out this &lt;a href="http://ruby.bastardsbook.com/chapters/enumerables/"&gt;dated - yet reliable - Enumerable primer&lt;/a&gt; if you&amp;rsquo;d like a refresher.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://ruby-doc.org/core-2.2.0/Enumerator.html"&gt;Enumerator&lt;/a&gt; is like &lt;code&gt;Enumerable&amp;#39;s&lt;/code&gt; kid sister; while &lt;code&gt;Enumerable&lt;/code&gt; is getting all the attention, &lt;code&gt;Enumerator&lt;/code&gt;, having borrowed many traits of her sibling, can do lots of amazing things in her own way and really should get more credit. Well, it&amp;rsquo;s time you took notice, Ma.&lt;/p&gt;

&lt;p&gt;So what exactly is &lt;code&gt;Enumerator&lt;/code&gt;?. For one, it&amp;rsquo;s a class. You can instantiate an
instance of &lt;code&gt;Enumerator&lt;/code&gt; by calling certain &lt;code&gt;Enumerable&lt;/code&gt; instance methods, like &lt;code&gt;Array#each&lt;/code&gt;, without a block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[1, 2, 3].each
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:each&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, you can do this for many (but not all) of Array&amp;rsquo;s &lt;code&gt;Enumerable&lt;/code&gt; methods
that expect a block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[1, 2, 3].map
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:map&amp;gt;

[1, 2, 3].select
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:select&amp;gt;

[1, 2, 3].reduce
LocalJumpError: no block given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, big deal. What does this get us? Glad you asked.&lt;/p&gt;

&lt;p&gt;Instances of Enumerator are enumerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map
e.each { |n| p n }
1
2
3
=&amp;gt; [nil, nil, nil]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See what happened there? The expression printed out each digit, but returned &lt;code&gt;[nil, nil, nil]&lt;/code&gt; instead of of &lt;code&gt;[1, 2, 3]&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; implemented &lt;code&gt;map&lt;/code&gt; in the context of &lt;code&gt;each&lt;/code&gt;; since &lt;code&gt;p n&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, we got three entries of &lt;code&gt;nil&lt;/code&gt; in the return value. We chained the behavior of two enumerable methods.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another example. It&amp;rsquo;s often useful to enumerate collection members along
with the index. We can use &lt;code&gt;Enumerable#each_with_index&lt;/code&gt;, we don&amp;rsquo;t have
&lt;code&gt;Enumerable#map_with_index&lt;/code&gt;. Javascript &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; gets this right, but not Ruby&amp;hellip; or does it?&lt;/p&gt;

&lt;p&gt;Almost - we can chain enumerators together to get effectively the same result:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map
e.each_with_index { |n, i| n * i }
=&amp;gt; [0, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block receives each member of the original array along with its index
for each iteration. This usage is common enough, that &lt;code&gt;Enumerator&lt;/code&gt; provides
&lt;code&gt;with_index&lt;/code&gt; to give:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map.with_index { |n, i| n * i }
=&amp;gt; [0, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reads pretty well, eh? What&amp;rsquo;s really interesting here is that enumerators package
up knowledge of a collection and a method with which we want to enumerate.&lt;/p&gt;

&lt;p&gt;We can combine several enumerators in different orders to get different
behaviors. Here&amp;rsquo;s an nice example borrowed from &lt;a href="http://dgiim.github.io/blog/2015/08/24/ruby-enumerators/#the-enumerator-class"&gt;another recent post on the subject&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;letters = %w[a b c d e]

group_1 = letters.reverse_each.group_by.each_with_index do |item, index|
  index % 3
end

group_2 = letters.reverse_each.each_with_index.group_by do |item, index|
  index % 3
end

p group_1
=&amp;gt; {0=&amp;gt;[&amp;quot;e&amp;quot;, &amp;quot;b&amp;quot;], 1=&amp;gt;[&amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;], 2=&amp;gt;[&amp;quot;c&amp;quot;]}

p group_2
=&amp;gt; {0=&amp;gt;[[&amp;quot;e&amp;quot;, 0], [&amp;quot;b&amp;quot;, 3]], 1=&amp;gt;[[&amp;quot;d&amp;quot;, 1], [&amp;quot;a&amp;quot;, 4]], 2=&amp;gt;[[&amp;quot;c&amp;quot;, 2]]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enumerator&lt;/code&gt; provides some additional methods that allow for &amp;ldquo;external&amp;rdquo;
enumeration as well. With an enumerator instance, we can call &lt;code&gt;next&lt;/code&gt; to get each
successive member of the collection.&lt;/p&gt;

&lt;p&gt;Consider &lt;code&gt;Enumerable#cycle&lt;/code&gt;. Calling &amp;ldquo;cycle&amp;rdquo; on an enumerable collection (without a limit arg) will enumerate over members of a collection ad nauseum. When implemented as an enumerator of css colors, we can use &lt;code&gt;cycle&lt;/code&gt; to create striped table rows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Project = Struct.new(:name)

colors = [&amp;#39;aliceblue&amp;#39;, &amp;#39;ghostwhite&amp;#39;].cycle
projects = [Project.new(&amp;quot;TODO&amp;quot;),
            Project.new(&amp;quot;Work&amp;quot;),
            Project.new(&amp;quot;Home&amp;quot;)]

require &amp;#39;erb&amp;#39;

erb = (&amp;lt;&amp;lt;-ERB)
&amp;lt;table&amp;gt;
&amp;lt;% projects.each_with_index do |project, index| %&amp;gt;
 &amp;lt;tr style=&amp;quot;background: &amp;lt;%= colors.next %&amp;gt;&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;&amp;lt;%= index + 1 %&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;&amp;lt;%= project.name %&amp;gt;&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;/table&amp;gt;
ERB

p ERB.new(erb).result(binding).gsub(/^$\n/, &amp;quot;&amp;quot;)

=&amp;gt; &amp;#39;&amp;lt;table&amp;gt;
 &amp;lt;tr style=&amp;quot;background: aliceblue&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;TODO&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
 &amp;lt;tr style=&amp;quot;background: ghostwhite&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;Work&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
 &amp;lt;tr style=&amp;quot;background: aliceblue&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;Home&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Brilliant! Notice how, in each enumeration of &lt;code&gt;project&lt;/code&gt;, we&amp;rsquo;re calling &lt;code&gt;colors.next&lt;/code&gt;. So external enumeration is one technique for enumerating more than one collection at a time.&lt;/p&gt;

&lt;p&gt;Not all enumerators will enumerate forever. Using cycle with a limit will result
in a &lt;code&gt;StopIteration&lt;/code&gt; error:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;numbers = [1,2].cycle(1)
=&amp;gt; #&amp;lt;Enumerator: [1, 2]:cycle(1)&amp;gt;

numbers.next
# =&amp;gt; 1

numbers.next
=&amp;gt; 2

numbers.next
StopIteration: iteration reached an end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;loop&lt;/code&gt; construct knows how to rescues from this error and treats it as a
&lt;code&gt;break&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;numbers = [1,2].cycle(1)
=&amp;gt; #&amp;lt;Enumerator: [1, 2]:cycle(1)&amp;gt;

loop do
  p numbers.next
end

puts &amp;quot;Tada!&amp;quot;

1
2
=&amp;gt; nil

Tada!
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can rewind enumerators or peek at their next values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].each

e.next
=&amp;gt; 1

e.peek
=&amp;gt; 2

e.next
=&amp;gt; 2

e.rewind
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:each&amp;gt;

e.next
=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So enumerators give us flexible and composable uses for enumerables. Combine them to extend behavior of existing enumerable methods. Use them for external enumeration with methods like &lt;code&gt;#next&lt;/code&gt; and &lt;code&gt;#peek&lt;/code&gt; for iterating over multiple arrays. In a future post, we&amp;rsquo;ll take a look at how to create our own enumerators outside the context of arrays and hashes and some good reasons for doing so.&lt;/p&gt;

&lt;p&gt;In case you missed it, &lt;a href="blog/ruby-enumerable.html"&gt;check out my presentation in the previous post&lt;/a&gt; on the &lt;code&gt;Enumerable&lt;/code&gt; module for more examples on how to get the most out of this terrific Ruby module.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Enumerable - Why I Fell in Love with Ruby</title>
    <link rel="alternate" href="/blog/ruby-enumerable.html"/>
    <id>/blog/ruby-enumerable.html</id>
    <published>2015-11-16T19:00:00-05:00</published>
    <updated>2015-11-16T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I like to say I started programming by accident. While facilitating a Lego robotics club during my teaching years, I was surprised to realize how much I enjoyed coding. Later, when I first learned Ruby as a full-time developer, I rediscovered that...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I like to say I started programming by accident. While facilitating a Lego robotics club during my teaching years, I was surprised to realize how much I enjoyed coding. Later, when I first learned Ruby as a full-time developer, I rediscovered that joy.&lt;/p&gt;

&lt;p&gt;A big reason for my love of Ruby is the &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module because of its simple, functional style and ability to be combined and chained to form useful constructs - a lot like Legos.&lt;/p&gt;

&lt;p&gt;I recently gave a talk at both &lt;a title="NYC.rb" href="http://www.meetup.com/NYC-rb/events/223864932/"&gt;NYC.rb&lt;/a&gt; and &lt;a title="DC Ruby User's Group" href="http://www.meetup.com/dcruby/events/225338026/"&gt;DCRUG&lt;/a&gt; about some great features of &lt;code&gt;Enumerable&lt;/code&gt; that deserve more attention. I touch on interesting use cases for using &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Enumerator&lt;/code&gt; including API client libraries, streaming HTTP, web crawlers, CSV parsing, and infinite sequences.&lt;/p&gt;

&lt;script async class="speakerdeck-embed" data-id="df623bc08aa642328c303a619c92fab0" data-ratio="1.55386949924127" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

&lt;p&gt;I put together a bunch of code samples for the talk and assembled them in a repository on GitHub:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/loves-enumerable"&gt;https://github.com/rossta/loves-enumerable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To run a sample, clone the repo and install the gems:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ git clone https://github.com/rossta/loves-enumerable.git
$ cd loves-enumerable
$ bundle install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then simply run the code with the ruby executable.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby code/pascals_triangle.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll get the most out of this repo by inspecting the source along with following the presentation.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Three Steps to Effective Code Reviews</title>
    <link rel="alternate" href="/blog/three-steps-to-effective-code-reviews.html"/>
    <id>/blog/three-steps-to-effective-code-reviews.html</id>
    <published>2014-02-24T19:00:00-05:00</published>
    <updated>2014-02-24T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;These days, software developers are living in a &lt;a href="http://scottchacon.com/2011/08/31/github-flow.html"&gt;GitHub Workflow&lt;/a&gt; world. They develop new code on version-controlled &lt;a href="http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging"&gt;branches&lt;/a&gt; and gather feedback prior to inclusion in the primary release, or “master” branch, through &lt;a href="https://help.github.com/articles/using-pull-requests"&gt;pull requests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our development team...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;These days, software developers are living in a &lt;a href="http://scottchacon.com/2011/08/31/github-flow.html"&gt;GitHub Workflow&lt;/a&gt;&lt;/a&gt; world. They develop new code on version-controlled &lt;a href="http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging"&gt;branches&lt;/a&gt; and gather feedback prior to inclusion in the primary release, or “master” branch, through &lt;a href="https://help.github.com/articles/using-pull-requests"&gt;pull requests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our development team at ChallengePost has been using this workflow for almost two years with great success, although we&amp;#8217;ve had our share of pain points. For better or worse, feedback typically happens asynchronously and is in written form. Convenient, yes, although this approach is not free of the wrinkles, especially when we use poor word choice, hyperbole, sarcasm, and other forms of counterproductive commentary.&lt;/p&gt;

&lt;p&gt;This has led to resentment and injured relationships on occasion. In response, I’m working to improve how we give and receive criticism.&lt;/p&gt;

&lt;h3&gt;Building trust&lt;/h3&gt;

&lt;p&gt;Let&amp;#8217;s assume that, when done well, code reviews are a good thing. That is to say, the practice of giving and receiving feedback in a consistent, continual manner has true benefits. These may include improving code quality over time and driving convergence of ideas and practices within your team. In my experience, for feedback to be effective, trust amongst team members is a key requirement.&lt;/p&gt;

&lt;p&gt;This may not be an issue for teams that have been together for a long time or share common values, but for others, trust has to be earned. In the absence of trust, there&amp;#8217;s more opportunity for personal differences to get intertwined with feedback. While there are no quick fixes, what follows are code review practices that we have adopted to foster our shared sense of trust.&lt;/p&gt;

&lt;h3&gt;1. Adopt a style guide&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Spoiler alert&lt;/strong&gt;: code syntax and formatting are trivial choices. What&amp;#8217;s most important is your team agrees on and adheres to a set of guidelines.&lt;/p&gt;

&lt;p&gt;Take a few hours as a team to hammer out a style guide for each of the languages you use. Better yet, use a public example like &lt;a href="https://github.com/styleguide"&gt;GitHub&amp;#8217;s style guide&lt;/a&gt; as a starting point. Besides the obvious benefits of consistency and maintainability, style guides reduce the likelihood of flared tempers during reviews; when you’re pushing to get a new feature out the door, it&amp;#8217;s unhealthy to argue over whitespace. This works when your team respectfully follows and comments on style issues respectfully, saving concerns about existing guidelines for separate discussions.&lt;/p&gt;

&lt;h3&gt;2. Start with the end in mind&lt;/h3&gt;

&lt;p&gt;Imagine a developer who emerges, after hours or days off in the “zone,” with a sparkly new feature and asks for a review. All is good, right? Except that the rest of the team has issues with the implementation. Words are exchanged, the developer takes the feedback personally, and suddenly the entire team is distracted from shipping code.&lt;/p&gt;

&lt;p&gt;Personally, I believe code review should begin well before the final commit. It can happen early on; in short discussions with teammates once the ideas start to take shape. Get buy-in on your approach before you’re ready to merge your branch. Opening a pull request and asking for feedback while work is still in progress is a great way to build trust between teammates, and reduce the likelihood that criticism may be interpreted as a personal attack.&lt;/p&gt;

&lt;h3&gt;3. Use the Rubber Duck&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Rubber_duck_debugging"&gt;Rubber duck&lt;/a&gt; debugging is a method of finding solutions simply by explaining code line-by-line to an inanimate object. We&amp;#8217;ve found it helps to do the same with our writing, especially when our first instinct is to respond to code or another comment with sarcasm or anger. Take a moment to read your response aloud and question the wording, timing, and appropriateness. This includes taking into account the personality of the team members you’re addressing. &lt;a href="http://thoughtbot.com"&gt;Thoughtbot&lt;/a&gt; has compiled a useful set of &lt;a href="https://github.com/thoughtbot/guides/tree/master/code-review"&gt;code review guidelines&lt;/a&gt; to help both readers and writers respond thoughtfully. I also suggest that teammates share meta-feedback to ensure that everyone is hitting the right notes of tone and instruction.&lt;/p&gt;

&lt;p&gt;The next time you feel pain in a code review, take a step back to consider what’s missing. It could be that your team needs to adopt some guidelines to reduce friction and ensure feedback is exchanged in as a constructive and positive manner as possible. After all, you have both code and relationships to maintain.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/bbatsov/ruby-style-guide"&gt;Community ruby style guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/styleguide"&gt;GitHub style guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mdswanson.com/blog/2012/11/04/code-reviews-good-idea-bad-idea.html"&gt;Code reviews: Good idea / bad idea?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.dblock.org/why-i-love-code-reviews"&gt;Why I Love Code Reviews&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://whilefalse.blogspot.com/2012/06/code-reviews-code-stories.html"&gt;Code Review, Code Stories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/blog/1124-how-we-use-pull-requests-to-build-github"&gt;How we use pull requests to build GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
