<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2015-12-14T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>Handling Paginated Resources in Ruby</title>
    <link rel="alternate" href="/blog/paginated-resources-in-ruby.html"/>
    <id>/blog/paginated-resources-in-ruby.html</id>
    <published>2015-12-14T19:00:00-05:00</published>
    <updated>2015-12-14T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;The thing with paginated data is we can’t get it all at once.&lt;/p&gt;

&lt;p&gt;Let’s say we’re using the &lt;a href="https://developers.trello.com/"&gt;Trello API&lt;/a&gt;. There are a number of Trello endpoints that return paginated data sets, such as boards, lists,
cards, and actions (like comments, copies, moves, etc...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;The thing with paginated data is we can&amp;rsquo;t get it all at once.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re using the &lt;a href="https://developers.trello.com/"&gt;Trello API&lt;/a&gt;. There are a number of Trello endpoints that return paginated data sets, such as boards, lists,
cards, and actions (like comments, copies, moves, etc).&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re querying for Trello cards marked as completed each month since last January, for example, we may need to request several pages of &amp;ldquo;cards&amp;rdquo; &lt;img src="/assets/images/icons/noun_63447.png?1450157944" class="icon-image inline" /&gt; &lt;img src="/assets/images/icons/noun_63453.png?1450157944" class="icon-image inline" /&gt;&lt;/p&gt;

&lt;p&gt;In most cases, Trello will provide a default limit, typically 50, on the number of resources returned in a single request. But what if you need more than that? In this post, we&amp;rsquo;ll examine a few ways to collect paginated results in Ruby.&lt;/p&gt;

&lt;h3&gt;Trello World&lt;/h3&gt;

&lt;p&gt;The &lt;a href="https://developers.trello.com/"&gt;Trello developer docs&lt;/a&gt; provide a quickstart in javascript - here&amp;rsquo;s the unofficial Ruby version.&lt;/p&gt;

&lt;p&gt;While logged into your Trello account (you&amp;rsquo;ll need one first), &lt;strong&gt;&lt;a href="https://trello.com/app-key"&gt;retrieve your app key&lt;/a&gt;&lt;/strong&gt;. We won&amp;rsquo;t need the &amp;ldquo;secret&amp;rdquo; for this article.&lt;/p&gt;

&lt;p&gt;Next, you&amp;rsquo;ll generate an &lt;strong&gt;app token&lt;/strong&gt;. Paste the following URL into your browser with your app &lt;strong&gt;key&lt;/strong&gt; subsituted for the placeholder.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;https://trello.com/1/authorize?expiration=never&amp;amp;scope=read,write,account&amp;amp;response_type=token&amp;amp;name=Trello%20World&amp;amp;key=YOUR_KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have an app key and token, we can make authenticated requests to the Trello API. As a quick test, paste the following url  with your own key and token as pararameters into your web browser (or use &lt;code&gt;curl&lt;/code&gt;) to read your member data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;https://api.trello.com/1/members/me?key=YOUR_KEY&amp;amp;token=YOUR_TOKEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see a JSON response with attributes like your Trello id, username, bio, etc.&lt;/p&gt;

&lt;h3&gt;Script mode&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s fetch some paginated data in Ruby. For the following examples, we&amp;rsquo;ll be using Ruby 2.2.&lt;/p&gt;

&lt;aside class="callout panel"&gt;&lt;p&gt;

For academic reasons, we&amp;rsquo;re ignoring available Ruby clients for the Trello API like &lt;strong&gt;&lt;a href="https://github.com/jeremytregunna/ruby-trello"&gt;ruby-trello&lt;/a&gt;&lt;/strong&gt;, a popular library which aims to provide some ActiveRecord-like abstractions over Trello resources, and &lt;strong&gt;&lt;a href="https://github.com/rossta/tacokit.rb"&gt;tacokit.rb&lt;/a&gt;&lt;/strong&gt;, a client with different design goals including simplicity and flexibility, inspired by the ideas presented in this post and the GitHub API Ruby wrapper, &lt;a href="https://github.com/octokit/octokit.rb"&gt;octokit.rb&lt;/a&gt;, in aiming to be a &amp;ldquo;flat API client&amp;hellip; that requires little knowledge of REST&amp;rdquo;.

&lt;/p&gt;&lt;/aside&gt;

&lt;p&gt;To make HTTP requests, we&amp;rsquo;ll also use the &lt;a href="https://github.com/httprb/http"&gt;http.rb&lt;/a&gt;, but feel free to subsitute with your HTTP client of choice. Install the gem yourself with &lt;code&gt;gem install http&lt;/code&gt; or add it to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Gemfile

gem &amp;quot;http&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make things easier for the remainder, add the key and token as environment variables in your shell. For Mac/Linux users, something like this will work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;# command line
export TRELLO_APP_KEY=your-key
export TRELLO_APP_TOKEN=your-token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s run Ruby version of our Trello World test.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_eager.rb
require &amp;quot;http&amp;quot;

def app_key
ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;)
end

def app_token
ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;)
end

url = &amp;quot;https://api.trello.com/1/members/me?key=#{app_key}&amp;amp;token=#{app_token}&amp;quot;
puts HTTP.get(url).parse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it worked correctly, you should see the same result we saw in your browser earlier.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s extract a few helpers to build the url. We&amp;rsquo;ll use &lt;code&gt;Addressable::URI&lt;/code&gt;, which is available as a dependency of the http.rb gem as of version &lt;code&gt;1.0.0.pre1&lt;/code&gt; or otherwise may be installed as &lt;code&gt;gem install addressable&lt;/code&gt; or &lt;code&gt;gem &amp;quot;addressable&amp;quot;&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;http&amp;quot;
require &amp;quot;addressable/uri&amp;quot;

def app_key
ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;)
end

def app_token
ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;)
end

def trello_url(path, params = {})
auth_params = { key: app_key, token: app_token }

Addressable::URI.new({
scheme: &amp;quot;https&amp;quot;,
host: &amp;quot;api.trello.com&amp;quot;,
path: File.join(&amp;quot;1&amp;quot;, path),
query_values: auth_params.merge(params)
})
end

def get(path)
HTTP.get(trello_url(path)).parse
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Let&amp;rsquo;s Paginate&lt;/h3&gt;

&lt;p&gt;Now we&amp;rsquo;ll add an alternative method to &lt;code&gt;#get&lt;/code&gt; that can handle pagination.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MAX = 1000

def paginated_get(path, options = {})
params  = options.dup
page    = params.delete(:page) { 1 }
limit   = params.fetch(:limit) { 50 }
results = []

loop do
data = get(path, { page: page }.merge(params))

page += 1
results += data

break if (data.empty? || page * limit &amp;gt;= MAX)
end

results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given a path and hash of parameter options, we&amp;rsquo;ll build up an array of results by fetching the endpoint and incrementing the page number each time. Once either the max is reached or no more results are returned from the API, we&amp;rsquo;ll exit the loop.&lt;/p&gt;

&lt;p&gt;As a starting point, this works nicely. We can simply use &lt;code&gt;paginated_get&lt;/code&gt; to collect up to 1000 results for a given resource without the caller caring about pages. Here&amp;rsquo;s how we can grab the all the comments we&amp;rsquo;ve added to Trello cards:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def comments(params = {})
paginated_get(&amp;quot;members/me/actions&amp;quot;, filter: &amp;quot;commentCard&amp;quot;)
end

comments
#=&amp;gt; [{&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;abcd&amp;quot;, &amp;quot;idMemberCreator&amp;quot;=&amp;gt;&amp;quot;wxyz&amp;quot;, &amp;quot;data&amp;quot;=&amp;gt; {...} ...}, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main problem with this approach is that it forces the results to be eager loaded. Unless a max is specified in the method call, we could be waiting for up to 1000 comments to load - 20 requests of 50 comments each - to execute before the results are returned.&lt;/p&gt;

&lt;h3&gt;Stop, enumerate, and listen&lt;/h3&gt;

&lt;p&gt;Next step is to refactor our &lt;code&gt;paginated_get&lt;/code&gt; method to take advantage of Ruby&amp;rsquo;s &lt;code&gt;Enumerator&lt;/code&gt;. I previously &lt;a href="/blog/what-is-enumerator.html"&gt;described Enumerator&lt;/a&gt; and showed how it can be used to &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;generate infinite sequences in Ruby&lt;/a&gt;, including &lt;a href="/blog/pascals-triangle-with-rubys-enumerator.html"&gt;Pascal&amp;rsquo;s Triangle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main advantage of using &lt;code&gt;Enumerator&lt;/code&gt; will be to give callers flexibility to work with the results including filtering, searching, and lazy enumeration.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_enumerator.rb

def paginated_get(path, options = {})
Enumerator.new do |y|
params  = options.dup
page    = params.delete(:page) { 1 }
limit   = params.fetch(:limit) { 50 }

loop do
data = get(path, { page: page }.merge(params))

data.each do |element|
y.yield element
end

break if (data.empty? || page * limit &amp;gt;= MAX)

page += 1
end
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve got a few similarities with our first implementation. We still loop over repeated requests for successive pages until either the max is reach or no data is returned from the API. There are a few big differences though.&lt;/p&gt;

&lt;p&gt;First, you&amp;rsquo;ll notice we&amp;rsquo;ve wrapped our expression in &lt;code&gt;Enumerator&lt;/code&gt; which will serve as the return value for &lt;code&gt;#paginated_get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using an enumerator may look strange but it offers a huge advantage over our first iteration. Enumerators allow callers to interact with data &lt;strong&gt;as it is generated&lt;/strong&gt;. Conceptually, the enumerator represents the algorithm for retrieving or generating data in &lt;code&gt;Enumerable&lt;/code&gt; form.&lt;/p&gt;

&lt;p&gt;An enumerator implements the &lt;code&gt;Enumerable&lt;/code&gt; module which means we can call familiar methods like &lt;code&gt;#map&lt;/code&gt;, &lt;code&gt;#select&lt;/code&gt;, &lt;code&gt;#take&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;Instead of building up an internal array of results, enumerators provide a mechanism for yielding each element even though a block may not be given to the method (how mind blowing is that?).&lt;/p&gt;

&lt;p&gt;Now we can use enumerator chains to doing something like the following, where we request comment data lazily, transform the API hash to comment text and select the first two addressed to a colleague.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;comments.lazy.
map { |a| a[&amp;quot;data&amp;quot;][&amp;quot;text&amp;quot;] }.
select { |t| t.start_with?(&amp;quot;@personIWorkWith&amp;quot;) }.
take(2).force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We may not need to load all 1000 results to because the enumerators chain is evaluated for each item as it is yielded. This technique provides the caller with a great deal of flexibility. Eager loading can be delayed or avoided altogther - a potential performance gain.&lt;/p&gt;

&lt;p&gt;Here are magic lines from &lt;code&gt;#paginated_get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;data.each do |element|
y.yield element
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;y.yield&lt;/code&gt; is not the keyword &lt;code&gt;yield&lt;/code&gt;, but the invokation of the &lt;code&gt;#yield&lt;/code&gt; method of &lt;code&gt;Enumerator::Yielder&lt;/code&gt;, an object the enumerator uses internally to pass values through to the first block used in the enumerator chain. For a more detailed look at how enumerators work under the hood, read more about how &lt;a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy"&gt;Ruby works hard so you can be lazy&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;A cursor-y example&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s do one more iteration on our &lt;code&gt;#paginated_get&lt;/code&gt; refactoring. Up to this point, we&amp;rsquo;ve been using a &amp;ldquo;functional&amp;rdquo; approach; we&amp;rsquo;ve just been using a bunch of methods defined in the outermost lexical scope.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll extract a &lt;code&gt;Client&lt;/code&gt; responsible for sending requests to the Trello API and parsing the responses as JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# trello_cursor.rb

require &amp;quot;http&amp;quot;
require &amp;quot;addressable/uri&amp;quot;

class Client
def initialize(opts = {})
@app_key   = opts.fetch(:app_key, ENV.fetch(&amp;quot;TRELLO_APP_KEY&amp;quot;))
@app_token = opts.fetch(:app_token, ENV.fetch(&amp;quot;TRELLO_APP_TOKEN&amp;quot;))
end

def get(path, params = {})
HTTP.get(trello_url(path, params)).parse
end

private

def trello_url(path, params = {})
auth_params = { key: @app_key, token: @app_token }

Addressable::URI.new({
scheme: &amp;quot;https&amp;quot;,
host: &amp;quot;api.trello.com&amp;quot;,
path: File.join(&amp;quot;1&amp;quot;, path),
query_values: auth_params.merge(params)
})
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we&amp;rsquo;ll provide a class to represent the paginated collection of results to replace our implementation of &lt;code&gt;#paginated_get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The Twitter API uses &lt;a href="https://dev.twitter.com/overview/api/cursoring"&gt;cursors&lt;/a&gt; to navigate through pages, a concept similar to &amp;ldquo;next&amp;rdquo; and &amp;ldquo;previous&amp;rdquo; links on websites. Although Trello doesn&amp;rsquo;t provide explicit cursors in their API, we can still wrap the paginated results in an enumerable class to get similar behavior.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Cursor
def initialize(path, options = {})
@path       = path
@params     = options.dup

@collection = []
@page       = params.fetch(:page, 1)
@limit      = params.fetch(:limit, 50)
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Cursor&lt;/code&gt; will be initialized with a path and params, like our &lt;code&gt;paginated_get&lt;/code&gt;. We&amp;rsquo;ll also maintain an internal &lt;code&gt;@collection&lt;/code&gt; array to cache elements as they are returned from Trello.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Cursor
private

def client
@client ||= Client.new
end

def fetch_next_page
response              = client.get(@path, @params.merge(page: @page))
@last_response_empty  = response.empty?
@collection          += response
@page                += 1
end

MAX = 1000

def last?
@last_response_empty || @page * @limit &amp;gt;= MAX
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll introduce a dependency on the &lt;code&gt;Client&lt;/code&gt; to interface with Trello through the private client method. We&amp;rsquo;ll use our client to fetch the next page, append the latest results to our cached &lt;code&gt;@collection&lt;/code&gt; and increment the page number. Now for the key public method:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Cursor
include Enumerable

def each(start = 0)
return to_enum(:each, start) unless block_given?

Array(@collection[start..-1]).each do |element|
yield(element)
end

unless last?
start = [@collection.size, start].max

fetch_next_page

each(start, &amp;amp;Proc.new)
end
end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve chosen to have our &lt;code&gt;Cursor&lt;/code&gt; expose the Enumerable API by including the &lt;code&gt;Enumerable&lt;/code&gt; module and implementing &lt;code&gt;#each&lt;/code&gt;. This will give cursor instances enumerable behavior so we can simply replace our paginated_get definition to return a new &lt;code&gt;Cursor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def paginated_get(path, params)
Cursor.new(path, param)
end

def comments(params = {})
paginated_get(&amp;quot;members/me/actions&amp;quot;, filter: &amp;quot;commentCard&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s break down &lt;code&gt;Cursor#each&lt;/code&gt; a bit further. The first line allows us retain the &lt;code&gt;Enumerator&lt;/code&gt; behavior before.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;return to_enum(:each, start) unless block_given?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It invokes &lt;code&gt;Kernel#to_enum&lt;/code&gt; when no block is given to an &lt;code&gt;each&lt;/code&gt; method call. In this case, the method returns an &lt;code&gt;Enumerator&lt;/code&gt; that packages the behavior of &lt;code&gt;#each&lt;/code&gt; for an enumerator chain similar to before:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;puts comments.each.lazy.
map { |axn| axn[&amp;quot;data&amp;quot;][&amp;quot;text&amp;quot;] }.
select { |txt| txt.start_with?(&amp;quot;@mgerrior&amp;quot;) }.
take(2).force
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more info on using &lt;code&gt;#to_enum&lt;/code&gt;, check out Arkency&amp;rsquo;s &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Stop including Enumerable, use Enumerable instead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We also need to &lt;code&gt;yield&lt;/code&gt; each element in the &lt;code&gt;@collection&lt;/code&gt; to pass elements to callers of &lt;code&gt;#each&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Array(@collection[start..-1]).each do |element|
yield(element)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We iterate from the start of the collection to the end with &lt;code&gt;Array(@collection[start..-1]).each&lt;/code&gt;&amp;hellip; but wait! when we start iterating, the &lt;code&gt;@collection&lt;/code&gt; is empty:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def initialize
# ...
@collection = []
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat?&lt;/p&gt;

&lt;p&gt;The key comes in the lines that follow in &lt;code&gt;#each&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;unless last?
start = [@collection.size, start].max

fetch_next_page

each(start, &amp;amp;Proc.new)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless we&amp;rsquo;ve encountered the last page, we fetch the next page, which appends the latest results to the collection and we recursively invoke &lt;code&gt;#each&lt;/code&gt; with a starting point. This means &lt;code&gt;#each&lt;/code&gt; will be invoked again with new results until no new data is encountered. Sweet!&lt;/p&gt;

&lt;p&gt;A neat trick is how we forward the block given to &lt;code&gt;#each&lt;/code&gt;. When we &lt;code&gt;Proc.new&lt;/code&gt; without explicitly passing a block or proc object, it will instantiate with the block given to its surrounding method if there is one. The behavior is similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def each(start = 0, &amp;amp;block)
# ...
each(start, &amp;amp;block)
# ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main benefit being we don&amp;rsquo;t needlessly invoke &lt;code&gt;Proc.new&lt;/code&gt; by omitting &lt;code&gt;&amp;amp;block&lt;/code&gt; in the arguments. For more on this, read up on &lt;a href="http://mudge.name/2011/01/26/passing-blocks-in-ruby-without-block.html"&gt;Passing Blocks in Ruby without &amp;amp;block&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Recursive each&amp;rdquo; is a powerful technique for providing a seamless, enumerable interface to paginated or cursored results. I first encountered &lt;a href="https://github.com/sferik/twitter/blob/c6c2fe44e4a56c3e3544a3c08492a8b83b549635/lib/twitter/enumerable.rb"&gt;this approach&lt;/a&gt; in the &lt;a href="https://github.com/sferik"&gt;sferik&amp;rsquo;s&lt;/a&gt; &lt;a href="https://github.com/sferik/twitter"&gt;Twitter gem&lt;/a&gt; - a great resource for those considering writing an API wrapper in Ruby.&lt;/p&gt;

&lt;h3&gt;On your own&lt;/h3&gt;

&lt;p&gt;Give it a shot! Pick out an API you like to use and play with techniques for modeling its collection resources. This is a great way to get more experience with Ruby&amp;rsquo;s &lt;a href="/blog/series/enumerable.html"&gt;Enumerable&lt;/a&gt;. Consider one of these approaches when you need to traverse paginated or partitioned subsets of data in an external or internal API.&lt;/p&gt;

&lt;p&gt;Think less about &lt;strong&gt;pages&lt;/strong&gt; and more about &lt;strong&gt;data&lt;/strong&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;Credits&lt;/h3&gt;

&lt;p&gt;Icons via the &lt;a href="https://thenounproject.com/"&gt;Noun Project&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://thenounproject.com/pixelbazaar/"&gt;Arrows by Zlatko Najdenovski&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Use inverse_of</title>
    <link rel="alternate" href="/blog/use-inverse_of.html"/>
    <id>/blog/use-inverse_of.html</id>
    <published>2015-12-01T19:00:00-05:00</published>
    <updated>2015-12-01T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s talk about &lt;code&gt;:inverse_of&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know Rails has ActiveRecord and ActiveRecord gives us associations and associations can really simplify our interactions with databases. These associations provide a number of configuration options, one of which is to set the &amp;ldquo;inverse of&amp;rdquo; your current relation.&lt;/p&gt;

&lt;p&gt;This option name can be a little confusing at first so let&amp;rsquo;s use an example. Let&amp;rsquo;s say we have an
&lt;code&gt;Author&lt;/code&gt; class and it &lt;code&gt;has_many :posts&lt;/code&gt;. This means we should have a &lt;code&gt;Post&lt;/code&gt; class that maintains a
column, &lt;code&gt;:author_id&lt;/code&gt;, so it we can say it &lt;code&gt;belongs_to :author&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so we know this means if we have an author, we can ask for her posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Loading development environment (Rails 4.2.5)
author = Author.find(1)
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;

author.posts
#  Post Load (0.4ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [#&amp;lt;Post:0x007fde810cb4a0 id: 1, ... &amp;gt;, #&amp;lt;Post:0x007fde810cb248 id: 2, ... &amp;gt;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also query for a post and ask for its author.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;post = Post.find(1)
#  Post Load (0.3ms)  SELECT  &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Post:0x007fde81c7d730 id: 1, ... &amp;gt;

post.author
#  Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fde7a5c8518 id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;What It&amp;rsquo;s For&lt;/h3&gt;

&lt;p&gt;Now, for most of our associations, Rails helps us find the &lt;strong&gt;inverse&lt;/strong&gt; relation. For example, if we
start with an author, then ask for her posts, each post will &amp;ldquo;know&amp;rdquo; that the inverse instance of this
relationship is the author. If we iterate over each of &lt;code&gt;author.posts&lt;/code&gt; and ask each post for its
author, we expect to get the same author record:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.posts.map { |post| post.author }
# =&amp;gt; [#&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, #&amp;lt;Author:0x007fde81898868 id: 1, ... &amp;gt;, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For consistency, we want each post&amp;rsquo;s author not only to be the same record, but the same
&lt;strong&gt;instance&lt;/strong&gt; in memory. If I modify one author&amp;rsquo;s attributes, I expect that change to be reflected no
matter with inverse I&amp;rsquo;m working with. Let&amp;rsquo;s confirm by inspecting the &lt;code&gt;:object_id&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author.object_id
# =&amp;gt; 70296816370740

object_ids = [author.object_id] + author.posts.map { |post| post.author.object_id }
# =&amp;gt; [70296816370740, 70296816370740, 70296816370740, ... ]

object_ids.uniq.size == 1
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!, This means we can say that, for the &lt;code&gt;Author&lt;/code&gt; class, &lt;code&gt;:author&lt;/code&gt; is the &amp;ldquo;inverse of&amp;rdquo; the
&lt;code&gt;has_many :posts&lt;/code&gt; association. So we could add the &lt;code&gt;:inverse_of&lt;/code&gt; option to specify the name of the
inverse association to ensure our object instances match up.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts, inverse_of: :author
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :post
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this example, providing this option will not change the behavior because Rails is already
setting the correct inverse instances as we might expect.&lt;/p&gt;

&lt;p&gt;It may seem obvious, but Rails has to do some work to set the inverse instance on records in an association and must infer the object based on the class name and association name.&lt;/p&gt;

&lt;p&gt;So it should &lt;strong&gt;just work™&lt;/strong&gt;!&lt;/p&gt;

&lt;h3&gt;It Doesn&amp;rsquo;t Always Work&lt;/h3&gt;

&lt;p&gt;I noticed something odd the other day.&lt;/p&gt;

&lt;p&gt;I was reviewing code for our Rails app which introduced abstraction to render a list of items given by a &lt;code&gt;has_many&lt;/code&gt; association. The code was passing around the inverse instance (the original owner of the association) all over the place.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t we expect the inverse to be available on our &lt;code&gt;has_many&lt;/code&gt; items?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an oversimplified example of what we were dealing with. Building on our &lt;code&gt;Author&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt; from earlier, we&amp;rsquo;ll add a &lt;code&gt;Tweet&lt;/code&gt; class. Using ActiveRecord&amp;rsquo;s single-table inheritance mechanism, &lt;code&gt;Tweet&lt;/code&gt; inherits functionality from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/author.rb
class Author &amp;lt; ActiveRecord::Base
  has_many :posts
  has_many :tweets, class_name: &amp;#39;Tweet&amp;#39;
end

# app/models/post.rb
class Post &amp;lt; ActiveRecord::Base
  belongs_to :author
end

# app/models/tweet.rb
class Tweet &amp;lt; Post
  validates :text, length: { maximum: 140 }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Author&lt;/code&gt; class &lt;code&gt;has_many :tweets&lt;/code&gt; and each tweet has an author since it inherits its associations from &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet = Tweet.last
#=&amp;gt; #&amp;lt;Tweet:0x007fc24c1dadd8 id: 10, ... &amp;gt;

tweet.author
#=&amp;gt; #&amp;lt;Author:0x007fc248e11998# id: 1, ... &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code was rendering each tweet in a list and each tweet needed to refer back to the author for additional data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It seemed odd to pass the author author around.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;tweet&lt;/code&gt; defines its &lt;code&gt;author&lt;/code&gt; association since it inherits from &lt;code&gt;Post&lt;/code&gt;. I knew my colleague would have had a good reason for passing the &lt;code&gt;author&lt;/code&gt; instance along so I opened up a &lt;code&gt;rails console&lt;/code&gt; to find out what happened if I used the inverse association instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.2ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24dee1ad0 ...&amp;gt;

author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# Author Load (0.1ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
# ...
#=&amp;gt; [&amp;#39;vicenta&amp;#39;, &amp;#39;vicenta&amp;#39;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot of database queries for one author!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s the classic problem with &lt;code&gt;has_many&lt;/code&gt; associations: the &amp;ldquo;N+1&amp;rdquo; query. After the initial &lt;code&gt;author.tweet&lt;/code&gt; query, &amp;ldquo;N&amp;rdquo; additional queries are needed to call each &lt;code&gt;tweet.author&lt;/code&gt; back through the &lt;code&gt;belongs_to&lt;/code&gt; association. We were avoiding the extra lookups by passing around the original author instance.&lt;/p&gt;

&lt;p&gt;This is unfortunate because we, as we have seen, it should be possible to avoid these extra queries so that each tweet&amp;rsquo;s author points to the same author object in memory.&lt;/p&gt;

&lt;p&gt;Not only do we want to avoid the extra queries, but if modifications are made in one place, we&amp;rsquo;d like them to be reflected elsewhere. I want to avoid something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;tweet_1 = author.tweets.first
tweet_2 = author.tweets.second

tweet_1.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;

tweet_1.author.name = &amp;quot;Martha&amp;quot;

tweet_1.author.name # =&amp;gt; &amp;quot;Martha&amp;quot;
tweet_2.author.name # =&amp;gt; &amp;quot;Cecily&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So passing the &lt;code&gt;author&lt;/code&gt; instance variable into the block, as an additional argument to method calls, or down to a view template is one workaround. But this can be difficult to maintain, especially if we&amp;rsquo;re dealing with more than one author&amp;rsquo;s posts. Wouldn&amp;rsquo;t it be better not to make those unnecessary queries?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s possible! &lt;code&gt;:inverse_of&lt;/code&gt; to the rescue.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Author &amp;lt; ActiveRecord::Base
  has_many :tweets, inverse_of: :author
end

class Tweet &amp;lt; ActiveRecord::Base
  belongs_to :author, inverse_of: :tweets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when iterate over the tweets and reference the author, &lt;strong&gt;no additional queries
are needed&lt;/strong&gt; because each tweet can now assign its author association from the
instance that exists already in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;author = Author.find(1)
# Author Load (0.3ms)  SELECT  &amp;quot;authors&amp;quot;.* FROM &amp;quot;authors&amp;quot; WHERE &amp;quot;authors&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT 1  [[&amp;quot;id&amp;quot;, 1]]
#=&amp;gt; #&amp;lt;Author:0x007fc24c65c028 ... &amp;gt;
author.tweets.map { |tw| tw.author.twitter_handle }
# Tweet Load (0.3ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot; WHERE &amp;quot;posts&amp;quot;.&amp;quot;type&amp;quot; IN (&amp;#39;Tweet&amp;#39;) AND &amp;quot;posts&amp;quot;.&amp;quot;author_id&amp;quot; = $1  [[&amp;quot;author_id&amp;quot;, 1]]
=&amp;gt; [&amp;quot;vicenta&amp;quot;, ... ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that additional queries for the author (&lt;code&gt;Author Load...&lt;/code&gt;) don&amp;rsquo;t appear in the query log: no more &amp;ldquo;N+1&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;You might be asking&amp;hellip; why doesn&amp;rsquo;t Rails just do this by default all the time? That&amp;rsquo;s a good question. Turns out, it&amp;rsquo;s not so easy. The &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Rails guides&lt;/a&gt; say:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every association will attempt to automatically find the inverse association and set the &lt;code&gt;:inverse_of&lt;/code&gt; option heuristically (based on the association name). Most associations with standard names will be supported.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So Rails will &amp;ldquo;try hard&amp;rdquo; to make the inverse association work automatically to prevent the extra queries. If no name is found with the &lt;code&gt;:inverse_of&lt;/code&gt; key in the association options, ActiveRecord will try to find the inverse association automatically inferring the class name from the association name, i.e. as &lt;code&gt;Post&lt;/code&gt; is implied by &lt;code&gt;has_many :posts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To summarize, when the name of the association and the name of the class Rails expects to find in the
association don&amp;rsquo;t match, or other certain other options are uses, automatic inverse lookup won&amp;rsquo;t happen. Then you may see extra
queries for objects that already exist in memory.&lt;/p&gt;

&lt;h3&gt;Avoid Uncertainty, Be Explicit&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s my recommendation:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set the &lt;code&gt;:inverse_of&lt;/code&gt; option wherever you can.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yeah, Rails will try hard to do automatic inverses on your behalf, but &lt;strong&gt;leaving it up to Rails adds uncertainty&lt;/strong&gt;. The uncertainty makes me uncomfortable.&lt;/p&gt;

&lt;p&gt;Also know that &lt;strong&gt;other ActiveRecord options can interfere with automatic inverses&lt;/strong&gt;: for example, using &lt;code&gt;:foreign_key&lt;/code&gt; in your association will make it impossible to guess the inverse. In these cases, if you expect to have inverses set properly, using &lt;code&gt;:inverse_of&lt;/code&gt; is necessary.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an opportunity to reduce the chances that a name change or a Rails upgrade will introduce unexpected behavior to your application. I don&amp;rsquo;t really want to write tests to be sure I&amp;rsquo;m not unintentionally generating a &amp;ldquo;N+1&amp;rdquo; queries for my associations. I want to make it easier to introduce other changes into my app later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Beware of the gotchas&lt;/strong&gt;: &lt;code&gt;:inverse_of&lt;/code&gt; will only work with &lt;code&gt;has_many&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt;, and &lt;code&gt;belong_to&lt;/code&gt; associations and they will not work with the &lt;code&gt;:as&lt;/code&gt;, &lt;code&gt;:polymorphic&lt;/code&gt;, and &lt;code&gt;:through&lt;/code&gt; options. &lt;a href="http://guides.rubyonrails.org/association_basics.html#bi-directional-associations"&gt;Check out to the Rails docs on bi-directional associations&lt;/a&gt; for more info.&lt;/p&gt;

&lt;p&gt;Save yourself the trouble and set &lt;code&gt;:inverse_of&lt;/code&gt; for valid &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;has_one&lt;/code&gt; associations.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Pascal's Triangle with Ruby's Enumerator</title>
    <link rel="alternate" href="/blog/pascals-triangle-with-rubys-enumerator.html"/>
    <id>/blog/pascals-triangle-with-rubys-enumerator.html</id>
    <published>2015-11-29T19:00:00-05:00</published>
    <updated>2015-11-29T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Pascal’s Triangle is a fun sequence. Here’s what it looks like:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_color.jpg?1448546389"&gt;&lt;/p&gt;

&lt;p&gt;It represents a &lt;a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle"&gt;“triangular array of the binomial coefficients”&lt;/a&gt;. Each row contains an increases in size and contains numbers which can be derived by adding adjacent members of the previous...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Pascal&amp;rsquo;s Triangle is a fun sequence. Here&amp;rsquo;s what it looks like:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_color.jpg?1448546389" /&gt;&lt;/p&gt;

&lt;p&gt;It represents a &lt;a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle"&gt;&amp;ldquo;triangular array of the binomial coefficients&amp;rdquo;&lt;/a&gt;. Each row contains an increases in size and contains numbers which can be derived by adding adjacent members of the previous row.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Pascal's Triangle" src="/assets/images/blog/pascals_triangle_animated.gif?1448546389" /&gt;&lt;/p&gt;

&lt;p&gt;We can model this in Ruby as an array of arrays. The first array member is &lt;code&gt;[1]&lt;/code&gt;. Each successive array (or &amp;ldquo;row&amp;rdquo;) will increase in size, and each array member will be the sum of the member at the same index &lt;code&gt;n&lt;/code&gt; in the &lt;code&gt;k-1&lt;/code&gt; row, where &lt;code&gt;k&lt;/code&gt; is the current row, and the &lt;code&gt;n-1&lt;/code&gt; member in the &lt;code&gt;k-1&lt;/code&gt; row or 0. In other words, add the number above and the number above to the left (or zero) to get the current number. We can express the first five rows as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[
  [1],
  [1, 1],
  [1, 2, 1],
  [1, 3, 3, 1],
  [1, 4, 6, 4, 1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s solve this with Ruby. While there are a number of approaches to generating Pascal&amp;rsquo;s Triangle, including both recursive and iterative solutions, we&amp;rsquo;ll explore an approach to treating this as &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;an enumerable&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Starting with the first row, &lt;code&gt;[1]&lt;/code&gt;, we can write a Ruby method that will generate the next row &lt;code&gt;[1, 1]&lt;/code&gt;. Let&amp;rsquo;s write this in a way so it will be possible to generate any row &lt;code&gt;k&lt;/code&gt; from row &lt;code&gt;k-1&lt;/code&gt;. Here&amp;rsquo;s what the usage of this method will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascal_row([1])
=&amp;gt; [1, 1]
pascal_row([1, 3, 3, 1])
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll use Test-Driven Development to validate our implementation starting with a few assertions to ensure the first several rows are returned as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_row(row)
  # yo no se
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_row
    assert_equal [1, 1], pascals_row([1])
    assert_equal [1, 2, 1], pascals_row([1, 1])
    assert_equal [1, 3, 3, 1], pascals_row([1, 2, 1])
    assert_equal [1, 4, 6, 4, 1], pascals_row([1, 3, 3, 1])
    assert_equal [1, 5, 10, 10, 5, 1], pascals_row([1, 4, 6, 4, 1])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our failing test run will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;$ ruby pascals_triangle_test.rb
Run options: --seed 45117

# Running:

F

Finished in 0.001035s, 966.0380 runs/s, 966.0380 assertions/s.

  1) Failure:
TestPascalsTriangle#test_pascals_row [code/pascals_row_test.rb:8]:
Expected: [1, 1]
  Actual: nil

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To extract a general method, let&amp;rsquo;s deconstruct a single row, the fifth: &lt;code&gt;[1, 4, 6, 4, 1]&lt;/code&gt;. Each member is the sum of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n-1&lt;/code&gt; from the previous row, &lt;code&gt;[1, 3, 3, 1]&lt;/code&gt;. We substitute zero when &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;n-1&lt;/code&gt; is missing. Therefore, we can rewrite the fifth row as&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby_"&gt;[(0 + 1), (1 + 3), (3 + 3), (3 + 1), (1 + 0)]
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also represent this as a nested array of number pairs then collect the sum of each pair like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]].collect { |a, b| a + b }
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking closely at the pairs, taking just first members of each pair form the array we get &lt;code&gt;[0, 1, 3, 3, 1]&lt;/code&gt;. The second members of each pair are &lt;code&gt;[1, 3, 3, 1, 0]&lt;/code&gt;. Written differently, the groups are &lt;code&gt;([0] + [1, 3, 3, 1])&lt;/code&gt; and &lt;code&gt;([1, 3, 3, 1] + [0])&lt;/code&gt;. In each we see the members of row four, &lt;code&gt;[1, 3, 3, 1]&lt;/code&gt; augmented by prepending zero or appending zero respectively.&lt;/p&gt;

&lt;p&gt;Getting the nested array pairs from these groups is perfect for the &lt;code&gt;Enumerable#zip&lt;/code&gt; method: &lt;code&gt;zip&lt;/code&gt; groups members of given arrays by position. Therefore, we can &amp;ldquo;zip&amp;rdquo; &lt;code&gt;[0, 1, 3, 3, 1]&lt;/code&gt; with &lt;code&gt;[1, 3, 3, 1, 0]&lt;/code&gt; to produce &lt;code&gt;[[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;[0, 1, 3, 3, 1].zip([1, 3, 3, 1, 0])
=&amp;gt; [[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s extract a variable to represent row four:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1, 3, 3, 1]
([0] + row).zip(row + [0])
=&amp;gt; [[0, 1], [1, 3], [3, 3], [3, 1], [1, 0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting it altogether, we can now produce the fifth row from the fourth:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1, 3, 3, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 4, 6, 4, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s confirm this expression works with for other row conversions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;row = [1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 1]

row = [1, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 2, 1]

row = [1, 2, 1]
([0] + row).zip(row + [0]).collect { |a, b| a + b }
=&amp;gt; [1, 3, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes! We now have the implementation for our method to produce any row for Pascal&amp;rsquo;s Triangle given the preceding row:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def pascal_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plugging in this implementation&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_row
    assert_equal [1, 1], pascals_row([1])
    assert_equal [1, 2, 1], pascals_row([1, 1])
    assert_equal [1, 3, 3, 1], pascals_row([1, 2, 1])
    assert_equal [1, 4, 6, 4, 1], pascals_row([1, 3, 3, 1])
    assert_equal [1, 5, 10, 10, 5, 1], pascals_row([1, 4, 6, 4, 1])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; we get passing tests&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby code/pascals_row_test.rb
Run options: --seed 61039

# Running:

.

Finished in 0.001020s, 980.6882 runs/s, 4903.4412 assertions/s.

1 runs, 5 assertions, 0 failures, 0 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;In Sequence&lt;/h3&gt;

&lt;p&gt;Now that we have a method to convert one row to its successor, we have a nice building block for an infinite sequence. We can call &lt;code&gt;pascals_row&lt;/code&gt; repeatedly to generate the triangle rows infinitely. I previously wrote about creating &lt;a href="/blog/infinite-sequences-in-ruby.html"&gt;infinite sequences in Ruby&lt;/a&gt; with Enumerator and we&amp;rsquo;ll apply this approach here.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;d like to be able to call a method and enumerate the rows representing Pascal&amp;rsquo;s Triangle as we would for an array. Since we&amp;rsquo;ll be using &lt;code&gt;Enumerator&lt;/code&gt;, which exposes the &lt;code&gt;Enumerable&lt;/code&gt; api, we can use external enumeration with &lt;code&gt;Enumerator#next&lt;/code&gt; to extract rows in succession. Let&amp;rsquo;s rewrite our previous test to demonstrate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_triangle
  # Enumerator, please
end

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_triangle
    rows = pascals_triangle
    assert_equal [1], rows.next
    assert_equal [1, 1], rows.next
    assert_equal [1, 2, 1], rows.next
    assert_equal [1, 3, 3, 1], rows.next
    assert_equal [1, 4, 6, 4, 1], rows.next
    assert_equal [1, 5, 10, 10, 5, 1], rows.next
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With no implementation, the test fails on calling &lt;code&gt;next&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby pascals_triangle_test.rb
Run options: --seed 62081

# Running:

E

Finished in 0.000949s, 1053.4832 runs/s, 0.0000 assertions/s.

  1) Error:
TestPascalsTriangle#test_pascals_rows:
NoMethodError: undefined method `next&amp;#39; for nil:NilClass
    code/pascals_row_test.rb:14:in `test_pascals_rows&amp;#39;

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our enumerator needs to call the &lt;code&gt;pascals_row&lt;/code&gt; method repeatedly with the
previous result. We&amp;rsquo;ll maintain the current row as &lt;code&gt;current&lt;/code&gt;, pass this as the
arg to &lt;code&gt;pascals_row&lt;/code&gt;, replace it with the result and repeat in a loop. Returning the
&lt;code&gt;Enumerator&lt;/code&gt; from the method will allow the caller to control how it&amp;rsquo;s
enumerated.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what the implementation could look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;current = [1]
Enumerator.new do |y|
  loop do
    y &amp;lt;&amp;lt; current
    current = pascals_row(current)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s plug this into our method and rerun:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;

def pascals_triangle(row = [1])
  current = row
  Enumerator.new do |y|
    loop do
      y &amp;lt;&amp;lt; current
      current = pascals_row(current)
    end
  end
end

def pascals_row(row)
  ([0] + row).zip(row + [0]).collect { |a, b| a + b }
end

class TestPascalsTriangle &amp;lt; Minitest::Test
  def test_pascals_rows
    rows = pascals_triangle
    assert_equal [1], rows.next
    assert_equal [1, 1], rows.next
    assert_equal [1, 2, 1], rows.next
    assert_equal [1, 3, 3, 1], rows.next
    assert_equal [1, 4, 6, 4, 1], rows.next
    assert_equal [1, 5, 10, 10, 5, 1], rows.next
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The exciting thing about this implementation is we can treat our sequence like a collection and call enumerable methods. We can also chain enumerable methods like &lt;code&gt;Enumerator#with_index&lt;/code&gt; and &lt;code&gt;Enumerator#each&lt;/code&gt; to print a &amp;ldquo;pretty&amp;rdquo; triangle of each row with its row number.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascals_triangle.with_index(1).take(10).each do |row, i|
  puts &amp;quot;%d:%#{20+(row.inspect.length/2)}s&amp;quot; % [i, row.inspect]
end

1:                  [1]
2:                 [1, 1]
3:               [1, 2, 1]
4:              [1, 3, 3, 1]
5:            [1, 4, 6, 4, 1]
6:          [1, 5, 10, 10, 5, 1]
7:        [1, 6, 15, 20, 15, 6, 1]
8:      [1, 7, 21, 35, 35, 21, 7, 1]
9:    [1, 8, 28, 56, 70, 56, 28, 8, 1]
10: [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]

=&amp;gt;
[[[1], 1],
 [[1, 1], 2],
 [[1, 2, 1], 3],
 [[1, 3, 3, 1], 4],
 [[1, 4, 6, 4, 1], 5],
 [[1, 5, 10, 10, 5, 1], 6],
 [[1, 6, 15, 20, 15, 6, 1], 7],
 [[1, 7, 21, 35, 35, 21, 7, 1], 8],
 [[1, 8, 28, 56, 70, 56, 28, 8, 1], 9],
 [[1, 9, 36, 84, 126, 126, 84, 36, 9, 1], 10]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the return value combines the each row with its index, an interesting outcome of how enumerator
chains can augment the enumerated values.&lt;/p&gt;

&lt;p&gt;We can also take advantage of &lt;code&gt;Enumerator#lazy&lt;/code&gt; to operate on rows without relying on eager evaluation. Here we use a lazy enumerator chain to demonstrate that the sum of numbers in each row is 2^n:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;pascals_triangle.lazy.map { |row| Math.log(row.reduce(:+), 2) }.take_while { |n| n &amp;lt; 9 }.force
=&amp;gt; [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enumerators allow us to provide an enumerable interface to generated data in much the same way we do for collections. Try test-driving an enumerable implementation of &lt;a href="https://edublognss.wordpress.com/2013/04/16/famous-mathematical-sequences-and-series/"&gt;other sequences&lt;/a&gt; on your own.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Infinite Sequences in Ruby</title>
    <link rel="alternate" href="/blog/infinite-sequences-in-ruby.html"/>
    <id>/blog/infinite-sequences-in-ruby.html</id>
    <published>2015-11-20T19:00:00-05:00</published>
    <updated>2015-11-20T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Functional languages like Clojure have &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;. Sequences are pretty amazing: they let us treat algorithms as data structures. We can call functions on the data as it is produced, allowing us to interact with the results like a collection even when...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Functional languages like Clojure have &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;. Sequences are pretty amazing: they let us treat algorithms as data structures. We can call functions on the data as it is produced, allowing us to interact with the results like a collection even when the sequence is infinite.&lt;/p&gt;

&lt;p&gt;The Ruby standard library doesn’t have an official sequence class or module, but we can get pretty far with the &lt;code&gt;Enumerable&lt;/code&gt; module. Rubyists are typically introduced to &lt;code&gt;Enumerable&lt;/code&gt; through methods on &lt;code&gt;Array&lt;/code&gt;,  like &lt;code&gt;#map&lt;/code&gt; and &lt;code&gt;#select&lt;/code&gt;. Arrays like &lt;code&gt;[1,2,3,4]&lt;/code&gt; may be thought of as finite, eagerly loaded sequences; they already contains all the members we want to enumerate with methods. We can also extend this API to sequences like “give me multiples of 5” in Ruby.&lt;/p&gt;

&lt;h3&gt;Enumerable Fibonacci&lt;/h3&gt;

&lt;p&gt;Consider an infinite sequence like fibonacci. We could create a method that generates the first &lt;code&gt;n&lt;/code&gt; fibonacci members given &lt;code&gt;n&lt;/code&gt; as a paramter. This implementation could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def eager_fibonacci(n)
  a = b = 1
  result = []

  loop do
    break if result.size &amp;gt;= n

    result &amp;lt;&amp;lt; a
    a, b = b, a + b
  end

  result
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but we can go one step further. Instead of returning an eagerly-loaded array, we can return an &lt;code&gt;Enumerator&lt;/code&gt;. We&amp;rsquo;ll yield each member to the &lt;code&gt;Enumerator&lt;/code&gt; as it is generated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def fibonacci
  Enumerator.new do |y|
    a = b = 1

    loop do
      y &amp;lt;&amp;lt; a
      a, b = b, a + b
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What the heck is an &lt;code&gt;Enumerator&lt;/code&gt;? It’s an enumerable object that can be used for either internal or external enumeration of a collection - for more details, check out my &lt;a href="https://rossta.net/blog/what-is-enumerator.html"&gt;previous post&lt;/a&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; initialize method take a block that acts like a template for an enumerable algorithm. The block takes a parameter, &lt;code&gt;y&lt;/code&gt;, which is an instance of an &lt;code&gt;Enumerator::Yielder&lt;/code&gt;, which let&amp;rsquo;s us yield each member of the &lt;code&gt;Enumerator&lt;/code&gt; to blocks passed to &lt;code&gt;Enumerable&lt;/code&gt; method calls. In short, this means we can treat an &lt;code&gt;Enumerator&lt;/code&gt; like an &lt;code&gt;Array&lt;/code&gt;, though we can also do so much more.&lt;/p&gt;

&lt;p&gt;To retrieve the first ten members of our enumerable fibonacci method, we’d instead do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.take(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can still enumerate over the fibonacci sequence as before:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.take(10).each { |i| puts i }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;Enumerator#lazy&lt;/code&gt; method, we can avoid eager enumeration and run queries or calculations as each member is generated. This opens the door to some interesting use cases, like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.lazy.select(&amp;amp;:even?).first(10)
#=&amp;gt; [2, 8, 34, 144, 610, 2584, 10946, 46368, 196418, 832040]

fibonacci.lazy.select(&amp;amp;:odd?).first(10)
#=&amp;gt; [1, 1, 3, 5, 13, 21, 55, 89, 233, 377]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can filter for the first 10 even or odd numbers generated by fibonacci. Inserting the &lt;code&gt;with_index&lt;/code&gt; enumerator method, we can see how many items we need to enumerate to get either the first 10 even or odd numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;fibonacci.lazy.with_index.select { |n, i| n.odd? }.first(10)
#=&amp;gt; [[1, 0], [1, 1], [3, 3], [5, 4], [13, 6], [21, 7], [55, 9], [89, 10], [233, 12], [377, 13]]

fibonacci.lazy.with_index.select { |n, i| n.even? }.first(10)
#=&amp;gt; [[2, 2], [8, 5], [34, 8], [144, 11], [610, 14], [2584, 17], [10946, 20], [46368, 23], [196418, 26], [832040, 29]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice we only need to enumerate 13 items to retrieve 10 odd numbers from fibonacci, while 29 are needed to retrieve the first 10 evens. These results wouldn’t be easily achieved with our previous fibonacci implementation in which the number of desired members must be known ahead of time.&lt;/p&gt;

&lt;p&gt;Try creating other numerical sequences with enumerators on your own, like multiples of &lt;code&gt;n&lt;/code&gt;, factorials for the first &lt;code&gt;n&lt;/code&gt; integers or enumerating sums of squares. Also be sure to check out Pat Shaughnessy&amp;rsquo;s &lt;a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy"&gt;great primer on lazy enumerators&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Sequence Functions&lt;/h3&gt;

&lt;p&gt;Clojure also has a number of useful functions that allow us to generate sequences from other functions. Let’s look at &lt;code&gt;repeatedly&lt;/code&gt; which simply calls the given function over and over, emitting the results as a sequence. To get a sequence of five random numbers between 0 - 100:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;(take 5 (repeatedly #(rand-int 100)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For those new to Clojure, the syntax may look odd, but this expression &amp;ldquo;takes the first 5 results of repeatedly asking for a random integer of 0 to 100&amp;rdquo; and returns a sequence.&lt;/p&gt;

&lt;p&gt;We can use Ruby enumerators to do something similar in Ruby. Let’s create our own version of &lt;code&gt;repeatedly&lt;/code&gt;, which takes a will call a given block over and over again. Let&amp;rsquo;s start with a naive implementation which use a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly_foo(&amp;amp;block)
 loop do
    block.call
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method is not useful because the function will never return; it&amp;rsquo;s an infinite loop! You’ll have to issue a kill signal to stop the execution (Ctrl-C!). We could give &lt;code&gt;repeatedly_foo&lt;/code&gt; a limit &lt;code&gt;n&lt;/code&gt; and break out of the loop with a counter.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly_foo(n, &amp;amp;block)
  result = []

  loop do
    break if result.size &amp;gt;= n

    result &amp;lt;&amp;lt; block.call
  end

  result
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an improvement, but like our fibonacci example earlier, it means we need to load the desired number eagerly in the &lt;code&gt;result&lt;/code&gt; array and have less control over the results.&lt;/p&gt;

&lt;p&gt;Again, we&amp;rsquo;ll wrap the loop in an &lt;code&gt;Enumerator&lt;/code&gt; so we can treat the result as a sequence. We’ll “yield” the result of calling the block to the &lt;code&gt;Enumerator::Yielder&lt;/code&gt; object (the &lt;code&gt;y &amp;lt;&amp;lt; block.call&lt;/code&gt;) expression in our loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def repeatedly(&amp;amp;block)
  Enumerator.new do |y|
    loop do
      y &amp;lt;&amp;lt; block.call # &amp;quot;yield&amp;quot; the result to the Enumerator::Yielder
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an abstraction that can be chained to other enumerator methods. It also has a similar terse feel to the Clojure inspiration we saw earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;repeatedly { rand(100) }.take(5)
#=&amp;gt; [48, 48, 72, 41, 70] # your results will vary... they&amp;#39;re random!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;To Infinity and Beyond&lt;/h3&gt;

&lt;p&gt;Of course, sequences of numbers aren&amp;rsquo;t the only concept that can be modeled this way in Ruby. Any collection of unknown size, for example, results from a search query, paginated resources from an API client library, data from a web crawl, etc., are also great use cases for exposure as enumerables. Consider wrapping your generated collections in an Enumerator to provide callers with flexible, composable results.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What the Heck is a Ruby Enumerator?</title>
    <link rel="alternate" href="/blog/what-is-enumerator.html"/>
    <id>/blog/what-is-enumerator.html</id>
    <published>2015-11-17T19:00:00-05:00</published>
    <updated>2015-11-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;Let’s pretend we know about Ruby’s &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module - that it’s included in
Ruby’s core collection classes like Array and Hash and provides a bunch of
methods for traversal, searching and sorting, and that we can can introduce it
to plain old ruby...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Let&amp;rsquo;s pretend we know about Ruby&amp;rsquo;s &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module - that it&amp;rsquo;s included in
Ruby&amp;rsquo;s core collection classes like Array and Hash and provides a bunch of
methods for traversal, searching and sorting, and that we can can introduce it
to plain old ruby classes through inclusion and implementing the &lt;code&gt;#each&lt;/code&gt; method.
Check out this &lt;a href="http://ruby.bastardsbook.com/chapters/enumerables/"&gt;dated - yet reliable - Enumerable primer&lt;/a&gt; if you&amp;rsquo;d like a refresher.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://ruby-doc.org/core-2.2.0/Enumerator.html"&gt;Enumerator&lt;/a&gt; is like &lt;code&gt;Enumerable&amp;#39;s&lt;/code&gt; kid sister; while &lt;code&gt;Enumerable&lt;/code&gt; is getting all the attention, &lt;code&gt;Enumerator&lt;/code&gt;, having borrowed many traits of her sibling, can do lots of amazing things in her own way and really should get more credit. Well, it&amp;rsquo;s time you took notice, Ma.&lt;/p&gt;

&lt;p&gt;So what exactly is &lt;code&gt;Enumerator&lt;/code&gt;?. For one, it&amp;rsquo;s a class. You can instantiate an
instance of &lt;code&gt;Enumerator&lt;/code&gt; by calling certain &lt;code&gt;Enumerable&lt;/code&gt; instance methods, like &lt;code&gt;Array#each&lt;/code&gt;, without a block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[1, 2, 3].each
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:each&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, you can do this for many (but not all) of Array&amp;rsquo;s &lt;code&gt;Enumerable&lt;/code&gt; methods
that expect a block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;[1, 2, 3].map
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:map&amp;gt;

[1, 2, 3].select
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:select&amp;gt;

[1, 2, 3].reduce
LocalJumpError: no block given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, big deal. What does this get us? Glad you asked.&lt;/p&gt;

&lt;p&gt;Instances of Enumerator are enumerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map
e.each { |n| p n }
1
2
3
=&amp;gt; [nil, nil, nil]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See what happened there? The expression printed out each digit, but returned &lt;code&gt;[nil, nil, nil]&lt;/code&gt; instead of of &lt;code&gt;[1, 2, 3]&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; implemented &lt;code&gt;map&lt;/code&gt; in the context of &lt;code&gt;each&lt;/code&gt;; since &lt;code&gt;p n&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, we got three entries of &lt;code&gt;nil&lt;/code&gt; in the return value. We chained the behavior of two enumerable methods.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another example. It&amp;rsquo;s often useful to enumerate collection members along
with the index. We can use &lt;code&gt;Enumerable#each_with_index&lt;/code&gt;, we don&amp;rsquo;t have
&lt;code&gt;Enumerable#map_with_index&lt;/code&gt;. Javascript &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; gets this right, but not Ruby&amp;hellip; or does it?&lt;/p&gt;

&lt;p&gt;Almost - we can chain enumerators together to get effectively the same result:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map
e.each_with_index { |n, i| n * i }
=&amp;gt; [0, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The block receives each member of the original array along with its index
for each iteration. This usage is common enough, that &lt;code&gt;Enumerator&lt;/code&gt; provides
&lt;code&gt;with_index&lt;/code&gt; to give:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].map.with_index { |n, i| n * i }
=&amp;gt; [0, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reads pretty well, eh? What&amp;rsquo;s really interesting here is that enumerators package
up knowledge of a collection and a method with which we want to enumerate.&lt;/p&gt;

&lt;p&gt;We can combine several enumerators in different orders to get different
behaviors. Here&amp;rsquo;s an nice example borrowed from &lt;a href="http://dgiim.github.io/blog/2015/08/24/ruby-enumerators/#the-enumerator-class"&gt;another recent post on the subject&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;letters = %w[a b c d e]

group_1 = letters.reverse_each.group_by.each_with_index do |item, index|
  index % 3
end

group_2 = letters.reverse_each.each_with_index.group_by do |item, index|
  index % 3
end

p group_1
=&amp;gt; {0=&amp;gt;[&amp;quot;e&amp;quot;, &amp;quot;b&amp;quot;], 1=&amp;gt;[&amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;], 2=&amp;gt;[&amp;quot;c&amp;quot;]}

p group_2
=&amp;gt; {0=&amp;gt;[[&amp;quot;e&amp;quot;, 0], [&amp;quot;b&amp;quot;, 3]], 1=&amp;gt;[[&amp;quot;d&amp;quot;, 1], [&amp;quot;a&amp;quot;, 4]], 2=&amp;gt;[[&amp;quot;c&amp;quot;, 2]]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Enumerator&lt;/code&gt; provides some additional methods that allow for &amp;ldquo;external&amp;rdquo;
enumeration as well. With an enumerator instance, we can call &lt;code&gt;next&lt;/code&gt; to get each
successive member of the collection.&lt;/p&gt;

&lt;p&gt;Consider &lt;code&gt;Enumerable#cycle&lt;/code&gt;. Calling &amp;ldquo;cycle&amp;rdquo; on an enumerable collection (without a limit arg) will enumerate over members of a collection ad nauseum. When implemented as an enumerator of css colors, we can use &lt;code&gt;cycle&lt;/code&gt; to create striped table rows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Project = Struct.new(:name)

colors = [&amp;#39;aliceblue&amp;#39;, &amp;#39;ghostwhite&amp;#39;].cycle
projects = [Project.new(&amp;quot;TODO&amp;quot;),
            Project.new(&amp;quot;Work&amp;quot;),
            Project.new(&amp;quot;Home&amp;quot;)]

require &amp;#39;erb&amp;#39;

erb = (&amp;lt;&amp;lt;-ERB)
&amp;lt;table&amp;gt;
&amp;lt;% projects.each_with_index do |project, index| %&amp;gt;
 &amp;lt;tr style=&amp;quot;background: &amp;lt;%= colors.next %&amp;gt;&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;&amp;lt;%= index + 1 %&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;&amp;lt;%= project.name %&amp;gt;&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;/table&amp;gt;
ERB

p ERB.new(erb).result(binding).gsub(/^$\n/, &amp;quot;&amp;quot;)

=&amp;gt; &amp;#39;&amp;lt;table&amp;gt;
 &amp;lt;tr style=&amp;quot;background: aliceblue&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;TODO&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
 &amp;lt;tr style=&amp;quot;background: ghostwhite&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;Work&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
 &amp;lt;tr style=&amp;quot;background: aliceblue&amp;quot;&amp;gt;
   &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;Home&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Brilliant! Notice how, in each enumeration of &lt;code&gt;project&lt;/code&gt;, we&amp;rsquo;re calling &lt;code&gt;colors.next&lt;/code&gt;. So external enumeration is one technique for enumerating more than one collection at a time.&lt;/p&gt;

&lt;p&gt;Not all enumerators will enumerate forever. Using cycle with a limit will result
in a &lt;code&gt;StopIteration&lt;/code&gt; error:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;numbers = [1,2].cycle(1)
=&amp;gt; #&amp;lt;Enumerator: [1, 2]:cycle(1)&amp;gt;

numbers.next
# =&amp;gt; 1

numbers.next
=&amp;gt; 2

numbers.next
StopIteration: iteration reached an end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;loop&lt;/code&gt; construct knows how to rescues from this error and treats it as a
&lt;code&gt;break&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;numbers = [1,2].cycle(1)
=&amp;gt; #&amp;lt;Enumerator: [1, 2]:cycle(1)&amp;gt;

loop do
  p numbers.next
end

puts &amp;quot;Tada!&amp;quot;

1
2
=&amp;gt; nil

Tada!
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can rewind enumerators or peek at their next values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;e = [1, 2, 3].each

e.next
=&amp;gt; 1

e.peek
=&amp;gt; 2

e.next
=&amp;gt; 2

e.rewind
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:each&amp;gt;

e.next
=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So enumerators give us flexible and composable uses for enumerables. Combine them to extend behavior of existing enumerable methods. Use them for external enumeration with methods like &lt;code&gt;#next&lt;/code&gt; and &lt;code&gt;#peek&lt;/code&gt; for iterating over multiple arrays. In a future post, we&amp;rsquo;ll take a look at how to create our own enumerators outside the context of arrays and hashes and some good reasons for doing so.&lt;/p&gt;

&lt;p&gt;In case you missed it, &lt;a href="blog/ruby-enumerable.html"&gt;check out my presentation in the previous post&lt;/a&gt; on the &lt;code&gt;Enumerable&lt;/code&gt; module for more examples on how to get the most out of this terrific Ruby module.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Enumerable - Why I Fell in Love with Ruby</title>
    <link rel="alternate" href="/blog/ruby-enumerable.html"/>
    <id>/blog/ruby-enumerable.html</id>
    <published>2015-11-16T19:00:00-05:00</published>
    <updated>2015-11-16T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;I like to say I started programming by accident. While facilitating a Lego robotics club during my teaching years, I was surprised to realize how much I enjoyed coding. Later, when I first learned Ruby as a full-time developer, I rediscovered that...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;I like to say I started programming by accident. While facilitating a Lego robotics club during my teaching years, I was surprised to realize how much I enjoyed coding. Later, when I first learned Ruby as a full-time developer, I rediscovered that joy.&lt;/p&gt;

&lt;p&gt;A big reason for my love of Ruby is the &lt;a href="http://ruby-doc.org/core-2.2.3/Enumerable.html"&gt;Enumerable&lt;/a&gt; module because of its simple, functional style and ability to be combined and chained to form useful constructs - a lot like Legos.&lt;/p&gt;

&lt;p&gt;I recently gave a talk at both &lt;a title="NYC.rb" href="http://www.meetup.com/NYC-rb/events/223864932/"&gt;NYC.rb&lt;/a&gt; and &lt;a title="DC Ruby User's Group" href="http://www.meetup.com/dcruby/events/225338026/"&gt;DCRUG&lt;/a&gt; about some great features of &lt;code&gt;Enumerable&lt;/code&gt; that deserve more attention. I touch on interesting use cases for using &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Enumerator&lt;/code&gt; including API client libraries, streaming HTTP, web crawlers, CSV parsing, and infinite sequences.&lt;/p&gt;

&lt;script async class="speakerdeck-embed" data-id="df623bc08aa642328c303a619c92fab0" data-ratio="1.55386949924127" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

&lt;p&gt;I put together a bunch of code samples for the talk and assembled them in a repository on GitHub:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/loves-enumerable"&gt;https://github.com/rossta/loves-enumerable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To run a sample, clone the repo and install the gems:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ git clone https://github.com/rossta/loves-enumerable.git
$ cd loves-enumerable
$ bundle install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then simply run the code with the ruby executable.&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ ruby code/pascals_triangle.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll get the most out of this repo by inspecting the source along with following the presentation.&lt;/p&gt;
</content>
  </entry>
</feed>
